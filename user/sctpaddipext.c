/* SCTP reference Implementation Copyright (C) 2001 Cisco Systems Inc.This file is part of the SCTP reference ImplementationVersion:4.0.5$Header: /home/sourceTree/src/sctp/user/sctpaddipext.c,v 1.16 2001/07/24 11:52:39 randall Exp $The SCTP reference implementation  is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published bythe Free Software Foundation; either version 2, or (at your option)any later version.the SCTP reference implementation  is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of                ************************MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See theGNU Library General Public License for more details.You should have received a copy of the GNU Library General Public Licensealong with GNU CC; see the file COPYING.  If not, write tothe Free Software Foundation, 59 Temple Place - Suite 330,Boston, MA 02111-1307, USA.  Please send any bug reports or fixes you make to one of the following emailaddresses:rrs@cisco.comkmorneau@cisco.comAny bugs reported given to us we will try to fix... any fixes shared willbe incorperated into the next SCTP release.There are still LOTS of bugs in this code... I always run on the motto"it is a wonder any code ever works :)"*/#include <sctpaddipext.h>#include <sctputil.h>intSCTP_processAddAddress(struct SCTP *m,		       struct SCTP_association *asoc,		       u_short ptype,		       ushort plen,		       struct sctpParamDesc *inreq,		       struct sctpParamDesc *replyParam){  struct sctpParamDesc *addressParam;  int type,ret,olen;  ret = 0;  addressParam = inreq + 1;  type = ntohs(addressParam->paramType);  switch(type){  case SCTP_IPV4_PARAM_TYPE:  case SCTP_IPV6_PARAM_TYPE:    /* We can add this type, do so */    {      int newsz;      struct SCTP_nets *newnets;      newsz = asoc->numnets + 1;      newnets = w_calloc(m,newsz,sizeof(struct SCTP_nets));      if(newnets == NULL){		struct sctpOpErrorCause *errCause;	char *copyTo;	ret = 1;	SCTPdebugPrint(m,"Can't add a IP address, no memory!\n");	olen = plen + sizeof(struct sctpOpErrorCause) + sizeof(struct sctpParamDesc);	replyParam->paramType = htons(SCTP_ERROR_CAUSE_TLV);	replyParam->paramLength = htons(olen);	errCause = (struct sctpOpErrorCause *)((u_long)replyParam + sizeof(struct sctpParamDesc));	errCause->cause = htons(SCTP_OP_ERROR_RESOURCE_SHORT); /* no memory is kind of a resource shortage :) */	errCause->causeLen = htons((olen-sizeof(struct sctpParamDesc)));	copyTo = (char *)((u_long)errCause + sizeof(struct sctpOpErrorCause));	memcpy(copyTo,(char *)inreq,plen);	return(ret);      }      /* First copy in the stuff from the current array */      memcpy((char *)newnets,	     (char *)asoc->nets,	     (asoc->numnets * sizeof(struct SCTP_nets)));      /* Now setup the address from the added one */      if(type == SCTP_IPV4_PARAM_TYPE){	struct sockaddr_in from;	struct sctpV4IpAddress *point;	memset(&from,0,sizeof(from));	point = (struct sctpV4IpAddress *)addressParam;	from.sin_family = AF_INET;	from.sin_addr.s_addr = point->ipAddress;	/* copy port from net[0]. */	/* cheat here and cast to sockaddr_in, since port has same location */	from.sin_port = ((struct sockaddr_in *)asoc->nets[0].ina)->sin_port;#ifdef USES_BSD_4_4_SOCKET	from.sin_len = sizeof(struct sockaddr_in);#endif	SCTPdebugPrint(m,"Adding IP\n");	SCTPdebugPrintAddress(m,(struct sockaddr *)&from);	/* now Init all those new params with the proper address */	SCTPinitNetStruct(m,asoc,&newnets[asoc->numnets],(struct sockaddr *)&from);	if(HashedTbl_enter(m->allAssoc,(void *)newnets[asoc->numnets].ina,			   (void *)asoc,			   sizeof(struct sockaddr_in)) != LIB_STATUS_GOOD){	  SCTPdebugPrint(m,"Hashing of new address IPv4 fails\n");	}      }else{	  	struct sctpV6IpAddress *point6;	struct sockaddr_in6 from6;	memset(&from6,0,sizeof(from6));	point6 = (struct sctpV6IpAddress *)addressParam;	from6.sin6_family = AF_INET6;	memcpy((char *)&from6.sin6_addr,	       point6->ipAddress,sizeof(struct in6_addr));	/* copy port from net[0]. */	/* cheat here and cast to sockaddr_in, since port has same location */	from6.sin6_port = ((struct sockaddr_in6 *)asoc->nets[0].ina)->sin6_port;#ifdef USES_BSD_4_4_SOCKET	from6.sin6_len = sizeof(struct sockaddr_in6);#endif	SCTPdebugPrint(m,"Adding a address\n");	SCTPdebugPrintAddress(m,(struct sockaddr *)&from6);	/* now Init all those new params with the proper address */	SCTPinitNetStruct(m,asoc,&newnets[asoc->numnets],(struct sockaddr *)&from6);	if(HashedTbl_enter(m->allAssoc,(void *)newnets[asoc->numnets].ina,			   (void *)asoc,			   sizeof(struct sockaddr_in6)) != LIB_STATUS_GOOD){	  SCTPdebugPrint(m,"Hashing of new address IPv6 fails\n");	}      }      w_free(m,(char *)asoc->nets);      asoc->nets = newnets;      asoc->numnets++;    }    break;  default:    /* unsupported address type, build a error     *  reply type.     */    {      struct sctpOpErrorCause *errCause;      char *copyTo;      ret = 1;      SCTPdebugPrint(m,"Can't add an IP address, unsupported address type:%d!\n",type);            olen = plen + sizeof(struct sctpOpErrorCause) + sizeof(struct sctpParamDesc);      SCTPdebugPrint(m,"Plen:%d operr:%d param:%d tot=%d\n",		     plen,sizeof(struct sctpOpErrorCause),sizeof(struct sctpParamDesc),		     olen);      replyParam->paramType = htons(SCTP_ERROR_CAUSE_TLV);      replyParam->paramLength = htons(olen);      errCause = (struct sctpOpErrorCause *)((u_long)replyParam + sizeof(struct sctpParamDesc));      errCause->cause = htons(SCTP_OP_ERROR_DNS_FAILED); /* this is the unresolveable address type */      errCause->causeLen = htons((olen-sizeof(struct sctpParamDesc)));      copyTo = (char *)((u_long)errCause + sizeof(struct sctpOpErrorCause));      memcpy(copyTo,(char *)inreq,plen);    }    break;  }  return(ret);}intSCTP_processDelAddress(struct SCTP *m,		       struct SCTP_association *asoc,		       u_short ptype,		       ushort plen,		       struct sctpParamDesc *inreq,		       struct sctpParamDesc *replyParam){  struct SCTP_association *lasoc;  struct sctpParamDesc *addressParam;  struct SCTP_nets *newnets;  int indx,ret,olen,type;  struct sctpV4IpAddress *point;  struct sctpV6IpAddress *point6;  ret = 0;  addressParam = inreq + 1;  type = ntohs(addressParam->paramType);  SCTPdebugPrint(m,"Processing DELETE IP address type:%d\n",type);  lasoc = NULL;  switch(type){  case SCTP_IPV4_PARAM_TYPE:  case SCTP_IPV6_PARAM_TYPE:    /* We can delete this one if it is in the association.     * We need to:     * - find the association again and see if the address is in it.     * - remove it (if it is not the last address).     * - verify that a HB has not been sent, if so we need to      *   change the flag to pretend that a HB has not been sent     */    {      if(type == SCTP_IPV4_PARAM_TYPE){	struct sockaddr_in x;	point = (struct sctpV4IpAddress *)addressParam;	SCTPdebugPrint(m,"Deleting IPv4 address\n");	memset(&x,0,sizeof(x));	x.sin_port = ((struct sockaddr_in *)asoc->nets[0].ina)->sin_port;	x.sin_family = AF_INET;	x.sin_addr.s_addr = point->ipAddress;#ifdef USES_BSD_4_4_SOCKET	x.sin_len = sizeof(struct sockaddr_in);#endif	lasoc = SCTPfindAssociation(m,(struct sockaddr *)&x,&indx);      }else if(type == SCTP_IPV6_PARAM_TYPE){	struct sockaddr_in6 x6;	point6 = (struct sctpV6IpAddress *)addressParam;	SCTPdebugPrint(m,"Deleting IPv6 address\n");	memset(&x6,0,sizeof(x6));	x6.sin6_port = ((struct sockaddr_in6 *)asoc->nets[0].ina)->sin6_port;#ifdef USES_BSD_4_4_SOCKET	x6.sin6_len = sizeof(struct sockaddr_in6);#endif	x6.sin6_family = AF_INET6;	memcpy((char *)&x6.sin6_addr,	       point6->ipAddress,sizeof(struct in6_addr));	lasoc = SCTPfindAssociation(m,(struct sockaddr *)&x6,&indx);      }      if(lasoc == asoc){	/* ok, we found it */	SCTPdebugPrint(m,"Found it indx:%d\n",indx);	if(asoc->numnets == 1){	  /* error, we are not allowed to remove the last net */	  struct sctpOpErrorCause *errCause;	  char *copyTo;	  ret = 1;	  SCTPdebugPrint(m,"Can't delete the last address in an association\n");	  olen = plen + sizeof(struct sctpOpErrorCause) + sizeof(struct sctpParamDesc);	  replyParam->paramType = htons(SCTP_ERROR_CAUSE_TLV);	  replyParam->paramLength = htons(olen);	  errCause = (struct sctpOpErrorCause *)((u_long)replyParam + sizeof(struct sctpParamDesc));	  errCause->cause = htons(SCTP_OP_ERROR_DELETE_LAST);	  errCause->causeLen = htons((olen-sizeof(struct sctpParamDesc)));	  copyTo = (char *)((u_long)errCause + sizeof(struct sctpOpErrorCause));	  memcpy(copyTo,(char *)inreq,plen);	}else{	  /* Ok, we are set to purge the address */	  int newsz;	  newsz = asoc->numnets -1 ;	  newnets = w_calloc(m,newsz,sizeof(struct SCTP_nets));	  SCTPdebugPrint(m,"Allocating new address stuff smaller(%d)\n",newsz);	  if(newnets == NULL){		    struct sctpOpErrorCause *errCause;	    char *copyTo;	    ret = 1;	    SCTPdebugPrint(m,"Can't delete an IP address, no memory!\n");	    olen = plen + sizeof(struct sctpOpErrorCause) + sizeof(struct sctpParamDesc);	    replyParam->paramType = htons(SCTP_ERROR_CAUSE_TLV);	    replyParam->paramLength = htons(olen);	    errCause = (struct sctpOpErrorCause *)((u_long)replyParam + sizeof(struct sctpParamDesc));	    errCause->cause = htons(SCTP_OP_ERROR_RESOURCE_SHORT); /* no memory is kind of a resource shortage :) */	    errCause->causeLen = htons((olen-sizeof(struct sctpParamDesc)));	    copyTo = (char *)((u_long)errCause + sizeof(struct sctpOpErrorCause));	    memcpy(copyTo,(char *)inreq,plen);	  }else{	    int i,j;	    /* remove indx from hash table */	    SCTPdebugPrint(m,"Time to do the hash remove\n");	    if(asoc->nets[indx].ina->sa_family == AF_INET){	      HashedTbl_remove(m->allAssoc,			       (void *)asoc->nets[indx].ina,			       sizeof(struct sockaddr_in),			       (void **)NULL);	    }else if(asoc->nets[indx].ina->sa_family == AF_INET6){	      HashedTbl_remove(m->allAssoc,			       (void *)asoc->nets[indx].ina,			       sizeof(struct sockaddr_in6),			       (void **)NULL);	    }	    /* copy in the relevant parts */	    SCTPdebugPrint(m,"Copy in the net structs\n");	    for(i=0,j=0;i<indx;i++){	      memcpy((char *)&newnets[j],		     (char *)&asoc->nets[i],sizeof(struct SCTP_nets));	      j++;	    }	    for(i=indx+1;i<asoc->numnets;i++){	      memcpy((char *)&newnets[j],		     (char *)&asoc->nets[i],sizeof(struct SCTP_nets));	      j++;	    }	    /* Here we just cancel out the fact that we	     * really sent a heartbeat, since if we	     * were just awaiting a response, it would	     * foul things up after we were done	     */	    if(asoc->lastHBOn == indx){	      asoc->reallySentHB = 0;	    }	    SCTPdebugPrint(m,"Freeing net old\n");	    w_free(m,m->localNets[indx]);	    w_free(m,(char *)asoc->nets);	    asoc->nets = newnets;	    asoc->numnets--;	    if(asoc->lastHBOn >= asoc->numnets)	      asoc->lastHBOn = 0;	  }	}      }else{	SCTPdebugPrint(m,"Hmm, asoc:%x not the same for lassoc:%x\n",		       (u_int)asoc,(u_int)lasoc);      }      /* If it is part of another association then we have a hacker or       * a software error on the other end. But since it is not part       * of this association I can pretend that everything is fine.       */    }    break;  default:    /* unsupported address type, here we take     *  a different approach.. If you are deleting an address     * and I don't understand it... I don't have it... so the     * response is ok, since I don't have the address in the     * association.     */    break;  }  SCTPdebugPrint(m,"Ret %d\n",ret);  return(ret);}intSCTP_processSetPrimary(struct SCTP *m,		       struct SCTP_association *asoc,		       u_short ptype,		       ushort plen,		       struct sctpParamDesc *inreq,		       struct sctpParamDesc *replyParam){  struct sctpParamDesc *addressParam;  struct SCTP_association *lasoc;  int type,ret,olen,indx;  ret = 0;  addressParam = inreq + 1;  lasoc = NULL;  type = ntohs(addressParam->paramType);  switch(type){  case SCTP_IPV4_PARAM_TYPE:  case SCTP_IPV6_PARAM_TYPE:    {      /* Now setup the address from the one to mark as primary */      if(type == SCTP_IPV4_PARAM_TYPE){	struct sockaddr_in x;	struct sctpV4IpAddress *point;	point = (struct sctpV4IpAddress *)addressParam;	memset(&x,0,sizeof(x));	x.sin_port = ((struct sockaddr_in *)asoc->nets[0].ina)->sin_port;	x.sin_family = AF_INET;	x.sin_addr.s_addr = point->ipAddress;#ifdef USES_BSD_4_4_SOCKET	x.sin_len = sizeof(struct sockaddr_in);#endif	lasoc = SCTPfindAssociation(m,(struct sockaddr *)&x,&indx);      }else if(type == SCTP_IPV6_PARAM_TYPE){	struct sockaddr_in6 x6;	struct sctpV6IpAddress *point6;	point6 = (struct sctpV6IpAddress *)addressParam;	memset(&x6,0,sizeof(x6));	x6.sin6_port = ((struct sockaddr_in6 *)asoc->nets[0].ina)->sin6_port;#ifdef USES_BSD_4_4_SOCKET	x6.sin6_len = sizeof(struct sockaddr_in6);#endif	x6.sin6_family = AF_INET6;	memcpy((char *)&x6.sin6_addr,	       point6->ipAddress,	       sizeof(struct in6_addr));	lasoc = SCTPfindAssociation(m,(struct sockaddr *)&x6,&indx);      }      if(lasoc == asoc){	/* Ok set it as primary and we are done */	SCTPdebugPrint(m,"Set primary for IP address idx:[%d] old primary was %d\n",		       indx,		       asoc->primary_destination);	asoc->primary_destination = indx;	break;      }    }    /* FALL THROUGH... if we can't find the address, it is an     * error and we fall through to return the unresovlable     * address error.     */  default:    /* unsupported address type, build a error     *  reply type.     */    {      struct sctpOpErrorCause *errCause;      char *copyTo;      ret = 1;      SCTPdebugPrint(m,"Can't add an IP address, unsupported address type!\n");            olen = plen + sizeof(struct sctpOpErrorCause) + sizeof(struct sctpParamDesc);      replyParam->paramType = htons(SCTP_ERROR_CAUSE_TLV);      replyParam->paramLength = htons(olen);      errCause = (struct sctpOpErrorCause *)((u_long)replyParam + sizeof(struct sctpParamDesc));      errCause->cause = htons(SCTP_OP_ERROR_DNS_FAILED); /* this is the unresolveable address type */      errCause->causeLen = htons((olen-sizeof(struct sctpParamDesc)));      copyTo = (char *)((u_long)errCause + sizeof(struct sctpOpErrorCause));      memcpy(copyTo,(char *)inreq,plen);    }    break;  }  return(ret);}intSCTPcheckListConsistency(struct SCTP *m,			 struct SCTP_association *asoc,			 struct sockaddr **newlist,			 int numnets){  int cntOfFnd,i,j,jstart,fndIt;  int locScope,siteScope,ipv4Scope,cntRequired;  struct sockaddr_in *p;  struct sockaddr_in6 *p6;  locScope = asoc->locScope;  siteScope = asoc->siteScope;  ipv4Scope = asoc->ipv4Scope;  cntRequired = 0;  SCTPdebugPrint(m,"Scoping rules are loc:%d site:%d ipv4:%d\n",		 locScope,		 siteScope,		 ipv4Scope);  for(j=0;j<m->numberOfNets;j++){    if(m->localNets[j]->sa_family == AF_INET){      p = (struct sockaddr_in *)m->localNets[j];          if((ipv4Scope == 0) && (IN4_ISPRIVATE_ADDRESS(&p->sin_addr))){	/* not local scope and a private address, can't count */	SCTPdebugPrint(m,"Skipping IPV4 Private address at %d\n",j);	continue;      }      SCTPdebugPrint(m,"Adding IPV4 address at %d to count\n",j);      cntRequired++;    }else if(m->localNets[j]->sa_family == AF_INET6){      p6 = (struct sockaddr_in6 *)m->localNets[j];          if(IN6_IS_ADDR_LINKLOCAL(&p6->sin6_addr)){	SCTPdebugPrint(m,"Skipping IPV6 Link Local address at %d\n",j);	continue;      }else if((siteScope == 0) && IN6_IS_ADDR_SITELOCAL(&p6->sin6_addr)){	SCTPdebugPrint(m,"Skipping IPV6 Site Local address at %d\n",j);	continue;      }      SCTPdebugPrint(m,"Adding IPV6 address at %d to count\n",j);      cntRequired++;    }  }  if(locScope){    /* local scope for v6 is set, so we must have one LL address     * in the association.     */    cntRequired++;    SCTPdebugPrint(m,"Adding one for the link local scope\n");  }  SCTPdebugPrint(m,"Total counted addresses are %d out of %d\n",		 cntRequired,m->numberOfNets);  if(numnets != cntRequired){    /* can't be consistent, not the same size */    SCTPdebugPrint(m,"NOP! cannot be consistent, numnets:%d != actual:%d\n",		   numnets,cntRequired);    return(0);  }  SCTPdebugPrint(m,"The hunt for red october begins\n");  cntOfFnd = 0;  for(i=0,j=0;i<numnets;i++){    jstart = j;    fndIt = 0;    SCTPdebugPrint(m,"Look for address %d in list:\n",i);    SCTPdebugPrintAddress(m,newlist[i]);    for(;j<m->numberOfNets;j++){      if(newlist[i]->sa_family != m->localNets[j]->sa_family){	/* not same type, can't be equal */	SCTPdebugPrint(m,"Disjoint family at i:%d/j:%d\n",i,j);	continue;      }      if(newlist[i]->sa_family == AF_INET){	p = (struct sockaddr_in *)m->localNets[j];	if(((struct sockaddr_in *)newlist[i])->sin_addr.s_addr ==  p->sin_addr.s_addr){	  cntOfFnd++;	  SCTPdebugPrint(m,"IPV4:j at %d matches  i at %d\n",j,i);	  fndIt = 1;	  break;	}      }else if(newlist[i]->sa_family == AF_INET6){	if(IN6_ARE_ADDR_EQUAL(&((struct sockaddr_in6 *)newlist[i])->sin6_addr, 			      &((struct sockaddr_in6 *)m->localNets[j])->sin6_addr)){	  cntOfFnd++;	  SCTPdebugPrint(m,"IPV6:j at %d matches  i at %d\n",j,i);	  fndIt = 1;	  break;	}      }    }    if(fndIt){      SCTPdebugPrint(m,"Iteration i:%d ends at first match\n",i);      continue;    }    SCTPdebugPrint(m,"Not found in %d to %d look from 0 to %d\n",		   jstart,m->numberOfNets,		   (j-1));    for(j=0;j<jstart;j++){      if(newlist[i]->sa_family != m->localNets[j]->sa_family)	/* not same type, can't be equal */	continue;      if(newlist[i]->sa_family == AF_INET){	struct sockaddr_in *p;	p = (struct sockaddr_in *)m->localNets[j];	if(((struct sockaddr_in *)newlist[i])->sin_addr.s_addr ==  p->sin_addr.s_addr){	  cntOfFnd++;	  SCTPdebugPrint(m,"j at %d matches  i at %d\n",j,i);	  fndIt = 1;	  break;	}      }else if(newlist[i]->sa_family == AF_INET6){	if(IN6_ARE_ADDR_EQUAL(&((struct sockaddr_in6 *)newlist[i])->sin6_addr, 			      &((struct sockaddr_in6 *)m->localNets[j])->sin6_addr)){	  cntOfFnd++;	  SCTPdebugPrint(m,"j at %d matches  i at %d\n",j,i);	  fndIt = 1;	  break;	}      }    }    SCTPdebugPrint(m,"Iteration i:%d ends\n",i);  }  SCTPdebugPrint(m,"Found:%d numnets is %d\n",cntOfFnd,numnets);  if(cntOfFnd == numnets){    /* we found all networks */    return(1);  }else{    return(0);  }}u_intSCTPfindNetMaskFor(struct SCTP *m,		   u_int ipAddress){  int i;  for(i=0;i<m->numberOfNets;i++){    if(m->localNets[i]->sa_family != AF_INET)      continue;    if(ipAddress == ((struct sockaddr_in *)m->localNets[i])->sin_addr.s_addr){      return(m->maskList[i].sin_addr.s_addr);    }  }  /* match the whole thing since we can't find it */  SCTPdebugPrint(m,"Warning, we did not find address %x return netmask:0xffffffff\n",		 ipAddress);  return(0xffffffff);}voidSCTP_handleAddResponse(struct SCTP *m,		       struct SCTP_association *asoc,		       struct sctpParamDesc *request,		       struct sctpParamDesc *reply){  /* We only allow an Add request to be sent, if   * we recognize it has new network in the ifconfig   * list. So the base code (and deamon) already as   * this guy... it is safe to expand the association to   * include this guy. Now key here is that after I am   * done I must do the consistency check thing.   * For failures, we leave alone and   * then make sure we are in "inconsistent mode". User   * can abort if they want (they get a report from the   * caller of this module i.e. the relreq layer).   */  u_short resp;  struct sockaddr **newlist;  struct sockaddr_in *mewlist;  struct sctpV4IpAddress *addingAddress;  struct sctpV6IpAddress *addingAddress6;  struct sctpParamDesc *nextLoc;  int type;  if((resp = ntohs(reply->paramType)) != SCTP_OPERATION_SUCCEED){    SCTPdebugPrint(m,"Add of an address fails, setting inconsistency flag!\n");    asoc->listConsistent = 0;    if(resp == SCTP_UNRECOG_PARAM){      SCTPdebugPrint(m,"Endpoint does not support adding addresses\n");        asoc->supportsDynamicAddress = 0;    }    return;  }  nextLoc = request + 1;  SCTPdebugPrint(m,"Ok lets look at my request addr:%x vs base:%x\n",		 (u_int)nextLoc,(u_int)request);  addingAddress = (struct sctpV4IpAddress *)nextLoc;  type = ntohs(addingAddress->p.paramType);  if((type == SCTP_IPV4_PARAM_TYPE) ||     (type == SCTP_IPV6_PARAM_TYPE)){    /* ok, it looks like we succeeded in adding if we reach here. */    /* First we add the address, then we verify consistency with the     * base m structure     */    SCTPdebugPrint(m,"Yep, IPv4/6 Parameter type need to get %d + 1 more sock structs\n",		   asoc->numberOfNets);    if(asoc->numberOfNetsAlloced >= asoc->numberOfNets){      newlist = w_calloc(m,(asoc->numberOfNets+1),sizeof(struct sockaddr *));      if(newlist == NULL){	/* help, I guess I will consider myself dead since I am	 * out of memory. Worse things will soon happen !!	 */	SCTPdebugPrint(m,"Add of an address fails, no memory WIDSN!\n");	asoc->listConsistent = 0;	return;      }      memcpy(newlist,	     asoc->localNets,	     (asoc->numberOfNets * sizeof(struct sockaddr *)));      w_free(m,asoc->localNets);      asoc->localNets = newlist;      mewlist = w_calloc(m,(asoc->numberOfNets+1),sizeof(struct sockaddr_in));      if(newlist == NULL){	SCTPdebugPrint(m,"Add of an address fails, no memory for netmask WIDSN!\n");	asoc->listConsistent = 0;	return;      }      SCTPdebugPrint(m,"Ok, copy in the old maskList\n");      memcpy(mewlist,	     asoc->maskList,	     (asoc->numberOfNets * sizeof(struct sockaddr_in)));      w_free(m,asoc->maskList);      asoc->maskList = mewlist;    }    SCTPdebugPrint(m,"Ok, fix the last address with our new entry\n");    if(type == SCTP_IPV4_PARAM_TYPE){      struct sockaddr_in *xx;      xx = (struct sockaddr_in *)w_calloc(m,1,sizeof(struct sockaddr_in));      memset(xx,0,sizeof(struct sockaddr_in));      asoc->localNets[asoc->numberOfNets] = (struct sockaddr *)xx;      xx->sin_port = m->port;      xx->sin_family = AF_INET;#ifdef USES_BSD_4_4_SOCKET      xx->sin_len = sizeof(struct sockaddr_in);#endif      xx->sin_addr.s_addr = addingAddress->ipAddress;      /* Now fix the netmask to please */      asoc->maskList[asoc->numberOfNets].sin_family = AF_INET;      asoc->maskList[asoc->numberOfNets].sin_addr.s_addr = SCTPfindNetMaskFor(m,xx->sin_addr.s_addr);    }else if(type == SCTP_IPV6_PARAM_TYPE){      struct sockaddr_in6 *xx6;      addingAddress6 = (struct sctpV6IpAddress *)addingAddress;      xx6 = (struct sockaddr_in6 *)w_calloc(m,1,sizeof(struct sockaddr_in6));      memset(xx6,0,sizeof(struct sockaddr_in6));      asoc->localNets[asoc->numberOfNets] = (struct sockaddr *)xx6;      xx6->sin6_port = m->port;      xx6->sin6_family = AF_INET6;#ifdef USES_BSD_4_4_SOCKET      xx6->sin6_len = sizeof(struct sockaddr_in6);#endif      memcpy((char *)&xx6->sin6_addr,	     addingAddress6->ipAddress,	     sizeof(struct in6_addr));    }    asoc->addrStats[asoc->numberOfNets] = SCTP_ADDR_REACHABLE;  }  asoc->numberOfNets++;      /* Are we consistent, still have not incremented so add one to count (we did copy though) */  asoc->listConsistent = SCTPcheckListConsistency(m,asoc,asoc->localNets,(int)(asoc->numberOfNets));  SCTPdebugPrint(m,"Ok, check consistency of newlist %d returned\n",asoc->listConsistent);}voidSCTP_handleDelResponse(struct SCTP *m,		       struct SCTP_association *asoc,		       struct sctpParamDesc *request,		       struct sctpParamDesc *reply){  struct sctpV4IpAddress *deletingAddress;  struct sctpParamDesc *nextLoc;  int type;  int fnd,indx;  struct sockaddr_in6 xx6;  struct sockaddr_in xx;  u_short resp;  fnd = 0;  if((resp = ntohs(reply->paramType)) != SCTP_OPERATION_SUCCEED){    SCTPdebugPrint(m,"Delete of an address fails, set up  inconsistency flag!\n");    asoc->listConsistent = SCTPcheckListConsistency(m,asoc,asoc->localNets,(int)asoc->numberOfNets);    if(resp == SCTP_UNRECOG_PARAM){      SCTPdebugPrint(m,"Endpoint does not support adding addresses\n");        asoc->supportsDynamicAddress = 0;    }    return;  }  nextLoc = request + 1;  deletingAddress = (struct sctpV4IpAddress *)nextLoc;  type = ntohs(deletingAddress->p.paramType);  if((type == SCTP_IPV4_PARAM_TYPE) ||     (type == SCTP_IPV6_PARAM_TYPE)     ){    if(type == SCTP_IPV4_PARAM_TYPE){      memset(&xx,0,sizeof(xx));      xx.sin_family = AF_INET;      xx.sin_port = m->port;#ifdef USES_BSD_4_4_SOCKET      xx.sin_len = sizeof(struct sockaddr_in);#endif      xx.sin_addr.s_addr = deletingAddress->ipAddress;      fnd = SCTPisToAddressInAssociation(m,asoc,(struct sockaddr *)&xx,&indx,1);    }else if(type == SCTP_IPV6_PARAM_TYPE){      struct sctpV6IpAddress *deletingAddress6;      deletingAddress6 = (struct sctpV6IpAddress *)deletingAddress;      memset(&xx6,0,sizeof(xx6));      xx6.sin6_family = AF_INET6;      xx6.sin6_port = m->port;#ifdef USES_BSD_4_4_SOCKET      xx6.sin6_len = sizeof(struct sockaddr_in6);#endif      memcpy((char *)&xx6.sin6_addr,	     deletingAddress6->ipAddress,	     sizeof(struct in6_addr));      fnd = SCTPisToAddressInAssociation(m,asoc,(struct sockaddr *)&xx6,&indx,1);    }    if(!fnd){      /* Hmm nothing to do since I can't find the one that       * is being deleted ??       */      SCTPdebugPrint(m,"Delete of an address fails, cant find the address\n");      if(type == SCTP_IPV4_PARAM_TYPE){	SCTPdebugPrintAddress(m,(struct sockaddr *)&xx);      }else if(type == SCTP_IPV6_PARAM_TYPE){	SCTPdebugPrintAddress(m,(struct sockaddr *)&xx6);      }      asoc->listConsistent = SCTPcheckListConsistency(m,asoc,asoc->localNets,(int)asoc->numberOfNets);      return;    }    /* Once found, swap it out to be the last entry */    if(indx != (asoc->numberOfNets-1)){      /* Ok, we need to swap indx with asoc->numberOfnets-1 (the last one)        * this allows us to hang on to the one that was last deleted       * even though it goes out of our site in the structure.       */      u_int tmp;      struct sockaddr *tmpy;      SCTPdebugPrint(m,"Swapping addresses at %x for %x\n");      tmpy = asoc->localNets[indx];      asoc->localNets[indx] = asoc->localNets[(asoc->numberOfNets-1)];      asoc->localNets[(asoc->numberOfNets-1)] = tmpy;      /* swap the netmasks around */      tmp = asoc->maskList[indx].sin_addr.s_addr;      asoc->maskList[indx].sin_addr.s_addr = asoc->maskList[(asoc->numberOfNets-1)].sin_addr.s_addr;      /* swap around the address stats flag */      asoc->addrStats[indx] = asoc->addrStats[(asoc->numberOfNets-1)];      asoc->addrStats[(asoc->numberOfNets-1)] = 0;    }    /* now finish up by lowering the count and fixing the consistency */    asoc->numberOfNets--;    asoc->listConsistent = SCTPcheckListConsistency(m,asoc,asoc->localNets,(int)asoc->numberOfNets);  }}voidSCTP_handleSetPrimaryResponse(struct SCTP *m,			      struct SCTP_association *asoc,			      struct sctpParamDesc *request,			      struct sctpParamDesc *reply){  /* Here the only response we care about is NO   * I don't know what you mean. In that case   * we need to disable the setprimary request from   * going to this guy.   */  u_short resp;  resp = ntohs(reply->paramType);  if(resp == SCTP_UNRECOG_PARAM){    SCTPdebugPrint(m,"Set primary fails on remote! It does not understand\n");    asoc->supportsDynamicSetPrim = 0;  }else if(resp == SCTP_OPERATION_SUCCEED){    SCTPdebugPrint(m,"Set primary succeeds!\n");  }else{    SCTPdebugPrint(m,"Set primary fails, reason %x!\n",resp);  }}