/* SCTP reference Implementation Copyright (C) 2001 Cisco Systems Inc.This file is part of the SCTP reference ImplementationVersion:4.0.5$Header: /home/sourceTree/src/sctp/user/sctprelreq.c,v 1.28 2001/07/24 11:52:39 randall Exp $The SCTP reference implementation  is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published bythe Free Software Foundation; either version 2, or (at your option)any later version.the SCTP reference implementation  is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of                ************************MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See theGNU Library General Public License for more details.You should have received a copy of the GNU Library General Public Licensealong with GNU CC; see the file COPYING.  If not, write tothe Free Software Foundation, 59 Temple Place - Suite 330,Boston, MA 02111-1307, USA.  Please send any bug reports or fixes you make to one of the following emailaddresses:rrs@cisco.comkmorneau@cisco.comAny bugs reported given to us we will try to fix... any fixes shared willbe incorperated into the next SCTP release.There are still LOTS of bugs in this code... I always run on the motto"it is a wonder any code ever works :)"*/#include <sctprelreq.h>#include <sctputil.h>#include <dlist.h>#include <sctpsenders.h>#include <sctpaddipext.h>intSCTPqueueARelReq(struct SCTP *m,		 struct SCTP_association *asoc,		 struct sctpParamDesc *param,		 int delaySend){  int sz,ret,ptype;  if(asoc->queueOfRelReq == NULL){    /* E gads, we could not malloc a dlist, we can't do     * rel-req's     */    return(-1);  }  if(asoc->peerCanDoRelReq == 0){    /* peer has told us it cannot do it in a op-err */    SCTPdebugPrint(m,"SORRY PEER CAN'T DO REL-REQ!\n");    return(-2);  }  sz = ntohs(param->paramLength);  ptype = ntohs(param->paramType);  if((sz + sizeof(struct sctpChunkDesc) + sizeof(struct sctpHeader)) > asoc->smallestMTU){    /* This one can not fit in a PMTU, I dis-allow this then and return     * an error.     */    return(-3);  }  SCTPdebugPrint(m,"Appending to dlist \n");  if(ptype != SCTP_ADD_IP_ADDRESS){    /* Deletes and set primaries go on the back */    if(dlist_append(asoc->queueOfRelReq,(void *)param) < LIB_STATUS_GOOD){      /* hmm, appending to the list failed */      return(-1);    }  }else{    /* Adds always go to the very front */    if(dlist_insert(asoc->queueOfRelReq,(void *)param) < LIB_STATUS_GOOD){      /* hmm, appending to the list failed */      return(-1);    }  }  if(delaySend)    return(0);  if(asoc->relReqSent == 0){    /* We must start the timer, even if this send     * fails, since the timer drives both retry's and     * retransmits. Special case is if we get a -2 back,     * this means there is nothing to send.     */    ret = SCTPsendRelReqOut(m,asoc,0);    SCTPdebugPrint(m,"RELREQOUT returns %d\n",ret);    if(ret > -2){      timerWork(m,asoc,		SCTP_TIMER_START,SctpTimerTypeRelReq,		asoc->lastNetSentTo);    }  }  return(0);}voidSCTPdequeueRelReq(struct SCTP *m,		  struct SCTP_association *asoc){  int ret;  if((asoc->relReqSent == 0) &&     (dlist_getCnt(asoc->queueOfRelReq) > 0)     ){    /* We must start the timer, even if this send     * fails, since the timer drives both retry's and     * retransmits. Special case is if we get a -2 back,     * this means there is nothing to send.     */    ret = SCTPsendRelReqOut(m,asoc,0);    SCTPdebugPrint(m,"RELREQOUT returns %d\n",ret);    if(ret > -2){      timerWork(m,asoc,		SCTP_TIMER_START,SctpTimerTypeRelReq,		asoc->lastNetSentTo);    }  }}voidSCTPprocessRelReqTLVs(struct SCTP *m,		      struct SCTP_association *asoc,		      struct sctpParamDesc *ppoint,		      int maxlen,		      u_int sn){  int len,stop,ptype,plen,rlen,rplen;  u_long start,roundUp;  char replyBuf[SCTP_MAX_READBUFFER];  struct sctpParamDesc *replyParam;  struct sctpRelChunkDesc *replyChunk;  char *copyFrom,*copyTo;  u_int *TLVtag,*TLVtagReply;  replyChunk = (struct sctpRelChunkDesc *)replyBuf;  replyChunk->chk.chunkID = SCTP_RELIABLE_CNTL_ACK;  replyChunk->chk.chunkFlg = 0;  replyChunk->serialNumber = htonl(sn);  /* account for the TLV tag */  TLVtag = (u_int *)ppoint;  ppoint = (struct sctpParamDesc *)((u_long)TLVtag + sizeof(u_int));  TLVtagReply = (u_int *)((u_long)replyChunk + sizeof(struct sctpRelChunkDesc));  replyParam = (struct sctpParamDesc *)((u_long)TLVtagReply + sizeof(u_int));  rlen = sizeof(struct sctpRelChunkDesc);  SCTPdebugPrint(m,"Randall Jr Says RLEN is %d at the start\n",rlen);  stop = 0;  len = maxlen;  SCTPdebugPrint(m,"Processing REL-REQ parameters, size:%d maxlen\n",maxlen);  while(len > 7){    /* examine and process the parameter */    if(stop){      /* one of the parameters told us to stop */      break;    }    ptype = ntohs(ppoint->paramType);    plen = ntohs(ppoint->paramLength);    if(plen > len){      /* mal-formed parameter, larger then leftover length */      SCTPdebugPrint(m,"Hmm, last param is mal-formed, it says len=%d I have %d left of in buffer\n",		     plen,len);      break;    }    SCTPdebugPrint(m,"Processing type %x length:%d\n",ptype,plen);    /********************/    /* BEGIN PROCESSING */    switch(ptype){    case SCTP_ADD_IP_ADDRESS:      if(SCTP_processAddAddress(m,asoc,ptype,plen,ppoint,replyParam)){	/* postive response indicates a reply param was added */	/* copy the tag */	*TLVtagReply = *TLVtag;	rplen = ntohs(replyParam->paramLength);	if((rlen + rplen + sizeof(u_int)) > SCTP_MAX_READBUFFER){	  /* protection against overrunning the reply buffer */	  SCTPdebugPrint(m,"The Huns have over-run our postion, retreat!\n");	  break;	}	start = (u_long)replyParam + (u_long)rplen;	roundUp = (((start + 3) >> 2) << 2);	if(roundUp > start){	  /* must null out the pad */	  char *foobar;	  int i;	  /* add in the pad */	  rlen += (roundUp-start);	  SCTPdebugPrint(m,"Padding out start:%x\n",(u_int)start);	  for(i=start;i<roundUp;i++){	    foobar = (char *)i;	    SCTPdebugPrint(m,"Padding address:%x=0\n",(u_int)i);	    *foobar = 0;	  }	}	/* set next TLV tag reply pointer */	TLVtagReply = (u_int *)roundUp; 	/* set next replyParam pointer */	replyParam = (struct sctpParamDesc *)((u_long)TLVtagReply + sizeof(u_int));	SCTPdebugPrint(m,"New TLVtag:%x new replyParam:%x\n",		       (u_int)TLVtagReply,(u_int)replyParam);	SCTPdebugPrint(m,"rlen:%d += (rplen:%d + u_int size:%d)\n",rlen,rplen,sizeof(u_int));	/* add parameter len */	rlen += rplen;	/* add tag length */	rlen += sizeof(u_int);      }      break;    case SCTP_DEL_IP_ADDRESS:      if(SCTP_processDelAddress(m,asoc,ptype,plen,ppoint,replyParam)){	/* postive response indicates a reply param was added */	/* copy the tag */	*TLVtagReply = *TLVtag;	rplen = ntohs(replyParam->paramLength);	if((rlen + rplen + sizeof(u_int)) > SCTP_MAX_READBUFFER){	  /* protection against overrunning the reply buffer */	  SCTPdebugPrint(m,"The Huns have over-run our postion, retreat!\n");	  break;	}	start = (u_long)replyParam + (u_long)rplen;	roundUp = (((start + 3) >> 2) << 2);	if(roundUp > start){	  /* must null out the pad */	  char *foobar;	  int i;	  /* add in the pad */	  rlen += (roundUp-start);	  SCTPdebugPrint(m,"Padding out start:%x\n",(u_int)start);	  for(i=start;i<roundUp;i++){	    foobar = (char *)i;	    SCTPdebugPrint(m,"Padding address:%x=0\n",(u_int)i);	    *foobar = 0;	  }	}	/* set next TLV tag reply pointer */	TLVtagReply = (u_int *)roundUp; 	/* set next replyParam pointer */	replyParam = (struct sctpParamDesc *)((u_long)TLVtagReply + sizeof(u_int));	SCTPdebugPrint(m,"New TLVtag:%x new replyParam:%x\n",		       (u_int)TLVtagReply,(u_int)replyParam);	SCTPdebugPrint(m,"rlen:%d += (rplen:%d + u_int size:%d)\n",rlen,rplen,sizeof(u_int));	/* add parameter len */	rlen += rplen;	/* add tag length */	rlen += sizeof(u_int);      }      break;    case SCTP_SETADDRESS_PRIMARY:      if(SCTP_processSetPrimary(m,asoc,ptype,plen,ppoint,replyParam)){	/* postive response indicates a reply param was added */	/* copy the tag */	*TLVtagReply = *TLVtag;	rplen = ntohs(replyParam->paramLength);	if((rlen + rplen + sizeof(u_int)) > SCTP_MAX_READBUFFER){	  /* protection against overrunning the reply buffer */	  SCTPdebugPrint(m,"The Huns have over-run our postion, retreat!\n");	  break;	}	start = (u_long)replyParam + (u_long)rplen;	roundUp = (((start + 3) >> 2) << 2);	if(roundUp > start){	  /* must null out the pad */	  char *foobar;	  int i;	  /* add in the pad */	  rlen += (roundUp-start);	  SCTPdebugPrint(m,"Padding out start:%x\n",(u_int)start);	  for(i=start;i<roundUp;i++){	    foobar = (char *)i;	    SCTPdebugPrint(m,"Padding address:%x=0\n",(u_int)i);	    *foobar = 0;	  }	}	/* set next TLV tag reply pointer */	TLVtagReply = (u_int *)roundUp; 	/* set next replyParam pointer */	replyParam = (struct sctpParamDesc *)((u_long)TLVtagReply + sizeof(u_int));	SCTPdebugPrint(m,"New TLVtag:%x new replyParam:%x\n",		       (u_int)TLVtagReply,(u_int)replyParam);	SCTPdebugPrint(m,"rlen:%d += (rplen:%d + u_int size:%d)\n",rlen,rplen,sizeof(u_int));	/* add parameter len */	rlen += rplen;	/* add tag length */	rlen += sizeof(u_int);      }      break;      /* Phil Conrad: This looks like a good place for this :) */      /*    case SCTP_STRM_FLOW_LIMIT:        * Remember if you reply (which you probably won't) you need to       * copy in the TLVtag to the reply and of course the       * new opaque number. I put the add stuff in a       * seperate module sctpaddext.c, you may either       * put it there or do your own module.       * You also need to have something added to userInterface.c to allow       * them to change the variable in the peer, pattern it something       * like the sctpADDREQUEST() stuff you see called in there.       * You will need to put the change request sctpSTRMFLOWCHG() in the       * main sctp.c module. Also you will need to track if the peer       * supports the feature. Look at the flags  supportsDynamicAddress and supportsDynamicSetPrim       * for reference, these track the add/delete and the set remote primary.       * You normally optimistically set it to 1 in sctputil.c (where the others are set)       * and thenif you get an error reply (see sctpaddext.c) you turn it off.       * In the sctp.c/sctpSTRMFLOWCHG() you must check this flag before proceeding       * since you don't want to send a request if the peer does not support it.       * I would delay collapsing the stream array's and the single structure       * for stream 0 if I were you. I realize I DID do this for a reason. In a       * default association with only one stream nothing gets alloc'd in the       * stream arrays (since you have none). You need some place to track       * stream 0 always... This may be a bit more sticky and it is less       * essential to do..  Randall...       */    default:      SCTPdebugPrint(m,"Hmm, I don't understand type %x\n",ptype);      if((0x8000 & ptype) == 0){	SCTPdebugPrint(m,"Stop bit is set to halt processing i.e. its 0\n");	stop = 1;      }      /* we always report no matter what the bit settings */      SCTPdebugPrint(m,"Now I must prepare report\n");      /* copy the TLV tag */      *TLVtagReply = *TLVtag;      /* setup the parameter and length */      replyParam->paramType = htons(SCTP_UNRECOG_PARAM);      rplen = sizeof(struct sctpParamDesc) + plen;      replyParam->paramLength = htons(rplen);      SCTPdebugPrint(m,"Reply Length is now %d (plen:%d)\n",rplen,plen);      /* copy the unrecognized parameter into place */      if((rlen + rplen + sizeof(u_int)) > SCTP_MAX_READBUFFER){	/* protection against overrunning the reply buffer */	SCTPdebugPrint(m,"The Huns have over-run our postion, retreat!\n");	break;      }      copyFrom = (char *)ppoint;      copyTo = (char *)((u_long)replyParam + sizeof(struct sctpParamDesc));      SCTPdebugPrint(m,"Ok, now I copy to my local buffer for %d bytes\n",plen);      memcpy(copyTo,copyFrom,plen);      SCTPdebugPrint(m,"Outbound TLV tag is at %x\n",(u_int)TLVtagReply);      SCTPdebugPrintArry(m,(char *)TLVtagReply,sizeof(u_int));      SCTPdebugPrint(m,"Outbound parameter will look as follows for %d bytes\n",rplen);      SCTPdebugPrintArry(m,(char *)replyParam,rplen);      /* now move up the reply parameter to the next slot  */      start = (u_long)copyTo + (u_long)plen;      roundUp = (((start + 3) >> 2) << 2);      if(roundUp > start){	/* must null out the pad */	char *foobar;	int i;	/* add in the pad */	rlen += (roundUp-start);	SCTPdebugPrint(m,"Padding out start:%x\n",(u_int)start);	for(i=start;i<roundUp;i++){	  foobar = (char *)i;	  SCTPdebugPrint(m,"Padding address:%x=0\n",(u_int)i);	  *foobar = 0;	}      }      TLVtagReply = (u_int *)roundUp;       replyParam = (struct sctpParamDesc *)((u_long)TLVtagReply + sizeof(u_int));      SCTPdebugPrint(m,"New TLVtag:%x new replyParam:%x\n",		     (u_int)TLVtagReply,(u_int)replyParam);      SCTPdebugPrint(m,"rlen:%d += (rplen:%d + u_int size:%d)\n",rlen,rplen,sizeof(u_int));      rlen += rplen;      rlen += sizeof(u_int);      SCTPdebugPrint(m,"To break, rlen for reply is now %d bytes\n",rlen);      break;    }    /* END PROCESSING */    /******************/    start = (u_long)ppoint + (u_long)plen;    roundUp =  (((start + 3) >> 2) << 2);    TLVtag = (u_int *)roundUp;    ppoint = (struct sctpParamDesc *)((u_long)TLVtag + sizeof(u_int));    /* account for the TLV */    SCTPdebugPrint(m,"Length was %d will now do round (((%d + 3) >> 2) << 2) = %d\n",		   len,plen,(((plen + 3) >> 2) << 2));    len -= (((plen + 3) >> 2) << 2);    /* account for the TLV tag */    len -= sizeof(u_int);    SCTPdebugPrint(m,"New length is %d\n",len);  }  /* grab some memory for our reply */  asoc->lastSentRelAck = (struct sctpRelChunkDesc *)w_calloc(m,1,rlen);  if(asoc->lastSentRelAck == NULL){    return;  }  /* fix in the length */  replyChunk->chk.chunkLength = htons(rlen);  /* now copy to the buffer */  memcpy((char *)asoc->lastSentRelAck,replyBuf,rlen);  return;}voidSCTPhandleRelReq(struct SCTP *m,		 struct sctpChunkDesc *desc,		 struct SCTP_association *asoc,		 struct sockaddr *from){  /* parse and send back the rel-ack to the sender */  u_int tmp;  struct sctpRelChunkDesc *rreq;  rreq = (struct sctpRelChunkDesc *)desc;  /* convert to host order */  tmp = ntohl(rreq->serialNumber);  rreq->serialNumber = tmp;  /* there is no question this peer is capable :) */  asoc->peerCanDoRelReq = 1;  /* first we check the serial number */  if(rreq->serialNumber == asoc->relReqSeqIn){    /* duplicate to last one, resend my previous     * response.     */    SCTPdebugPrint(m,"Got a duplicate serial number %x\n",rreq->serialNumber);    sendRelReqAck(m,asoc,from);      }else if(rreq->serialNumber == (asoc->relReqSeqIn+1)){    /* Got the next expected serial number,     * we must process all TLV's and fomulate a response     * in a REL-ACK.     */    struct sctpParamDesc *ppoint;    int len;    SCTPdebugPrint(m,"READY TO PROCESS REL-REQ serial number %x\n",rreq->serialNumber);    /* clear away the old REL-ACK if I have one */    if(asoc->lastSentRelAck != NULL){      w_free(m,(char *)asoc->lastSentRelAck);      asoc->lastSentRelAck = NULL;    }    /* update the sequence number */    asoc->relReqSeqIn = rreq->serialNumber;    /* calculate the total lenght of the param area */    len = ntohs(rreq->chk.chunkLength) - sizeof(struct sctpRelChunkDesc);    /* index the first TLV */    ppoint = (struct sctpParamDesc *)((u_long)rreq + sizeof(struct sctpRelChunkDesc));    SCTPprocessRelReqTLVs(m,asoc,ppoint,len,rreq->serialNumber);    sendRelReqAck(m,asoc,from);  }else{    /* our peer is violating the protocol by sending last-serialNumber+2 or more */    SCTPdebugPrint(m,"Peer violates REL-REQ Protocol sends me serial:%x I expect serial:%x\n",		   rreq->serialNumber,(asoc->relReqSeqIn+1));    return;  }}voidSCTPprocessRelReqResponse(struct SCTP *m,			  struct SCTP_association *asoc,			  struct sctpParamDesc *request,			  struct sctpParamDesc *reply){  /* Here you insert processing of the epoint for    * your REL-REQ parameter. Any return value   * that your REL-REQ may generate should be   * handled here.   */  int reqtype,resptype;  reqtype = ntohs(request->paramType);  resptype = ntohs(reply->paramType);  /* notify upper layer */  if(resptype == SCTP_OPERATION_SUCCEED){    (*m->notify)(SCTP_NOTIFY_RELREQ_RESULT_OK,(char *)reply,reqtype);  }else{    (*m->notify)(SCTP_NOTIFY_RELREQ_RESULT_FAILED,(char *)reply,reqtype);  }  switch(reqtype){    case SCTP_ADD_IP_ADDRESS:      SCTP_handleAddResponse(m,asoc,request,reply);      break;    case SCTP_DEL_IP_ADDRESS:      SCTP_handleDelResponse(m,asoc,request,reply);      break;    case SCTP_SETADDRESS_PRIMARY:      SCTP_handleSetPrimaryResponse(m,asoc,request,reply);      break;  default:    SCTPdebugPrint(m,"SOFTWARE ERRROR, forgot to add the error handling for type %d (response is %d)\n",		   reqtype,resptype);    break;  }}voidSCTPprocessRelAckTLVs(struct SCTP *m,		      struct SCTP_association *asoc,		      struct sctpParamDesc *ppoint,		      int maxlen){  /* Hints and helps:   *   * asoc->lastSentRelReq - points to last REL-REQ that we sent. This   * can be used to figure out things that may not have been processed.   */  int len;  int plen;  int notExecutedFrom;  void *v,*k;  struct sctpParamDesc *upoint,plainGood,*replyPoint,plainBad;  u_int *TLVtag,localTLV;  u_long roundUp,start;  struct SCTP_RelReqKey *key;    notExecutedFrom = 0;  len = maxlen;  if(asoc->lastSentRelReq == NULL){    SCTPdebugPrint(m,"Hmm, ERROR how can I get a REL-ACK and not have one in queue??\n");    return;  }  TLVtag = (u_int *)ppoint;  SCTPdebugPrint(m,"Processing setup as follows ppoint:%x\n",(u_int)ppoint);  SCTPdebugPrintArry(m,(char *)TLVtag,4);  ppoint = (struct sctpParamDesc *)((u_long)TLVtag + sizeof(u_int));  SCTPdebugPrintArry(m,(char *)ppoint,4);  /* relReqSent holds our count of sent out TLV's    * for each one of these we need to find the response   * or generate a postive response if no response   * is listed for it.   */  while(len > 7){    /* examine and process the parameter */    plen = ntohs(ppoint->paramLength);    if(plen > len){      /* mal-formed parameter, larger then leftover length */      SCTPdebugPrint(m,"Hmm, last param is mal-formed, it says len=%d I have %d left of in buffer\n",		     plen,len);      break;    }    SCTPdebugPrint(m,"Length is %d\n",plen);    /* look up the TLVtag */    v = HashedTbl_lookup(asoc->pendingChunks,(void *)TLVtag,sizeof(u_int),&k);    if(v == NULL){      /* TSNH unless peer does something wrong */      SCTPdebugPrint(m,"Hmm, parameter response to TLVtag %d, I can't find it!\n",*TLVtag);    }else{      u_short type;      /* found the guy setup the reply in the proper place */      key = (struct SCTP_RelReqKey *)k;      key->reply = ppoint;      type = ntohs(ppoint->paramType);      if(type != SCTP_OPERATION_SUCCEED){	/* Here we have a failure of some sort, if the 	 * first bit is set we are cool... if not	 * all others queued must fail too.	 */	if((type & 0x8000) == 0){	  notExecutedFrom = (*TLVtag) + 1;	}      }    }    start = (u_long)ppoint + (u_long)plen;    roundUp =  (((start + 3) >> 2) << 2);    TLVtag = (u_int *)roundUp;    ppoint = (struct sctpParamDesc *)((u_long)TLVtag + sizeof(u_int));    len -= (((plen + 3) >> 2) << 2);    len -= sizeof(u_int);    SCTPdebugPrint(m,"Processing setup as follows ppoint now:%x (tlvtag:%x)\n",(u_int)ppoint,(u_int)TLVtag);  }  /* Now we have indexed all of the reply TLV's  and must look them up in   * order. We always start with 1 and go on up.   */  localTLV = 1;  /* initialize good TLV structure used for default reply */  plainGood.paramType = htons(SCTP_OPERATION_SUCCEED);  plainGood.paramLength = htons(sizeof(struct  sctpParamDesc));  plainBad.paramType = htons(SCTP_ERROR_NOT_EXECUTED);  plainBad.paramLength = htons(sizeof(struct  sctpParamDesc));  SCTPdebugPrint(m,"relReqSent set to %d\n",asoc->relReqSent);  while((v = HashedTbl_remove(asoc->pendingChunks,(void *)&localTLV,sizeof(u_int),&k)) != NULL){    key = (struct SCTP_RelReqKey *)k;    upoint = (struct sctpParamDesc *)v;    if((notExecutedFrom == 0) || (notExecutedFrom > localTLV)){      /* we executed all, or have not reached point of non-execution */      if(key->reply == NULL){	replyPoint = &plainGood;      }else{	replyPoint = key->reply;      }    }else{      /* it was never executed */      replyPoint = &plainBad;    }    /* call the processing routine */    SCTPdebugPrint(m,"Processing parameter %d\n",localTLV);    SCTPprocessRelReqResponse(m,asoc,upoint,replyPoint);    /* bump to the next one */    localTLV++;    /* free up the data */    w_free(m,(char *)key);    w_free(m,(char *)v);  }}voidSCTPhandleRelAck(struct SCTP *m,		 struct sctpChunkDesc *desc,		 struct SCTP_association *asoc){  /* figure out what happened, and setup for next rel-req send */  struct sctpRelChunkDesc *rack;  struct sctpParamDesc *ppoint;  u_int tmp,ret;  int maxlen;  rack =(struct sctpRelChunkDesc *)desc;  if(rack == NULL)    /* huh? */    return;  /* convert the serial number to host order */  tmp = ntohl(rack->serialNumber);  rack->serialNumber = tmp;  /* check if this is the serial number I am expecting,   * if not then it is a duplicate.   */  if(rack->serialNumber != asoc->relReqSeqOut){    /* old duplicate, ignore it */    SCTPdebugPrint(m,"Saw a REL-ACK with serial number %x my next ack should be %x, ignoring\n",		   rack->serialNumber,asoc->relReqSeqOut);    return;  }  /* first bump up the rel-req sequence number */  asoc->relReqSeqOut++;  /* now stop the timer */  timerWork(m,asoc,SCTP_TIMER_STOP,SctpTimerTypeRelReq,0);	      /* Now process any TLV responses that may have been in here,   * you add your handling codes to the module called here.   */  ppoint = (struct sctpParamDesc *)((u_long)rack + sizeof(struct sctpRelChunkDesc));  maxlen = (int)ntohs(rack->chk.chunkLength) - sizeof(struct sctpRelChunkDesc);  SCTPprocessRelAckTLVs(m,asoc,ppoint,maxlen);  /* now free the chunk we have on queue since it has been ack'd */  if(asoc->lastSentRelReq != NULL){    w_free(m,(char *)asoc->lastSentRelReq);    asoc->lastSentRelReq = NULL;  }  /* clear our sent flag/count */  asoc->relReqSent = 0;  /* now if we have more in queue lets go ahead and start the ball rolling for   * the next send.   */  if(dlist_getCnt(asoc->queueOfRelReq)){    ret = SCTPsendRelReqOut(m,asoc,0);    if(ret > -2){      timerWork(m,asoc,		SCTP_TIMER_START,SctpTimerTypeRelReq,		asoc->lastNetSentTo);    }  }}voidSCTPrelrequestFailAll(struct SCTP *m,struct SCTP_association *asoc){  /* This function is called when a REL-REQ fails with a   * non-supported error i.e. unrecognized chunk. All of the TLV's pending    * need to be called with a unrecongnized parameter, and of course the   * relrequest flag that tells us our peer can handle rel-req is turned   * off so all future queues of TLV's will fail   */  char buffer[SCTP_MAX_READBUFFER],*copypoint;  struct sctpParamDesc *plainBad,*request;  struct SCTP_RelReqKey *key;  int sz;  void *v,*k;  plainBad = (struct sctpParamDesc *)buffer;  copypoint = (char *)((u_long)buffer + sizeof(struct sctpParamDesc));  plainBad->paramType = htons(SCTP_UNRECOG_PARAM);  SCTPdebugPrint(m,"Ok, time to pull out the pending and fail them\n");  HashedTbl_rewind(asoc->pendingChunks);  while((v = HashedTbl_getNext(asoc->pendingChunks,&k)) != NULL){    key = (struct SCTP_RelReqKey *)k;    request = (struct sctpParamDesc *)v;    /* manufacture the failure */    sz = ntohs(request->paramLength);    plainBad->paramLength = htons(sizeof(struct sctpParamDesc) + sz);    memcpy(copypoint,request,sz);    SCTPprocessRelReqResponse(m,asoc,request,plainBad);    w_free(m,(char *)key);    w_free(m,(char *)v);  }  /* now any in queue that have not been sent must also have a failure call */  SCTPdebugPrint(m,"Ok, time to pull out the queued and fail them\n");  dlist_reset(asoc->queueOfRelReq);  while((v = dlist_getNext(asoc->queueOfRelReq)) != NULL){    request = (struct sctpParamDesc *)v;    sz = ntohs(request->paramLength);    plainBad->paramLength = htons(sizeof(struct sctpParamDesc) + sz);    memcpy(copypoint,request,sz);    SCTPprocessRelReqResponse(m,asoc,request,plainBad);    w_free(m,(char *)v);  }  SCTPdebugPrint(m,"Ok, all done\n");}