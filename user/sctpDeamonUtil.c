/* SCTP reference Implementation Copyright (C) 2001 Cisco And MotorolaThis file is part of the SCTP reference ImplementationVersion:4.0.5$Header: /home/sourceTree/src/sctp/user/sctpDeamonUtil.c,v 1.33 2001/07/24 11:52:39 randall Exp $The SCTP reference implementation  is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published bythe Free Software Foundation; either version 2, or (at your option)any later version.the SCTP reference implementation  is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of                ************************MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See theGNU Library General Public License for more details.You should have received a copy of the GNU Library General Public Licensealong with GNU CC; see the file COPYING.  If not, write tothe Free Software Foundation, 59 Temple Place - Suite 330,Boston, MA 02111-1307, USA.  Please send any bug reports or fixes you make to one of the following emailaddresses:rrs@cisco.comkmorneau@cisco.comqxie1@email.mot.comAny bugs reported given to us we will try to fix... any fixes shared willbe incorperated into the next SCTP release.There are still LOTS of bugs in this code... I always run on the motto"it is a wonder any code ever works :)"*/#include <sctp.h>#include <sctputil.h>/* now get all the function declarations in */#include <stdio.h>#include <stdlib.h>#include <unistd.h>#include <sys/types.h>#include <pwd.h>#include <netinet/in_systm.h>#include <netinet/in.h>#include <netinet/ip.h>#include <arpa/inet.h>#include <sys/ioctl.h>#include <sys/stat.h>#include <stdarg.h>#include <signal.h>#include <fcntl.h>#include <sys/socket.h>#if ! ( defined(LINUX) || defined(TRU64) || defined(AIX))#include <sys/sockio.h>#endif#include <time.h>#include <string.h>#if (defined (LINUX) || defined (TRU64))#include <stropts.h>#endif#include <net/if.h>#include <errno.h>#include <netinet/ip_icmp.h>#include <sctpDeamonUtil.h>#include <poll.h>#include <sys/time.h>#include <sctpConstants.h>#include <sctpStructs.h>#include <sctpHeader.h>#include <adler32.h>#include <sys/uio.h>/* comment this out and you get rid of debug */#ifndef DEBUG_ON#define DEBUG_ON 1#endifextern char portSpace[65535];extern int icmpFd;	/* port open for ICMP messages */extern int ipFd; 	/* port open for RAW IP - the writer port */extern int ipRdFd;	/* port bound to SCTP protocol, the reader port */extern int udpFd;	/* client access port, where UDP datagrams, come-go to */extern int ipFd6;extern int ipRdFd6;static unsigned short lastPortSentTo = 0;extern int numberOfNets;extern int numberOfNetsAloced;extern struct sockaddr **localNets;extern struct sockaddr_in *maskList;extern struct sockaddr_in *broadList;extern int max_mtu;extern int NOipV6;/* array of my networks and masks for each */static int IcmpBaseId = 0;static uid_t saved_suid; /* saved set-user-id */static int checkPrivileges_done = 0;#ifdef DEBUG_ONstatic FILE *ioout=NULL;#endif/* The program shoudl be either suid root or run by root. * If not, return <0. * * NOTE This function must be called before {lower,raise}Privileges. * * TODO add a check that, if suid, the permissions are 4550, ie the "others" * cannot execute us. */intcheckPrivileges(void){    uid_t ruid, euid;    ruid = getuid();    euid = saved_suid = geteuid();    if (euid != 0) {        printf("Error: This program should be suid root or run by root\n");        return -1;    }    checkPrivileges_done = 1;    return 0;}/* Set the effective UID to the real UID. * XXX This does nothing if we are running as root. *     I suggest two possible solutions: *     1. force the program to be suid root and not run by root *     2. if run by root, switch to user nobody. * * Precondition: checkPrivileges() successful. */intlowerPrivileges(void){    if (!checkPrivileges_done) {        return -1;    }    if (seteuid(getuid()) < 0) {        perror("seteuid");        return -1;    }    return 0;}/* Set the effective UID to the saved-set-uid, which should be root. * * Precondition: checkPrivileges() succesful. */intraisePrivileges(void){    if (!checkPrivileges_done) {        return -1;    }    if (seteuid(saved_suid) < 0) {        perror("seteuid");        return -1;    }    return 0;}/* Open a log file. * Return 0 on success, <0 on failure. */intDEAMONinitDebug(){#ifndef DEBUG_ON    return 0;#else  char name[100];  sprintf(name, "/tmp/sctpDeamon.%d", (int)getpid());  if ( (ioout = SCTPsafefopen(name)) == NULL) {      return -1;  }  return 0;#endif /* defined DEBUG_ON */}voidDEAMONcloseDebug(){#ifdef DEBUG_ON  if(ioout != NULL){    fclose(ioout);    ioout = NULL;  }#endif}int DEAMONvwrite(char *format, va_list ap){#ifdef DEBUG_ON  /* if debug is on, this will write out   * the strings reformatting on the way.. to the   * proper file.   */  struct tm *tm;  struct timespec t;#if (defined (LINUX) || defined(TRU64) || defined(AIX) )   struct timeval tv;#endif#if !(defined (LINUX) || defined(TRU64) || defined(AIX) )  clock_gettime(CLOCK_REALTIME,&t);#else  gettimeofday(&tv,NULL);  TIMEVAL_TO_TIMESPEC(&tv,&t);#endif  tm = localtime( (time_t *)&(t.tv_sec) );  if(fprintf(ioout,"refimpl:SCTP:[%d] ",(int)getpid()) < 1)    return(-1);  if(fprintf(ioout,"%d/%d %d:%d:%d.%d - ",	     (tm->tm_mon+1),	     tm->tm_mday,	     tm->tm_hour,	     tm->tm_min,	     tm->tm_sec,	     (int)(t.tv_nsec/1000000)) < 1)    return(-1);  if(vfprintf(ioout,format, ap) < 1)    return(-1);  fflush(ioout);#endif  return(0);}voidDEAMONdebugPrint(char *f,...){#ifdef DEBUG_ON  /* if debug is on print a string */  va_list va;  if(ioout == NULL)    return;  va_start(va,f);  DEAMONvwrite(f,va);  va_end(va);  return;#endif}voidDEAMONprintArry(unsigned char *data,int sz){#ifdef DEBUG_ON  /* if debug is on hex dump a array */  int i,j,linesOut;  char buff1[64];  char buff2[64];  char *ptr1,*ptr2,*dptrlast,*dptr;  char *hexes = "0123456789ABCDEF";  if(ioout == NULL)    return;  ptr1 = buff1;  ptr2 = buff2;  dptrlast = dptr = (char *)data;  for(i=0,linesOut=0;i<sz;i++){    *ptr1++ = hexes[0x0f&((*dptr)>>4)];    *ptr1++ = hexes[0x0f&(*dptr)];    *ptr1++ = ' ';    if((*dptr >= 040) && (*dptr <= 0176))      *ptr2++ = *dptr;    else      *ptr2++ = '.';    dptr++;    if(((i+1) % 16) == 0){      *ptr1 = 0;      *ptr2 = 0;      fprintf(ioout,"%s %s\n",buff1,buff2);      linesOut++;      ptr1 = buff1;      ptr2 = buff2;      dptrlast = dptr;    }  }  if((linesOut*16) < sz){    char spaces[64];    int dist,sp;    j=(linesOut*16);    dist = ((16 - (i - j)) * 3) + 2;    *ptr1 = 0;    *ptr2 = 0;    for(sp=0;sp<dist;sp++){      spaces[sp] = ' ';    }    spaces[sp] = 0;    fprintf(ioout,"%s %s%s\n",buff1,spaces,buff2);  }  fflush(stdout);#endif}voidDEAMONdebugPrintArry(unsigned char *arry,int sz){#ifdef DEBUG_ON  /* if debug is on hex dump a array */  if(ioout == NULL)    return; DEAMONprintArry(arry,sz);#endif}char readBuff[SCTP_MAX_READBUFFER];intfillBuffer(int fd,unsigned char *from,int len){  int ret;#ifdef AIX  size_t lenfrm;#else  int lenfrm;#endif  lenfrm = len;  ret = recvfrom(fd,readBuff,SCTP_MAX_READBUFFER,		 0,(struct sockaddr *)from,&lenfrm);  DEAMONdebugPrint("filled buffer with %d bytes from address type %d\n",		   ret,		   ((struct sockaddr *)from)->sa_family		   );  DEAMONdebugPrintArry(readBuff,ret);  return(ret);}intisAddressValid(struct sockaddr *add){  int i;  for(i=0;i<numberOfNets;i++){    if(add->sa_family != localNets[i]->sa_family){      continue;    }    if(add->sa_family == AF_INET){      if(((struct sockaddr_in *)add)->sin_addr.s_addr == 	 ((struct sockaddr_in *)localNets[i])->sin_addr.s_addr){	/* valid local address */	return(1);      }    }else if(add->sa_family == AF_INET6){      if(memcmp(&((struct sockaddr_in6 *)add)->sin6_addr,		&((struct sockaddr_in6 *)localNets[i])->sin6_addr,		sizeof(struct in6_addr)) == 0){	return(1);      }    }  }  /* can't recognize has a local address */  return(0);}voidhandleRegistration(struct deamonRegister *reg,struct sockaddr *from){  int ret,sz,portidx;  sz = portidx = ret = 0;  if(from->sa_family == AF_INET){    sz = sizeof(struct sockaddr_in);    portidx = ((struct sockaddr_in *)from)->sin_port;  }else if(from->sa_family == AF_INET6){    sz = sizeof(struct sockaddr_in6);    portidx = ((struct sockaddr_in6 *)from)->sin6_port;  }  switch(reg->msgType){  default:  case DEAMON_REGISTER_ACK:  case DEAMON_DEREGISTER_ACK:    DEAMONdebugPrint("Huh, the deamon got a reg-ack? or %d ?\n",reg->msgType);    break;  case  DEAMON_REGISTER:    /* add and send back a ack */    printf("Got a register from ");    SCTPPrintAnAddress(from);    portSpace[ntohs(portidx)] = 1;    reg->msgType = DEAMON_REGISTER_ACK;    ret = sendto(udpFd,(char *)reg,sizeof(struct deamonRegister),0,from,sz);    break;  case DEAMON_CHECKADDR_LIST:    {      int i;      SCTP_gatherAddresses(&localNets,			   &maskList,			   &broadList,			   &numberOfNets,			   &numberOfNetsAloced,			   &max_mtu,			   (int **)NULL,			   udpFd,			   1);      printf("Deamon finds New networks now %d\n",numberOfNets);      for(i=0;i<numberOfNets;i++){	SCTPPrintAnAddress(localNets[i]);      }    }    break;  case DEAMON_DEREGISTER:    /* remove and send back a ack */    printf("Got a de-register from ");    SCTPPrintAnAddress(from);    portSpace[ntohs(portidx)] = 0;    reg->msgType = DEAMON_DEREGISTER_ACK;    ret = sendto(udpFd,(char *)reg,sizeof(struct deamonRegister),0,		 (struct sockaddr *)from,sizeof(*from));    break;  };}unsigned shortin_check(unsigned char *buf, int sz){  u_short *psh;  u_long sum;  int i;    sum = 0;  psh = (u_short *)buf;  if(sz & 0x1){    /* odd byte boundary pad up 1 byte */    /* this cheats, but it should be ok :-> */    buf[sz] = 0;    sz++;  }  sz /= 2;  for(i=0;i<sz;i++){    sum += *psh++;  }  sum = (sum >> 16) + (sum & 0xffff);  sum += (sum >> 16);  return((unsigned short) (~sum & 0x0000ffff));}voidsendOffIcmpToSource(char *readBuff,int sz,struct sockaddr_in *to){  /* This routine is used to generate the proper ICMP   * message to send back to the sender of the readBuff message.   * This is because the sender can't get the EMSGSIZE error   * and so we pretend to be a network and send back   * a ICMP FRAGMENTATION NEEDED, Sun's do this instead of   * giving the error message.   */  struct ip *badip,*iph;  struct icmp *icmph;  char outbuf[1024];  int lenof,ret;  memset(outbuf,0,sizeof(outbuf));  iph = (struct ip *)outbuf;  badip = (struct ip *)readBuff;  /* Fill in the IP portion of the header */  iph->ip_hl = (sizeof(struct ip)/4);  iph->ip_v = IPVERSION;  iph->ip_tos = (u_char)0;  iph->ip_len = htons(sizeof(struct ip) + sizeof(struct icmp) + 8);  iph->ip_id = htons(IcmpBaseId);  IcmpBaseId++;  iph->ip_off = 0;  iph->ip_ttl = 0xff;  iph->ip_p = IPPROTO_ICMP;  iph->ip_src.s_addr = to->sin_addr.s_addr;    iph->ip_dst.s_addr = to->sin_addr.s_addr;  iph->ip_sum = 0;  iph->ip_sum = in_check((char *)iph,sizeof(struct ip));  icmph = (struct icmp *)((u_long)iph + (sizeof(struct ip)));  icmph->icmp_type = ICMP_UNREACH;  icmph->icmp_code = ICMP_UNREACH_NEEDFRAG;  icmph->icmp_cksum = 0; /* fix down below */  icmph->icmp_void = 0; /* we don't know the correct size so we just 			 * do the hunt algo at the sender			 */  /* ok we now must copy in the ip header plus 64 bits (8 bytes) */  lenof = (badip->ip_hl * 4) + 8;  memcpy(&icmph->icmp_ip,badip,lenof);  /* correct the header */  lenof += sizeof(struct icmp);  icmph->icmp_cksum = in_check((char *)icmph,lenof);  /* ready to send now .. */  lenof += sizeof(struct ip);  ret = sendto(udpFd,outbuf,lenof,0,(struct sockaddr *)to,sizeof(*to));  DEAMONdebugPrint("Made up ICMP sent %d bytes to %x:%d ret:%d errno:%d\n",	 lenof,to->sin_addr.s_addr,to->sin_port,ret,errno);}intsendAAbort6(struct ip6_hdr *iph6, u_short port, u_long tag,u_short sport){  /* send a abort to the to address */  char abortbuf[1024];  struct ip6_hdr *iph6o;  struct sctpUnifiedAbortHeavy  *mh;  struct sockaddr_in6 to6;  int retVal,len;  unsigned int val;  memset(&to6,0,sizeof(to6));  iph6o = (struct ip6_hdr *)abortbuf;  mh = (struct sctpUnifiedAbortHeavy  *)((caddr_t)iph6o + sizeof(struct ip6_hdr));  len = sizeof(struct sctpUnifiedAbortLight);  /* fill in IP header */  iph6o->ip6_flow = iph6->ip6_flow;  iph6o->ip6_plen = htons(len);  /* use icmp ipid for this */  iph6o->ip6_hlim = 0xff;  iph6o->ip6_nxt = IPPROTO_SCTP;  iph6o->ip6_src = iph6->ip6_dst;  iph6o->ip6_dst = iph6->ip6_src;  /* fill in the mh stuff with all the abort info */  mh->mh.source = sport;  mh->mh.destination = port;  mh->mh.adler32 = 0;  mh->mh.verificationTag = tag;  mh->uh.chunkID = SCTP_ABORT_ASSOCIATION;  mh->uh.chunkFlg = SCTP_HAD_NO_TCB;  mh->uh.chunkLength = htons(4);  /* Now for the adler 32 */  val = count_crc((char *)mh,len);  mh->mh.adler32 = htonl(val);  /* fill in where this is going */  memset(&to6,0,sizeof(to6));  to6.sin6_family = AF_INET6;  to6.sin6_port = 0;  to6.sin6_addr = iph6->ip6_src;#ifdef USES_BSD_4_4_SOCKET  to6.sin6_len = sizeof(struct sockaddr_in6);#endif  DEAMONdebugPrint("Sending to fd:%d abortbuf:%x size(%d),0,%x,%d\n",		   ipFd6,(u_int)abortbuf,(len+sizeof(struct ip6_hdr)),		   (u_int)&to6,sizeof(to6));  DEAMONdebugPrintArry(abortbuf,(len+sizeof(struct ip6_hdr)));  retVal = sendto(ipFd6,abortbuf,(len+sizeof(struct ip6_hdr)),0,		  (struct sockaddr *)&to6,sizeof(to6));  DEAMONdebugPrint("Retval is %d errno:%d\n",retVal,errno);  return(retVal);}intsendAAbort(u_long ipaddr, u_short port, u_long tag,u_long srcaddr, u_short sport){  /* send a abort to the to address */  char abortbuf[1024];  struct ip *iph;  struct sctpUnifiedAbortHeavy  *mh;  struct sockaddr_in to;  int retVal,len;  unsigned int val;  iph = (struct ip *)abortbuf;  mh = (struct sctpUnifiedAbortHeavy  *)((u_long)iph + sizeof(struct ip));  len = sizeof(struct sctpUnifiedAbortLight);  /* fill in IP header */  iph->ip_hl = (sizeof(struct ip)/4);  iph->ip_v = IPVERSION;  iph->ip_tos = (u_char)0;#if (defined (TRU64) || defined (FREEBSD))  iph->ip_len = sizeof(struct ip) + len;#else  iph->ip_len = htons(sizeof(struct ip) + len);#endif  /* use icmp ipid for this */  iph->ip_id = htons(IcmpBaseId);  IcmpBaseId++;  iph->ip_off = 0;  iph->ip_ttl = 0xff;  iph->ip_p = IPPROTO_SCTP;  iph->ip_src.s_addr = srcaddr;  iph->ip_dst.s_addr = ipaddr;  iph->ip_sum = 0;  iph->ip_sum = in_check((char *)iph,sizeof(struct ip));  /* fill in the mh stuff with all the abort info */  mh->mh.source = sport;  mh->mh.destination = port;  mh->mh.adler32 = 0;  mh->mh.verificationTag = tag;  mh->uh.chunkID = SCTP_ABORT_ASSOCIATION;  mh->uh.chunkFlg = SCTP_HAD_NO_TCB;  mh->uh.chunkLength = htons(4);  /* Now for the adler 32 */  val = count_crc((char *)mh,len);  mh->mh.adler32 = htonl(val);  /* fill in where this is going */  memset(&to,0,sizeof(to));  to.sin_family = AF_INET;#ifdef USES_BSD_4_4_SOCKET  to.sin_len = sizeof(struct sockaddr_in);#endif  to.sin_port = port;  to.sin_addr.s_addr = ipaddr;  retVal = sendto(ipFd,abortbuf,(len+sizeof(struct ip)),0,		  (struct sockaddr *)&to,sizeof(to));  if (retVal < 0)      perror("sendto");  return(retVal);}voidDeamonHandleIPV4(struct ip *iph,struct sockaddr_in *from,int sz){  int off,ret;  struct sctpHeader *sch;  struct sockaddr_in to;  if (iph->ip_p != IPPROTO_SCTP){    /* won't deal with anything but SCTP */    return;  }  if (sz < ((sizeof(struct ip) + sizeof(struct sctpHeader)))) {    /* to small forget it */    return;  }  off = iph->ip_hl << 2;  if((off+sizeof(struct sctpHeader)) > sz){    /* mal-formed */    return;  }  sch = (struct sctpHeader *)((u_long)iph + off);  if(sch->source != from->sin_port){    /* fails sanity, UDP port and src port equal */    return;  }  /* verify source address */  if(isAddressValid((struct sockaddr *)from) == 0){    /* your not on my machine */    DEAMONdebugPrint("IPv6:Invalid address discard\n");    return;  }  if(portSpace[ntohs(sch->source)] == 0){    /* un-registered  */    return;  }  errno = 0;  memset(&to,0,sizeof(to));  to.sin_family = AF_INET;  to.sin_port = sch->destination;  to.sin_addr = iph->ip_dst;#ifdef LYNX    /* Lynx O/S in its defintion of raw IP is brain dead!!     * It will NOT allow us to give it a IP header, so     * we are STUCK letting it fill in the IP header.. there     * goes PATH MTU discovery down the drain!! So all we     * can do is send to the readFD i.e. the sctp file desc     * and strip off our very nice IP header that the app     * built... Rats !! We probably should go turn off pmtu raise     * discovery in lynx since we are dead if we don't. For simplicity     * just make the max raise value be the size of a e-net.     */    {      char *noipout;      noipout = (char *)((u_long)readBuff +  sizeof(struct ip));      DEAMONdebugPrint("LYNX is defined: sendto ipRdFd\n");      ret = sendto(ipRdFd,noipout,(sz-sizeof(struct ip)),0,		   (struct sockaddr *)&to,sizeof(to));    }#endif#ifdef LINUX    /* if it is bigger than the max segment (1500)      * AND it is a INIT, INIT-ACK or COOKIE we     * take and let IP frag kick in by writing out the     * SCTP protocol port. This is a HACK since      * LINUX will not fragment on the raw write     * side. Not sure what will happen if we     * write a big PMTU msg out on the raw fd.. but     * oh well.. I want PMTU to work ...     */    {      int retNow;      u_char typeOf;      struct sctpSendableInit *m;      DEAMONdebugPrint("LINUX is defined: checking if segment > max segment \n");      retNow = 0;      m = (struct sctpSendableInit *)((u_long)readBuff +  sizeof(struct ip));      typeOf = m->msg.uh.chunkID;      if((sz > SCTP_DEFAULT_MAXSEGMENT) && ((typeOf == SCTP_INITIATION) || 	  (typeOf == SCTP_COOKIE) || (typeOf == SCTP_INITIATION_ACK))){	char *noipout;	noipout = (char *)((u_long)readBuff +  sizeof(struct ip));	DEAMONdebugPrint("LINUX is defined: sendto ipRdFd\n");	ret = sendto(ipRdFd,noipout,(sz-sizeof(struct ip)),0,		     (struct sockaddr *)&to,sizeof(to));	retNow = 1;      }      if(retNow){	if(ret < sz){	  /* on some systems you don't get a ICMP but instead	   * you get a errno == EMSGSIZE	   */	  if(errno == EMSGSIZE){	    /* we must send back	     * a icmp message to sender of message	     */	    sendOffIcmpToSource(readBuff,sz,from);	  }	}	return;      }    }#endif#if (defined (FREEBSD) || defined (TRU64) || defined(AIX))#ifndef WITH_IP_HDRINCL    sz = sz-sizeof(struct ip);#endif#endif    ret = sendto(ipFd,readBuff,sz,0,(struct sockaddr *)&to,sizeof(to));    DEAMONdebugPrint("Sent %d bytes to ipFd:%d and ret:%d err:%d to:%x port %d ->>\n",		     sz, ipFd, ret, errno, (u_int)ntohl(to.sin_addr.s_addr), ntohs(to.sin_port));    DEAMONdebugPrintArry((unsigned char*)readBuff,sz);    if(ret < sz){      /* on some systems you don't get a ICMP but instead       * you get a errno == EMSGSIZE       */      if(errno == EMSGSIZE){	/* we must send back	 * a icmp message to sender of message	 */	sendOffIcmpToSource(readBuff,sz,from);      }    }}voidDeamonHandleIPV6(struct ip6_hdr *ip6h,struct sockaddr_in6 *from6, int sz){  int off,ret;  struct sctpHeader *sch;  struct sockaddr_in6 to;  if (ip6h->ip6_nxt != IPPROTO_SCTP){    /* won't deal with anything but SCTP */    return;  }  if (sz < ((sizeof(struct ip6_hdr) + sizeof(struct sctpHeader)))) {    /* to small forget it */    return;  }  DEAMONdebugPrint("Have %d bytes to send?\n",sz);  off = sizeof(struct ip6_hdr);  if((off+sizeof(struct sctpHeader)) > sz){    /* mal-formed */    return;  }  sch = (struct sctpHeader *)((caddr_t)ip6h + off);  if(sch->source != from6->sin6_port){    /* fails sanity, UDP port and src port equal */    return;  }  /* verify source address */  if(isAddressValid((struct sockaddr *)from6) == 0){    /* your not on my machine */    DEAMONdebugPrint("IPv6:Invalid address discard\n");    return;  }  if(portSpace[ntohs(sch->source)] == 0){    /* un-registered  */    return;  }  errno = 0;  memset(&to,0,sizeof(to));  to.sin6_family = AF_INET6;  to.sin6_port = 0;  to.sin6_addr = ip6h->ip6_dst;  DEAMONdebugPrint("Have %d bytes to send?\n",sz);  DEAMONdebugPrintArry((char *)ip6h,(sz));  ret = sendto(ipFd6,(char *)ip6h,(sz),0,(struct sockaddr *)&to,sizeof(to));}voidDeamonHandleClient(int fd,int events){  int sz,ret;  unsigned char from[SCTP_ADDRMAX];  struct deamonRegister *reg;  struct ip *iph;  struct ip6_hdr *ip6h;  ret = 0;  if (((events & POLLIN) != POLLIN) && ((events & POLLPRI) != POLLPRI)){    int err;#ifdef  AIX    size_t sz;#else    int sz;#endif    /* attempt to get and clear socket error level */    DEAMONdebugPrint("Attempting to get SO_ERROR to clear (client)\n");    err = 0;    sz = sizeof(err);    ret = getsockopt(fd,SOL_SOCKET,SO_ERROR,&err,&sz);    DEAMONdebugPrint("Ret=%d err=%d\n",ret,err);    if(ret == 0){      DEAMONdebugPrint("Success!\n");      if((err == ECONNREFUSED) || (err == ECONNRESET) || (err == ECONNABORTED)){	/* code name, the guy (i last sent to) might have died without telling the deamon */	portSpace[lastPortSentTo]++;	if(portSpace[lastPortSentTo] > 3){	  /* three strikes and you are out */	  DEAMONdebugPrint("De-registering port:%d\n",lastPortSentTo);	  portSpace[lastPortSentTo] = 0;	}      }      return;    }    DEAMONdebugPrint("WARNING*** don't know how to handle event %d\n",		     events);    printf("Aborting with a unknown event in handleClient %d\n",events);    exit(-1);  }  sz = fillBuffer(fd,from,sizeof(from));  if(sz < 4){    /* Incoming message is to small */    return;  }  /* Now, this is either a message from a   * registered user that is a IP datagram to go   * out, OR, it is a registration/deregistration   * message, OR, a non registered user.   */  reg = (struct deamonRegister *) readBuff;  if((unsigned char)reg->ver_len == (unsigned char)DEAMON_MAGIC_VER_LEN){    DEAMONdebugPrint("DeamonHandleClient: receiving a registration request \n");    handleRegistration(reg,(struct sockaddr *)from);    return;  }else{    DEAMONdebugPrint("It is not a registration request \n");  }  /* if we reach here it is a IP datagram heading out ? */  iph = (struct ip *)readBuff;  ip6h = (struct ip6_hdr *)readBuff;  if(iph->ip_v == IPVERSION){    DEAMONdebugPrint("Off to V4 land\n");    DeamonHandleIPV4(iph,(struct sockaddr_in *)from,sz);  }else if((ip6h->ip6_vfc & IPV6_VERSION_MASK) == IPV6_VERSION){    if(!NOipV6){      DEAMONdebugPrint("Off to V6 land\n");	      DeamonHandleIPV6(ip6h,(struct sockaddr_in6 *)from,sz);    }  }}voidDeamonHandleipFd6(int fd, int events){  unsigned char from[SCTP_ADDRMAX];    int x;  if((events != POLLIN) && (events != POLLPRI)){    int err,ret;#ifdef	AIX    size_t sz;#else    int sz;#endif    /* attempt to get and clear socket error level */    DEAMONdebugPrint("Attempting to get SO_ERROR to clear (ipFD)\n");    err = 0;    sz = sizeof(err);    ret = getsockopt(fd,SOL_SOCKET,SO_ERROR,&err,&sz);    DEAMONdebugPrint("Ret=%d err=%d\n",ret,err);    if(ret == 0){      DEAMONdebugPrint("Success!\n");      return;    }    DEAMONdebugPrint("Don't know how to handle event %d\n",events);    printf("Aborting with a unknown event in handleipFD %d\n",events);    exit(-1);  }  DEAMONdebugPrint("Huh, I got a fd event on IP write socket?\n");  x = fillBuffer(fd,from,sizeof(from));  DEAMONdebugPrint("Trashing inbound data %d bytes\n",x);  DEAMONdebugPrintArry(readBuff,x);}voidDeamonHandleipFd(int fd,int events){  unsigned char from[SCTP_ADDRMAX];    int x;  if((events != POLLIN) && (events != POLLPRI)){    int err,ret;#ifdef	AIX    size_t sz;#else    int sz;#endif    /* attempt to get and clear socket error level */    DEAMONdebugPrint("Attempting to get SO_ERROR to clear (ipFD)\n");    err = 0;    sz = sizeof(err);    ret = getsockopt(fd,SOL_SOCKET,SO_ERROR,&err,&sz);    DEAMONdebugPrint("Ret=%d err=%d\n",ret,err);    if(ret == 0){      DEAMONdebugPrint("Success!\n");      return;    }    DEAMONdebugPrint("Don't know how to handle event %d\n",events);    printf("Aborting with a unknown event in handleipFD %d\n",events);    exit(-1);  }  DEAMONdebugPrint("Huh, I got a fd event on IP write socket?\n");  x = fillBuffer(fd,from,sizeof(from));  DEAMONdebugPrint("Trashing inbound data %d bytes\n",x);  DEAMONdebugPrintArry(readBuff,x);}voidDeamonHandleicmpFd(int fd,int events){  int totsz,sz;  unsigned long off;  struct ip *badip,*iph;  struct icmp *icmph;  struct sctpHeader *sch;  struct sockaddr_in to;  if((events != POLLIN) && (events != POLLPRI)){    int err,ret;#ifdef AIX    size_t sz;#else    int sz;#endif    /* attempt to get and clear socket error level */    DEAMONdebugPrint("Attempting to get SO_ERROR to clear (ipcmpFD)\n");    err = 0;    sz = sizeof(err);    ret = getsockopt(fd,SOL_SOCKET,SO_ERROR,&err,&sz);    DEAMONdebugPrint("Ret=%d err=%d\n",ret,err);    if(ret == 0){      DEAMONdebugPrint("Success!\n");      return;    }    DEAMONdebugPrint("Don't know how to handle event %d\n",events);    printf("Aborting with a unknown event in handleicmpFD %d\n",events);    exit(-1);  }  sz = recv(fd,readBuff,SCTP_MAX_READBUFFER,0);  if(sz < 0){    DEAMONdebugPrint("Huh read only %d errno:%d\n",sz,errno);    return;  }  iph = (struct ip *)readBuff;  /* here a ICMP message awaits us */  off = iph->ip_hl << 2;  icmph = (struct icmp *)((u_long)iph + off);  if(icmph->icmp_type != ICMP_UNREACH){    /* not unreachable */    return;  }  if(icmph->icmp_code != ICMP_UNREACH_NEEDFRAG){    /* not a unreachable message due to frag. */    return;  }  /* ok we like the type, look more closely */  badip = &icmph->icmp_ip;  off = badip->ip_hl << 2;  totsz = (((unsigned short)badip->ip_len) - off);  /* is it our protocol ? */  if(badip->ip_p != IPPROTO_SCTP){    /* not a protocol I handle */    return;  }  off = badip->ip_hl << 2;  sch = (struct sctpHeader *)((u_long)badip + off);  /* now is anyone on this port? */  if(portSpace[ntohs(sch->source)] == 0){    return;  }  /* if we reach here we need to forward this bad boy    * to the UDP port sch->source, and the TO ip address   */  to.sin_family = AF_INET;  to.sin_port = sch->source;  to.sin_addr.s_addr = badip->ip_src.s_addr;  sendto(udpFd,readBuff,sz,0,(struct sockaddr *)&to,sizeof(to));}int isThereAAbortHere(struct sctpHeader *sch,int bound){  /* check the inbound datagram to make sure there   * is not an abort inside it, if there is return 1   * else return 0.   */  void *addr;  struct sctpChunkDesc *desc,*tmpdesc;  u_short distance;  /* setup a bounding address */  addr = (void *)((u_long)sch + bound);  desc = (struct sctpChunkDesc *)((u_long)sch + sizeof(struct sctpHeader));  DEAMONdebugPrint("Checking from %x to bound:%x for abort\n",		   (u_long)desc,(u_long)addr);  while((void *)((u_long)desc + sizeof(struct sctpChunkDesc)) <= addr){    if(desc->chunkID == SCTP_ABORT_ASSOCIATION){      DEAMONdebugPrint("Found a abort\n");      return(1);    }    distance = ntohs(desc->chunkLength);    /* move to the next chunk descriptor */    tmpdesc = (struct sctpChunkDesc *)((((u_long)desc + distance + 3) >> 2) << 2);    if(tmpdesc == desc){      DEAMONdebugPrint("Input packet error old addr:%x new addr same:%x\n",		       (u_long)desc,(u_long)tmpdesc);      break;    }    desc = tmpdesc;    DEAMONdebugPrint("New calculation is %x\n",(u_long)desc);  }  DEAMONdebugPrint("No abort found\n");  return(0);}voidDeamonHandleRdIp6Fd(int fd,int events){  unsigned short x;  int sz,off;  struct ip6_hdr *iph6;  unsigned short sh;  int ret;  struct msghdr hdr;  struct sctpHeader *sch;  struct sockaddr_in to;  struct sockaddr_in6 from6;  char controlbuf[30000];  struct cmsghdr *cmsg;  struct iovec io[2];  io[0].iov_base = readBuff;  io[0].iov_len = sizeof(readBuff);  io[1].iov_base = 0;  io[1].iov_len = 0;  hdr.msg_name = &from6;  hdr.msg_namelen = sizeof(from6);  hdr.msg_iov = io;  hdr.msg_iovlen = 1;  hdr.msg_control = controlbuf;  hdr.msg_controllen = sizeof(controlbuf);  hdr.msg_flags = 0;      cmsg = (struct cmsghdr *)controlbuf;  sz = recvmsg(fd,&hdr,0);  if(sz < 0){    DEAMONdebugPrint("Huh read only %d errno:%d\n",sz,errno);    return;  }    DEAMONdebugPrint("Just read %d bytes from fd:%d for RdIp6<----\n",	 sz,fd);  DEAMONdebugPrintArry(readBuff,sz);  iph6 = (struct ip6_hdr *)readBuff;  DEAMONdebugPrint("protocol is %d\n",iph6->ip6_nxt);  if(iph6->ip6_nxt != IPPROTO_SCTP){    /* not a protocol I handle */    DEAMONdebugPrint("Not SCTP out of here\n");    return;  }  off = sizeof(struct ip6_hdr);  DEAMONdebugPrint("off is %d\n",off);  if((x = ntohs(iph6->ip6_plen)) != (sz-off)){    DEAMONdebugPrint("Size problem sz:%d+off:%d != read:%d\n",		     sz,off,x);    return;  }  sch = (struct sctpHeader *)((caddr_t)iph6 + off);  DEAMONdebugPrint("Take a peak at the port dest:%d  source:%d (dest=%d)\n",		   ntohs(sch->destination),		   ntohs(sch->source),		   portSpace[ntohs(sch->destination)]		   );  sh = ntohs(sch->destination);  if(portSpace[ntohs(sch->destination)] == 0){    /* no registered port */    /* OOTB no one registered */    DEAMONdebugPrint("Not registered\n");    if(isThereAAbortHere(sch,(sz-off)) == 0){      struct sctpSendableInit *ui;      ui = (struct sctpSendableInit *)sch;      sendAAbort6(iph6,sch->source,ui->msg.initm.initTag,sch->destination);    }else{      printf("Yikes abort to abort .. drop it\n");    }    return;  }  DEAMONdebugPrint("Passed the test, forward it on\n");  to.sin_family = AF_INET;  to.sin_port = sch->destination;  /* Evil but necessary */  to.sin_addr.s_addr = htonl(0x7f000001);   lastPortSentTo = sh;  ret = sendto(udpFd,readBuff,sz,0,(struct sockaddr *)&to,sizeof(to));  DEAMONdebugPrint("Sent %d bytes to %x:%d ret:%d errno:%d to client on machine\n",	 sz,ntohl(to.sin_addr.s_addr),ntohs(to.sin_port),ret,errno);}voidDeamonHandleRdIpFd(int fd,int events){  unsigned short x;  int sz,off;  struct ip *iph;  unsigned short sh;  int ret;  struct sctpHeader *sch;  struct sockaddr_in to;  sz = recv(fd,readBuff,SCTP_MAX_READBUFFER,0);  if(sz < 0){    DEAMONdebugPrint("Huh read only %d errno:%d\n",sz,errno);    return;  }  DEAMONdebugPrint("Just read %d bytes from fd:%d for RdIp<----\n",	 sz,fd);  DEAMONdebugPrintArry(readBuff,sz);  iph = (struct ip *)readBuff;  DEAMONdebugPrint("protocol is %d\n",iph->ip_p);  if(iph->ip_p != IPPROTO_SCTP){    /* not a protocol I handle */    DEAMONdebugPrint("Not SCTP out of here\n");    return;  }  off = iph->ip_hl << 2;  DEAMONdebugPrint("off is %d\n",off);#if (defined (FREEBSD) || defined (TRU64  ) || defined(AIX))/* SCTP_PB_4 */  x = iph->ip_len;  if (x != sz){    /* this is a bug: at least where     * they send me the size minus the ip_hl     * possibly. Either that or we are hosed.     */    DEAMONdebugPrint("Detected total length IP header error: sz = %d; ip_len = %d; off = %d; x = %d \n",		     sz, iph->ip_len, off, x);    if ((x + off) == sz){      /* fix */      /* BLA */      iph->ip_len = x + off;     }else{      DEAMONdebugPrint("Size problem \n");    }  }#else  if((x = ntohs(iph->ip_len)) != sz){    /* this is a bug in sun at least where     * they send me the size minus the ip_hl     * possibly. Either that or we are hosed.     */    if((x + off) == sz){      /* fix for sun */      iph->ip_len = htons((x+off));    }else{      DEAMONdebugPrint("Size problem\n");    }  }#endif  sch = (struct sctpHeader *)((u_long)iph + off);  /* SCTP_PB */  {    struct sctpChunkDesc *desc;    desc = (struct sctpChunkDesc *)((u_long)sch + sizeof(struct sctpHeader));    printChunkTypeAsText(desc->chunkID);  }  DEAMONdebugPrint("Take a peak at the port dest:%d  source:%d (dest=%d)\n",		   ntohs(sch->destination),		   ntohs(sch->source),		   portSpace[ntohs(sch->destination)]		   );  sh = ntohs(sch->destination);  if(portSpace[ntohs(sch->destination)] == 0){    /* no registered port */    /* OOTB no one registered */    DEAMONdebugPrint("Not registered\n");    if(isThereAAbortHere(sch,(sz-off)) == 0){      struct sctpSendableInit *ui;      u_long xx;      ui = (struct sctpSendableInit *)sch;      xx = ntohl(iph->ip_src.s_addr);      /*      DEAMONdebugPrint("No abort so send a abort\n");*/ printf(	"No listener for port:%d Deamon sends a abort to IP:%d.%d.%d.%d:%d tag:%x\n",	sh,	(int)((xx>>24) & 0x000000ff),	(int)((xx>>16) & 0x000000ff),	(int)((xx>>8) & 0x000000ff),	(int)(xx & 0x000000ff),	ntohs(sch->source),	(u_int)ui->msg.initm.initTag);      sendAAbort(iph->ip_src.s_addr,sch->source,		 ui->msg.initm.initTag,		 iph->ip_dst.s_addr,sch->destination);    }else{      printf("Yikes abort to abort .. drop it\n");    }    return;  }  DEAMONdebugPrint("Passed the test, forward it on\n");  to.sin_family = AF_INET;  to.sin_port = sch->destination;  to.sin_addr.s_addr = iph->ip_dst.s_addr;  lastPortSentTo = sh;  ret = sendto(udpFd,readBuff,sz,0,(struct sockaddr *)&to,sizeof(to));  DEAMONdebugPrint("Sent %d bytes to %x:%d ret:%d errno:%d to client on machine\n",	 sz,ntohl(to.sin_addr.s_addr),ntohs(to.sin_port),ret,errno);}/* SCTP_PB */void printChunkTypeAsText(const char theChunkId){  char logBuffer[256];  strcpy(logBuffer, "CHUNK id is:  ");  switch ( theChunkId )     {    case SCTP_DATA:      strcat(logBuffer, "SCTP_DATA");      break;     case SCTP_INITIATION:      strcat(logBuffer, "SCTP_INITIATION");      break;    case SCTP_INITIATION_ACK:      strcat(logBuffer, "SCTP_INITIATION_ACK");      break;    case SCTP_SELECTIVE_ACK:      strcat(logBuffer, "SCTP_SELECTIVE_ACK");      break;    case SCTP_HEARTBEAT_REQUEST:      strcat(logBuffer, "SCTP_HEARTBEAT_REQUEST");      break;    case SCTP_HEARTBEAT_ACK:      strcat(logBuffer, "SCTP_HEARTBEAT_ACK");      break;    case SCTP_ABORT_ASSOCIATION:      strcat(logBuffer, "SCTP_ABORT_ASSOCIATION");      break;    case SCTP_SHUTDOWN:      strcat(logBuffer, "SCTP_SHUTDOWN");      break;    case SCTP_SHUTDOWN_ACK:      strcat(logBuffer, "SCTP_SHUTDOWN_ACK");      break;    case SCTP_OPERATION_ERR:      strcat(logBuffer, "SCTP_OPERATION_ERR");      break;    case SCTP_COOKIE:      strcat(logBuffer, "SCTP_COOKIE");      break;    case SCTP_COOKIE_ACK:      strcat(logBuffer, "SCTP_COOKIE_ACK");      break;    case SCTP_ECN_ECHO:      strcat(logBuffer, "SCTP_ECN_ECHO");      break;          case SCTP_ECN_CWR:      strcat(logBuffer, "SCTP_ECN_CWR");      break;          case SCTP_SHUTDOWN_COMPLETE:      strcat(logBuffer, "SCTP_SHUTDOWN_COMPLETE");      break;    default:      sprintf(logBuffer, "Unknown chunk type %d", theChunkId);      break;    }  strcat(logBuffer, "\n");  DEAMONdebugPrint(logBuffer);}