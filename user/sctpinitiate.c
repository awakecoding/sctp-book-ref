/* SCTP reference Implementation Copyright (C) 2001 Cisco And MotorolaThis file is part of the SCTP reference ImplementationVersion:4.0.5$Header: /home/sourceTree/src/sctp/user/sctpinitiate.c,v 1.58 2001/07/24 11:52:39 randall Exp $The SCTP reference implementation  is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published bythe Free Software Foundation; either version 2, or (at your option)any later version.the SCTP reference implementation  is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of                ************************MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See theGNU Library General Public License for more details.You should have received a copy of the GNU Library General Public Licensealong with GNU CC; see the file COPYING.  If not, write tothe Free Software Foundation, 59 Temple Place - Suite 330,Boston, MA 02111-1307, USA.  Please send any bug reports or fixes you make to one of the following emailaddresses:rrs@cisco.comkmorneau@cisco.comqxie1@email.mot.comAny bugs reported given to us we will try to fix... any fixes shared willbe incorperated into the next SCTP release.There are still LOTS of bugs in this code... I always run on the motto"it is a wonder any code ever works :)"*/#include <sctp.h>#include <sctputil.h>#include <sctpsenders.h>#include <sctpinbound.h>#include <sctpoutofblue.h>#include <sctprelreq.h>voidSCTPupdateAcked(struct SCTP *m,		struct SCTP_association *asoc,		u_long seen,		struct sockaddr *from){  struct sctpUnifiedSack dummy;  /* set up a dummy SACK and call the   * SACK processor.   */  dummy.uh.chunkID = SCTP_SELECTIVE_ACK;  dummy.uh.chunkFlg = 0;  dummy.uh.chunkLength = htons(sizeof(dummy));  dummy.sack.highestConseqTSN = seen;  dummy.sack.updatedRwnd = htonl(asoc->peersRwnd);  dummy.sack.numberOfdesc = 0;  dummy.sack.numDupTsns = 0;  SCTP_handleInboundSack(m,asoc,&dummy,from);}voidSCTPhandleShutdown(struct SCTP *m,		   struct sctpChunkDesc *uh,		   struct SCTP_association *asoc,		   struct sockaddr *from,		   struct sockaddr *toAddr){  /* Here we must verify that all is   * acked, if so we ack with a shutdown ack and   * start the shutdown timer. Otherwise we retransmit   * stuff to the remote end based on the Seen in the    * shutdown msg. If I am missing some I need to start   * the retransmit procedures for all un-acked dg's.   */  struct sctpUnifiedShutdown *shut;  if(asoc == NULL){    /* Can't find the asoc. This     * should not now happen.     */    return;  }  shut = (struct sctpUnifiedShutdown *)uh;    SCTPupdateAcked(m,asoc,shut->shut.TSN_Seen,from);  /* set to shutdown state to block new requests */  if((asoc->state&SCTP_STATE_MASK) != SCTP_STATE_SHUTDOWN){    asoc->state = SCTP_STATE_SHUTDOWN_RECV;    SCTPdebugPrint(m,"STATE SET TO SHUTDOWN-RECV\n");  }  (*m->getTime)(&asoc->timeEnteringState);    if((asoc->outQueueCount) || (asoc->outqueue != NULL)){    /* Still have un-resolved DG's     */    SCTPsendRetransmits(m,asoc);    SCTPsendAnyWeCan(m,asoc,1);  }else{    /* here don't check return code since if it fails to     * send or get's lost, our peer will retransmit and     * we will hit the case above where the assoc     * is equal to NULL     */    SCTPsendShutdownAck(m,asoc,from,SCTP_SHUTDOWN_ACK,0,toAddr);    asoc->state = SCTP_STATE_SHUTDOWN_ACK_SENT;    SCTPdebugPrint(m,"STATE SET TO SHUTDOWN-ACK-SENT\n");    timerWork(m,asoc,SCTP_TIMER_START,SctpTimerTypeShutdownAck,0);  }}void SCTPhandleShutdownAck(struct SCTP *m,			   struct sctpChunkDesc *uh,			   struct SCTP_association *asoc,			   struct sockaddr *from,			   struct sockaddr *toAddr){  /* Here we process the shutdown ack i.e. terminate   * the association and report to upper layer as   * needed.   */  if(asoc == NULL){    /* nothing we can do, already asoc is gone     */    return;  }  if(((asoc->state&SCTP_STATE_MASK) != SCTP_STATE_SHUTDOWN) &&     ((asoc->state&SCTP_STATE_MASK) != SCTP_STATE_SHUTDOWN_ACK_SENT)){    /* may be a attack, probably should report     * to upper layer. Will ignore since I am     * not shutting down.     */    return;  }  /* Ok if we reach here we are shutting down   * and we have been ack'd.   */  SCTPupperLayerNotification(m,asoc,SCTP_NOTIFY_ASSOC_DOWN,0);  /* asoc->outQueueCount should be 0 */  if((asoc->outQueueCount) || (asoc->outqueue != NULL)){    /* this really should not happen since I should     * not have sent the shutdown-ack if I had any      * un-resolved dg's but we check here anyway     */    SCTPreportAllOutboundLost(m,asoc);  }  SCTPsendShutdownAck(m,asoc,from,SCTP_SHUTDOWN_COMPLETE,0,toAddr);  /* now stop any rec timer  - should not be running   * since the peer is supposed to make sure all   * un-resloved dg's are done before sending   * shutdown.   */  timerWork(m,asoc,SCTP_TIMER_STOP,SctpTimerTypeShutdown,0);  SCTPfreeAssociation(m,asoc);  return;}void SCTPhandleShutdownComplete(struct SCTP *m,				struct sctpChunkDesc *uh,				struct SCTP_association *asoc){  /* Here we process the shutdown complete i.e. terminate   * the association and report to upper layer as   * needed.   */  if(asoc == NULL){    /* nothing we can do, already the assoc is gone. TSNH     */    return;  }  if((asoc->state&SCTP_STATE_MASK) != SCTP_STATE_SHUTDOWN_ACK_SENT){    /* may be a attack, probably should report     * to upper layer. Will ignore since I am     * not shutting down.     */    return;  }  /* Ok if we reach here we are shutting down   * and we have been ack'd.   */  SCTPupperLayerNotification(m,asoc,SCTP_NOTIFY_ASSOC_DOWN,0);  /* asoc->outQueueCount should be 0 */  if((asoc->outQueueCount) || (asoc->outqueue != NULL)){    /* this really should not happen since I should     * not have sent the shutdown-ack if I had any      * un-resolved dg's but we check here anyway     */    SCTPreportAllOutboundLost(m,asoc);  }  /* now stop any rec timer  - should not be running   * since the peer is supposed to make sure all   * un-resloved dg's are done before sending   * shutdown.   */  timerWork(m,asoc,SCTP_TIMER_STOP,SctpTimerTypeShutdown,0);  SCTPfreeAssociation(m,asoc);  return;}inthandleOpErrStaleCookie(struct SCTP *m,		       struct SCTP_association *asoc,		       struct sockaddr *from){  /* we must now look at the state of the   * association to figure out what to do.   */  SCTPdebugPrint(m,"Stale cookie in state %d\n",asoc->state);  switch(asoc->state&SCTP_STATE_MASK){  case SCTP_STATE_COOKIE_SENT:    /* we expect to be here, if we are here,     * we need to go back to the SCTP_STATE_COOKIE_WAIT and     * send off another init and hope that we make it     * in the right amount of time .. we don't ask for extensions :-(     */    asoc->state = SCTP_STATE_COOKIE_WAIT;    SCTPdebugPrint(m,"STATE SET TO COOKIE_WAIT\n");    asoc->staleCookieCount++;    SCTPdebugPrint(m,"Back to the INIT stage count to %d\n",		   asoc->staleCookieCount);    if(asoc->staleCookieCount < SCTP_MAX_STALE_COOKIES_I_COLLECT){      /* Ok, we will return out of here, feeding this       * to the pigeons and re-trying.       */      SCTPdebugPrint(m,"Out goes a INIT again\n");      SCTPsendInitiate(m,asoc);      if(asoc->cookie != NULL){	w_free(m,asoc->cookie);	asoc->cookie = NULL;      }      timerWork(m,asoc,SCTP_TIMER_STOP,SctpTimerTypeInit,0);      timerWork(m,asoc,SCTP_TIMER_STOP,SctpTimerTypeCookie,0);      timerWork(m,asoc,SCTP_TIMER_START,SctpTimerTypeInit,0);    }else{      /* flup, we must give the rats their due, and give up */      SCTPdebugPrint(m,"Rats, we are out of luck\n");      SCTPreportAllOutboundLost(m,asoc);      SCTPupperLayerNotification(m,asoc,SCTP_NOTIFY_ASSOC_DOWN,				 (int)from);      SCTPfreeAssociation(m,asoc);      return(1);    }    break;  default:  case SCTP_STATE_COOKIE_WAIT:  case SCTP_STATE_OPEN:  case SCTP_STATE_SHUTDOWN:  case SCTP_STATE_SHUTDOWN_RECV:  case SCTP_STATE_SHUTDOWN_PEND:  case SCTP_STATE_EMPTY:  case SCTP_STATE_INUSE:    /* the following should NOT happen */    printf("Impossible state? whats up with a stale cookie? attacker?\n");    break;  }  return(0);}voidSCTPhandleAbort(struct SCTP *m,		struct sctpChunkDesc *uh,		struct SCTP_association *asoc,		struct sockaddr *toAddr){  struct sctpUnifiedAbort *uabrt;  int adrIndx;  if(asoc == NULL){    /* we don't have a association for this guy     * so just return;     */    return;  }  /* first verify that the address in question is not   * being deleted   */  if(SCTPisToAddressInAssociation(m,asoc,toAddr,&adrIndx,0) == 0){    /* Huh? we did this earlier*/    return;  }  if(asoc->addrStats[adrIndx] == SCTP_ADDR_BEING_DELETED){    SCTPdebugPrint(m,"Ignoring ABORT on a address being deleted\n");    return;  }  uabrt = (struct sctpUnifiedAbort *)uh;  /* here the guy dies so we   * just free the association    * for the guy.   */  /* arg gets the number of lost dg's being sent */  SCTPupperLayerNotification(m,asoc,SCTP_NOTIFY_ASSOC_ABORTED,			     asoc->outQueueCount);  /* report the lost dg's  and clean up timer */  SCTPreportAllOutboundLost(m,asoc);  /* now stop any rec timer */  timerWork(m,asoc,SCTP_TIMER_STOP,SctpTimerTypeRecv,0);  /* now free the assoc */  SCTPfreeAssociation(m,asoc);  return;}struct SCTP_association *SCTPstartInit(struct SCTP *m,struct sockaddr *to,int options){  struct SCTP_association *asoc;  /* This function will allocate a association    * and then get the initiate message sent off   * to the guy.   * It returns the sctp association so that   * the caller may elect to queue outbound   * messages in outbound for stream 0.   */  int locScope,siteScope,ipv4Scope;  SCTPdebugPrint(m,"Starting INIT for a address type %d addr:%x\n",		 to->sa_family,(u_int)to);  if(to->sa_family == AF_INET6){    /* setup scope of to address */    struct sockaddr_in6 *a6;    a6 = (struct sockaddr_in6 *)to;    if(IN6_IS_ADDR_LINKLOCAL(&a6->sin6_addr)){      SCTPdebugPrint(m,"Scope all\n");      locScope = siteScope = 1;      /*      ipv4Scope = 0;*/      ipv4Scope = 1;    }else if(IN6_IS_ADDR_SITELOCAL(&a6->sin6_addr)){      SCTPdebugPrint(m,"Scope site/global\n");      locScope = 0;      siteScope = 1;      /*ipv4Scope = 0;*/      ipv4Scope = 1;    }else{      SCTPdebugPrint(m,"Scope global\n");      locScope = 0;      siteScope = 0;      ipv4Scope = 1;      /*      ipv4Scope = 0;*/    }  }else{    struct sockaddr_in *sin;    SCTPdebugPrint(m,"Scope global (v4 to)\n");    sin = (struct sockaddr_in *)to;    /* IPv6 scope only global */    locScope = 0;    siteScope = 1;    /* now what about to address? */    /*    if(IN4_ISPRIVATE_ADDRESS(&sin->sin_addr)){*/      /* private address */      ipv4Scope = 1;      /*    }*/  }  asoc = SCTPalocAssociation(m,to,locScope,siteScope,ipv4Scope);  if(asoc == NULL){    errno = ENOSPC;    return(NULL);  }  if(options != 0){    asoc->sendMode = options & SCTP_STICKY_OPTIONS_MASK;    if(options & SCTP_MY_ADDRESS_ONLY){      asoc->sendMode |= SCTP_MY_ADDRESS_ONLY;    }  }  if(SCTPsendInitiate(m,asoc) < 0){    SCTPreportAllOutboundLost(m,asoc);    SCTPdebugPrint(m,"Now notify down asoc\n");    SCTPupperLayerNotification(m,asoc,SCTP_NOTIFY_ASSOC_DOWN,			       (int)to);    SCTPfreeAssociation(m,asoc);    return(NULL);  }  /* if mtu discovery is on, i.e. we had permission we   * set this up high (around 8k) and let it find out the   * real MTU's. Else we set it to a min safe value (512).   */  asoc->smallestMTU = SCTP_DEFAULT_MAXSEGMENT;  asoc->state = SCTP_STATE_COOKIE_WAIT;  SCTPdebugPrint(m,"STATE SET TO COOKIE-WAIT\n");  timerWork(m,asoc,SCTP_TIMER_START,SctpTimerTypeInit,0);  /* Record the time so we can at least calculate RTT on   * the first interface.   */  (*m->getTime)(&asoc->timeEnteringState);    return(asoc);}voidSCTP_handleInitateIn(struct SCTP *m,		     struct sctpUnifiedInit *uh,		     struct sockaddr *from,		     struct SCTP_association *aoc,		     struct sockaddr *toAddr){  struct sctpInitiation *inits;  struct SCTP_association *pasoc;  char *operr;  int operrsz;  struct cookieMessage *cookie;  int lenOfCook;  int tcbNotDestroyed;	/* its really special :-) */  u_long tmp;  /* This function must handle all the details of   * getting a init message. This may either be   * a new init or it can be the simulataneous init   * if we both happen to init at the same time.   */  tcbNotDestroyed = 0;  pasoc = aoc;  SCTPdebugPrint(m,"handleInitiateIn\n");  if(pasoc == NULL){    /* do special lookup just in case     * I have this guy and he responded on     * a different intf.     */    SCTPdebugPrint(m,"asoc null so special lookup on order\n");    pasoc = SCTPspecialFindAssociation(m,uh,from);  }  if(pasoc != NULL){    SCTPdebugPrint(m,"check shutdown case\n");    if((pasoc->state&SCTP_STATE_MASK) == SCTP_STATE_SHUTDOWN_ACK_SENT){      /* special case of I want a Shutdown-complete       * and the peer now sends a INIT. the S-C was lost?       */      SCTPdebugPrint(m,"out of here, send s-a\n");      SCTPsendShutdownAck(m,pasoc,from,SCTP_SHUTDOWN_ACK,0,toAddr);      return;    }else if((pasoc->state&SCTP_STATE_MASK) != SCTP_STATE_COOKIE_WAIT){      if(sctpVerifyNoNewAddress(m,pasoc,uh,from)){	/* yes they added a new address that had another association 	 * discard the cookie by returning NULL.	 */	/* Fix, If I want to ABORT, send it here ... */	SCTPsendAAbort(m,pasoc,from,inits->initTag,0,1);	return;            }    }else{      /* we are in cookie wait. We must override who the       * message came from with where we sent our INIT.       */      from = pasoc->nets[0].ina;    }  }  inits = &uh->initm;		  /* un-network the tags */  tmp = (u_long)ntohl(inits->initTag);  inits->initTag = tmp;  tmp = (u_long)ntohl(inits->rcvWindowCredit);  inits->rcvWindowCredit = tmp;  if(inits->rcvWindowCredit < SCTP_MIN_RWND){    /* below min RWND? if so abort */    SCTPsendAAbort(m,pasoc,from,inits->initTag,		   SCTP_OP_ERROR_INV_PARAM,1);        return;  }  tmp = (u_long)ntohs(inits->NumPreopenStreams);  inits->NumPreopenStreams = tmp;  if(tmp == 0){    /*      * Violation of the protocol.     *      */    SCTPsendAAbort(m,pasoc,from,inits->initTag,0,1);    return;  }  tmp = (u_long)ntohs(inits->MaxInboundStreams);  inits->MaxInboundStreams = tmp;  if(tmp == 0){    /*      * Violation of the protocol.     *      */    SCTPsendAAbort(m,pasoc,from,inits->initTag,0,1);    return;  }  tmp = (u_long)ntohl(inits->initialTSN);  inits->initialTSN = tmp;  SCTPdebugPrint(m,"Initiate inbound\n");  operr = NULL;  operrsz = 0;  cookie = SCTPbuildACookie(m,			    pasoc,			    uh,			    &lenOfCook,			    &operr,			    &operrsz,			    from);  /* send it back */  if(cookie != NULL){    SCTPdebugPrint(m,"Sending out the INIT-ACK+Cookie!!\n");    if(operr != NULL){      struct sctpParamDesc *p;      p = (struct sctpParamDesc *)operr;      p->paramType = htons(SCTP_UNRECOG_PARAM);      SCTPdebugPrint(m,"Operational Error is tacked on %d bytes\n",operrsz);    }    /* change operr from chunk to param */    SCTPsendInitiateAck(m,from,cookie,lenOfCook,inits->initTag,operr,operrsz,			toAddr);    if(operr != NULL){      w_free(m,operr);    }    w_free(m,cookie);  }else{    SCTPdebugPrint(m,"No cookie to send :( no INIT-ACK\n");    if(operr != NULL){      /* send of the op error */      struct sctpChunkDesc *chk;      chk = (struct sctpChunkDesc *)operr;      SCTPsendOpErr(m,from,operr,operrsz,inits->initTag);      w_free(m,operr);    }else{      /* Only other reason that a cookie could not be       * built is a resource problem, send an abort.       */      SCTPsendAAbort(m,(struct SCTP_association *)NULL,		     from,inits->initTag,SCTP_OP_ERROR_NO_RESOURCE,1);    }  }}  intSCTPadoptThisInit(struct SCTP *m,		  struct sockaddr *from,		  struct SCTP_association *asoc,		  struct sctpUnifiedInit *msg)     		     {  int ii,ret;  struct sctpInitiation *inits;  struct sctpParamDesc *preferedPrim;  int deadflag;  inits = &msg->initm;  asoc->hisTag = inits->initTag;  asoc->peersRwnd = inits->rcvWindowCredit;  SCTPdebugPrint(m,"***Adopting the INIT tag of peer to %x\n",inits->initTag);    if(asoc->preOpenStreams > inits->MaxInboundStreams){    /* cut back my preopened streams. */    SCTPdebugPrint(m,"Cutting back my streams to %d\n",		   inits->MaxInboundStreams);    asoc->preOpenStreams = inits->MaxInboundStreams;  }  if(inits->NumPreopenStreams > MAX_SCTP_STREAMS){    inits->NumPreopenStreams = MAX_SCTP_STREAMS;  }  asoc->streamincnt = inits->NumPreopenStreams;  asoc->streamoutcnt = asoc->preOpenStreams;  asoc->relReqSeqIn = asoc->highestTSNinside = asoc->mappingArrayHighestTSN =  inits->initialTSN - 1;  asoc->lastEcho_TSN = asoc->mappingArrayHighestTSN;  /* open up all the streams he wants */  SCTPdebugPrint(m,"3:Now do any preopen streams each way mine:%d his:%d\n",		 asoc->preOpenStreams,inits->NumPreopenStreams);  {    int i,j,sp,ep,cksz,sizeLimit,numSets;    char *paramarea, *operr=NULL;    int death=0, operrsz=0 ;    struct sctpParamDesc *datasrch;    struct sctpUnrelStrmRange *sr;    if(asoc->strmin != NULL){      free (asoc->strmin);    }    asoc->strmin = w_calloc(m,inits->NumPreopenStreams,			  sizeof(struct SCTP_stream_in));    for(i=0;i<inits->NumPreopenStreams;i++){      asoc->strmin[i].lastSequenceDelivered = 0xffff;      asoc->strmin[i].inqueue = NULL;      asoc->strmin[i].reliable = SCTP_STRM_RELIABLE;    }    /* need to set (un)reliability flag here for u-sctp (XIE) */    /* first see if there is a u-sctp param present */    cksz = ntohs(msg->uh.chunkLength);    sizeLimit = cksz - sizeof(struct sctpUnifiedInit);    paramarea = (char *)((u_long)msg + sizeof(struct sctpUnifiedInit));    datasrch = findAParameter(m,SCTP_UNRELIABLE_STRM,paramarea,			      sizeLimit,&death,&operr,&operrsz);    /* ignore error here, will be caught later */    if(datasrch) {      numSets = (ntohs(datasrch->paramLength) - sizeof(struct sctpParamDesc)) /	        (sizeof(struct sctpUnrelStrmRange));      SCTPdebugPrint(m,"peer is u-sctp capable (sets=%d)\n", numSets);      datasrch++;      sr = (struct sctpUnrelStrmRange *)datasrch;      for(i=0;i<numSets;i++) {	sp = ntohs(sr->UnrelStrmStart);	ep = ntohs(sr->UnrelStrmEnd);	for(; (sp<=ep && sp<inits->NumPreopenStreams); sp++) {	  if(sp == 0) {	    asoc->inbound.reliable = SCTP_STRM_UNRELIABLE;	  } else {	    asoc->strmin[sp-1].reliable = SCTP_STRM_UNRELIABLE;	  }	  SCTPdebugPrint(m,"set in-stream #%d unreliable\n", sp);	}	sr++;      }    }    if(asoc->strmout != NULL){      /* PHIL CONRAD HEADS UP */      /* since this is a common module called by       * both the INIT and INIT-ACK processing       * we must save off the nextSeq that may have       * been set by the sending to stream 0 that starts       * our association (udp model). This would increment the stream       * count on the outbound sequence number. This must be       * preserved if the outbound is every collapsed to the        * array ... Hint PHIL! You must also be aware that you alloc       * only a array of 1 and now may be re-allocating :)...       */       free (asoc->strmout);    }    asoc->strmout = w_calloc(m,asoc->preOpenStreams,			   sizeof(struct SCTP_stream_out));    for(i=0;i<asoc->preOpenStreams;i++){      asoc->strmout[i].nextSequenceSent = 0;      asoc->strmout[i].reliable = SCTP_STRM_RELIABLE;    }    /* now we set unreliable streams, if any,  using     * the pre-stored mark array. however, if the peer does not     * support u-sctp (by returning an error), we will change     * all strmout[] back to reliable and report to ULP     */    SCTPdebugPrint(m,"Now we set our unreliable o-streams\n");    for(j=0; j<MAX_UNRELSTREAM_SETS*2; j+=2) {      sp = m->unrelStreamSets[j]; /* start */      ep = m->unrelStreamSets[j+1]; /* end */      if(sp < 0 || ep <0) break; /* done */      for(; (sp<=ep && sp<asoc->preOpenStreams); sp++) {	if(sp==0) {	  asoc->outbound.reliable = SCTP_STRM_UNRELIABLE;	} else {	  asoc->strmout[sp-1].reliable = SCTP_STRM_UNRELIABLE; 	}	SCTPdebugPrint(m,"set o-stream #%d unreliable\n", sp);      }    }  }  /* build a mapping array to track which   * datagrams have arrived.   */  if(asoc->mappingArray != NULL){    w_free(m,asoc->mappingArray);  }  asoc->mappingArray = w_calloc(m,1,SCTP_STARTING_MAPARRAY);  if(asoc->mappingArray == NULL){    SCTPfreeAssociation(m,asoc);    return(-1);  }  asoc->mappingArraySz = SCTP_STARTING_MAPARRAY;  memset(asoc->mappingArray,0,SCTP_STARTING_MAPARRAY);  /* update addresses */  preferedPrim = NULL;  asoc->opErr = SCTPupdateAllAddresses(m,asoc,msg,from,&deadflag,				       &asoc->opErrSiz,				       &preferedPrim);  if(deadflag){    if(deadflag > 0)      SCTPdebugPrint(m,"Unrecognized parameter causes death of association\n");    else       SCTPdebugPrint(m,"Duplicately keyed address causes death of association\n");    SCTPreportAllOutboundLost(m,asoc);    SCTPupperLayerNotification(m,asoc,SCTP_NOTIFY_ASSOC_DOWN,			       (int)from);    SCTPfreeAssociation(m,asoc);    return(-1);  }  /* make any necessary DNS query */  if(asoc->DNSname[0] != 0){    SCTPdebugPrint(m,"Going to make a DNS query\n");    ret = SCTPmakeAnyDNSQuery(m,asoc);    if(ret < 0){      struct sctpUnifiedOpError *ue;      struct sctpOpErrorCause *c;      u_short *what;      /* here we turn on the restrict address flag       * to get the address list sent in the INIT.       * Resend the INIT and start the timer again       */      SCTPdebugPrint(m,"DNS query fails\n");      c = NULL;      if(asoc->opErr == NULL){	asoc->opErrSiz = (sizeof(struct sctpUnifiedOpError)+4);	asoc->opErr = w_calloc(m,1,asoc->opErrSiz);	ue = (struct sctpUnifiedOpError *)asoc->opErr;	c = &ue->c;      }else{	char *newlist;	newlist = w_calloc(m,1,((sizeof(struct sctpUnifiedOpError)+4) + asoc->opErrSiz));	if(newlist != NULL){	  memcpy(newlist,asoc->opErr,asoc->opErrSiz);	  ue = (struct sctpUnifiedOpError *)(asoc->opErr);	  c = (struct sctpOpErrorCause *)((u_long)asoc->opErr + asoc->opErrSiz);	  asoc->opErrSiz += (sizeof(struct sctpUnifiedOpError)+4);	  w_free(m,asoc->opErr);	  asoc->opErr = newlist;	}else{	  ue = NULL;	}      }      if(c != NULL){	/* we fill this out every time even though	 * we know the sendaabort will blast it	 * and only use the cause sections. It does	 * use the length of the chunk though..	 */	what = (u_short *)((u_long)c + sizeof(*c));	ue->uh.chunkID = SCTP_OPERATION_ERR;	ue->uh.chunkFlg = 0;	ue->uh.chunkLength = htons(asoc->opErrSiz);	/* it is a unresovable address */	c->cause = htons(SCTP_OP_ERROR_DNS_FAILED);	/* we always have cause/len and the unrecognized address + 2 pad bytes	 * not included in the length.. i.e. 12	 */	c->causeLen = ntohs(12);	*what = htons(SCTP_HOSTNAME_VIA_DNS);	what++;	/* zero out the pad */	*what = 0;      }      return(-2);    }  }  /* now correct which address we received the dg on.   */  SCTPdebugPrint(m,"4:We now have %d addresses to sort through\n",		 asoc->numnets);  for(ii=0;ii<asoc->numnets;ii++){    SCTPdebugPrint(m,"Association net index[%d] address\n");    SCTPdebugPrintAddress(m,asoc->nets[ii].ina);    if(from->sa_family != asoc->nets[ii].ina->sa_family){      SCTPdebugPrint(m,"5:Skipping unlike family at %d\n",ii);      continue;    }    if(from->sa_family == AF_INET){      struct sockaddr_in *sin,*sfrm;      SCTPdebugPrint(m,"5:compare IPv4 at %d\n",ii);      sin = (struct sockaddr_in *)asoc->nets[ii].ina;      sfrm = (struct sockaddr_in *)from;      if(sfrm->sin_addr.s_addr == sin->sin_addr.s_addr){	SCTPdebugPrint(m,"5:update after load to where we rec from for address:%d\n",ii);	asoc->primary_destination = asoc->lastNetRcvdFrom = ii;	break;      }    }else if(from->sa_family == AF_INET6){      struct sockaddr_in6 *sin6,*sfrm6;      SCTPdebugPrint(m,"5:compare IPv6 at %d\n",ii);      sin6 = (struct sockaddr_in6 *)asoc->nets[ii].ina;      sfrm6 = (struct sockaddr_in6 *)from;      if(IN6_ARE_ADDR_EQUAL(&sfrm6->sin6_addr,&sin6->sin6_addr)){	SCTPdebugPrint(m,"5:update after load to where we rec from for address:%d\n",ii);	asoc->primary_destination =  asoc->lastNetRcvdFrom = ii;	break;      }    }  }  if((preferedPrim != NULL) &&     (ntohs(preferedPrim->paramType) == SCTP_SETADDRESS_PRIMARY)){    /* peer has a prefered primary_destination */    int type,indx;    struct SCTP_association *lasoc;    SCTPdebugPrint(m,"66:Set prefered primary if possible\n");    preferedPrim++;    lasoc = NULL;    type = ntohs(preferedPrim->paramType);    if(type == SCTP_IPV4_PARAM_TYPE){      struct sockaddr_in x;      struct sctpV4IpAddress *point;      point = (struct sctpV4IpAddress *)preferedPrim;      memset(&x,0,sizeof(x));      x.sin_port = ((struct sockaddr_in *)asoc->nets[0].ina)->sin_port;      x.sin_family = AF_INET;      x.sin_addr.s_addr = point->ipAddress;#ifdef USES_BSD_4_4_SOCKET      x.sin_len = sizeof(struct sockaddr_in);#endif      lasoc = SCTPfindAssociation(m,(struct sockaddr *)&x,&indx);    }else if(type == SCTP_IPV6_PARAM_TYPE){      struct sockaddr_in6 x6;      struct sctpV6IpAddress *point6;      point6 = (struct sctpV6IpAddress *)preferedPrim;      memset(&x6,0,sizeof(x6));      x6.sin6_port = ((struct sockaddr_in6 *)asoc->nets[0].ina)->sin6_port;#ifdef USES_BSD_4_4_SOCKET      x6.sin6_len = sizeof(struct sockaddr_in6);#endif      x6.sin6_family = AF_INET6;      memcpy((char *)&x6.sin6_addr,	     point6->ipAddress,	     sizeof(struct in6_addr));      lasoc = SCTPfindAssociation(m,(struct sockaddr *)&x6,&indx);    }    if(lasoc == asoc){      /* Ok set it as primary and we are done */      SCTPdebugPrint(m,"Set primary for IP address idx:[%d] old primary was %d\n",		     indx,		     asoc->primary_destination);      asoc->primary_destination = indx;    }  }  return(0);}intSCTPadoptThisInitAck(struct SCTP *m,		     struct sockaddr *from,		     struct SCTP_association *asoc,		     struct sctpUnifiedInit *msg){  int ret;  /* now we need a cookie */  SCTPdebugPrint(m,"1:I think I am hungry for a cookie!\n");  /* pull out the cookie */  SCTPupdateACookie(m,asoc,msg,from);  if(asoc->cookie == NULL){    /* Hmm, I am still hungry, no cookie? */    /* we ret -1 so that the caller will back out and     * leave all the timers running etc.     */    SCTPdebugPrint(m,"Oh no, no cookie... I give up\n");    return(-1);  }  SCTPdebugPrint(m,"2:Yum Yum\n");  /* First do the adopt the INIT things. */  if((ret = SCTPadoptThisInit(m,from,asoc,msg)) != 0){    if(ret == -2){      /* DNS query failed */      asoc->restrictAddresses = 1;      SCTPsendInitiate(m,asoc);      timerWork(m,asoc,SCTP_TIMER_STOP,SctpTimerTypeInit,0);      timerWork(m,asoc,SCTP_TIMER_START,SctpTimerTypeInit,0);    }    return(ret);  }  SCTPdebugPrint(m,"3:RTO calculation for Init/Init-Ack exchange\n");  if(asoc->overallErrorCount == 0){    SCTPdebugPrint(m,"No errors calculate RTO\n");    asoc->nets[asoc->lastNetRcvdFrom].RTO = calculateRTO(m,asoc,asoc->lastNetRcvdFrom,							 asoc->timeEnteringState.tv_sec,							 asoc->timeEnteringState.tv_nsec);  }  SCTPdebugPrint(m,"4:adopted it stop timer and return\n");  /* stop any init timer I have running */  timerWork(m,asoc,SCTP_TIMER_STOP,SctpTimerTypeInit,0);  return(0);}struct SCTP_association *SCTP_handleInitateAck(struct SCTP *m,		      struct sctpUnifiedInit *uh,		      struct sockaddr *from,		      struct SCTP_association *aoc,		      struct sctpHeader *dg){  struct SCTP_association *asoc;  struct sctpInitiation *inits;  u_int tmp;  /* This function must handle all the details of   * getting a init message ACK. This may either be   * a first or duplicate response to a previous init.   */  tmp = 0;  asoc = aoc;  if(asoc == NULL){    /* do special lookup since this guy     * may have responded from a different     * IP address/port than I sent to and at     * the time I did not know all his addresses.     */    SCTPdebugPrint(m,"Doing special find assoc\n");    asoc = SCTPspecialFindAssociation(m,uh,from);    SCTPdebugPrint(m,"Special found %x\n",(u_int)asoc);  }  if(asoc == NULL){    /* must be a old stray or something     * since I can't find a association that I have     * started with it.. could be a man in the middle     * or some old stray dg.     */    SCTPdebugPrint(m,"Can't find asoc discard\n");    return(NULL);  }  if(ntohl(dg->verificationTag) != asoc->curTag){    /* attacker possibly.. ignore dg */    return(NULL);  }  inits = (struct sctpInitiation *)((u_long)uh + 				    sizeof(struct sctpChunkDesc));  /* un-network the tags */  tmp = (u_long)ntohl(inits->initTag);  inits->initTag = tmp;  if(inits->initTag == 0){    /* invalid tag */    SCTPreportAllOutboundLost(m,asoc);    SCTPupperLayerNotification(m,asoc,SCTP_NOTIFY_ASSOC_DOWN,			       (int)from);    SCTPfreeAssociation(m,asoc);    return(NULL);  }    tmp = (u_long)ntohl(inits->rcvWindowCredit);  inits->rcvWindowCredit = tmp;  if(inits->rcvWindowCredit < SCTP_MIN_RWND){    /* Can't have an associationwith someone with     * such a small rwnd     */    SCTPreportAllOutboundLost(m,asoc);    SCTPupperLayerNotification(m,asoc,SCTP_NOTIFY_ASSOC_DOWN,			       (int)from);    SCTPfreeAssociation(m,asoc);    return(NULL);  }  tmp = (u_long)ntohs(inits->NumPreopenStreams);  inits->NumPreopenStreams = tmp;  if(tmp == 0){    /*      * Violation of the protocol.     *      */    SCTPfreeAssociation(m,asoc);    return(NULL);  }  tmp = (u_long)ntohs(inits->MaxInboundStreams);  inits->MaxInboundStreams = tmp;  if(tmp == 0){    /*      * Violation of the protocol.     *      */    SCTPfreeAssociation(m,asoc);    return(NULL);  }  tmp = (u_long)ntohl(inits->initialTSN);  inits->initialTSN = tmp;  switch (asoc->state&SCTP_STATE_MASK){  case SCTP_STATE_COOKIE_WAIT:    /* This is the normal case     * here we get a ack of our init.     */    SCTPdebugPrint(m,"I inited him and he responded data now:\n");    if(SCTPadoptThisInitAck(m,from,asoc,uh) < 0){      return(NULL);    }      /* Now if we have any to send we launch them off to     * the initial window size..     */    SCTPdebugPrint(m,		   "Ok we will now start the timer and let the send happen\n");    SCTPdebugPrintArry(m,(char *)uh,(sizeof(*uh) + 8));    if(asoc->state & SCTP_STATE_SHUTDOWN_PEND){      asoc->state = SCTP_STATE_COOKIE_SENT | SCTP_STATE_SHUTDOWN_PEND;      SCTPdebugPrint(m,"STATE SET TO COOKIE_SENT | SHUTDOWN PENDING\n");    }else{      asoc->state = SCTP_STATE_COOKIE_SENT;      SCTPdebugPrint(m,"STATE SET TO COOKIE_SENT\n");    }    /* new shot at RTO calculation */    asoc->overallErrorCount = 0;    (*m->getTime)(&asoc->timeEnteringState);      SCTPdebugPrint(m,"Time to do the timers\n");    /* collapse the init timer back in case of a exponential backoff */    asoc->initsectim = m->baseTimeoutSecs[SCTP_TIMER_INIT];    asoc->initusectim = m->baseTimeoutNSecs[SCTP_TIMER_INIT];    timerWork(m,asoc,SCTP_TIMER_START,SctpTimerTypeCookie,0);    /* the send at the end of the inbound data processing will     * cause the cookie to be sent.     */    break;  case SCTP_STATE_SHUTDOWN:    SCTPdebugPrint(m,"Hmm I-A in shutdown discard since I am leaving now\n");    break;  case SCTP_STATE_COOKIE_SENT:    SCTPdebugPrint(m,"Hmm I-A in cookie sent? discard\n");    break;  case SCTP_STATE_OPEN:    SCTPdebugPrint(m,"Hmm I-A in open? discard\n");    break;  case SCTP_STATE_EMPTY:  case SCTP_STATE_INUSE:  default:    /* This case should NOT happen. I somehow     * only got through part of my init and never     * moved to initing after I allocated it, or I     * found one for this that was empty?     */    SCTPdebugPrint(m,"Software ERROR at init empty/in-use gets I-A %x?\n",		   asoc->state);    return(NULL);    break;  };  return(asoc);}struct SCTP_association *SCTP_handleControlPortion(struct SCTP *m,			  struct sctpHeader *dg,				  struct SCTP_association *as,			  struct sockaddr *from,			  unsigned int sizeOfDg,			  struct sctpChunkDesc **rest,			  int *netOn1,			  int *gotCookie,			  int *sizeLeft,			  struct sockaddr *toAddr){  struct SCTP_association *asoc;  struct sctpChunkDesc *desc,*tmp;  int countInLoop,sawTheCookie;  int netOn;  int echoSeen;  char *nameof;  u_int ttag;  static char *controlMappings[] = {    "SCTP_DATA",    "SCTP_INITIATION",    "SCTP_INITIATION_ACK",    "SCTP_SELECTIVE_ACK",    "SCTP_HEARTBEAT_REQUEST",    "SCTP_HEARTBEAT_ACK",    "SCTP_ABORT_ASSOCIATION",    "SCTP_SHUTDOWN",    "SCTP_SHUTDOWN_ACK",    "SCTP_OPERATION_ERR",    "SCTP_COOKIE",    "SCTP_COOKIE_ACK",    "SCTP_ECN_ECHO",    "SCTP_ECN_CWR",    "SCTP_SHUTDOWN_COMPLETE",    "SCTP_UNKNOWN:",    "SCTP_REL-REQ",    "SCTP_REL-ACK",  };  /* process and handle some number of   * control chunks in this datagram   */  netOn = *netOn1;  sawTheCookie = 0;  desc = *rest;  echoSeen = 0;  if((desc->chunkID != SCTP_INITIATION) &&      (desc->chunkID != SCTP_INITIATION_ACK) &&     (desc->chunkID != SCTP_COOKIE)     ){    if((desc->chunkID == SCTP_ASCONF) && (as == NULL)){      /* look into the packet to find the association */      SCTPdebugPrint(m,"Asconf find of association\n");      as = findAssociationForAsconf(m,(struct sctpRelChunkDesc *)desc,from);      SCTPdebugPrint(m,"Returns %x\n",(u_int)as);    }    if(as == NULL){      SCTPdebugPrint(m,"no association for this guy OOTB\n");      SCTP_handleOutOfBlue(m,from,dg,sizeOfDg,toAddr);      *rest = NULL;      return(NULL);    }    ttag = ntohl(dg->verificationTag);    SCTPdebugPrint(m,"ttag for verify is %x\n",ttag);    if((desc->chunkID == SCTP_ABORT_ASSOCIATION) ||       (desc->chunkID == SCTP_SHUTDOWN_COMPLETE)){      /* aborts and Shutdown completes are special, the tag can be his or mine */      SCTPdebugPrint(m,"Chunk is an ABORT so special handling\n");      if((ttag == as->curTag) ||	 ((desc->chunkFlg & SCTP_HAD_NO_TCB) && (ttag == as->hisTag) && ttag)	 ){	;      }else{	/* attacker possibly.. ignore dg */	*rest = NULL;	return(NULL);      }    }else if(desc->chunkID == SCTP_SHUTDOWN_ACK){      SCTPdebugPrint(m,"Chunk is an SHUTDOWN_ACK so special handling\n");      if(ttag == as->curTag){	;      }else{	/* this could be a old stale SHUTDOWN-ACK or	 * the peer never got the SHUTDOWN-COMPLETE and	 * thus is still hung, I since have started a	 * new association.. but he won't give up	 * until he gets a SHUTDOWN-COMPLETE.. then	 * he will let my new assoc come up.	 */	SCTPsendShutdownAck(m,(struct SCTP_association *)NULL,from,			    SCTP_SHUTDOWN_COMPLETE,dg->verificationTag,			    toAddr);	*rest = NULL;	return(NULL);      }    }else{      /* ok not a abort so it MUST be my tag */      SCTPdebugPrint(m,"All other types must match there tag %x vs %x\n",		     ttag,as->curTag);      if(ttag != as->curTag){	/* attacker possibly.. ignore dg */	SCTPdebugPrint(m,"Intruder alert Deck 4, intruder caught and discarded!\n");	*rest = NULL;	return(NULL);      }    }  }  /* end if((desc->chunkID != SCTP_INITIATION) &&     *        (desc->chunkID != SCTP_INITIATION_ACK) &&   *        (desc->chunkID != SCTP_COOKIE)){   */       /* INIT's, INIT-ACK's and Cookie's will fall through the   * above into the processing.   */  SCTPdebugPrint(m,"Past TAG checks into the control stuff\n");  asoc = as;  /* unless we reach bottom none left */  *sizeLeft = 0;  desc = (struct sctpChunkDesc *)((u_long)dg + sizeof(struct sctpHeader));  sizeOfDg -= sizeof(struct sctpHeader);  countInLoop = 0;  while(isSCTPControl(desc)){    if(desc->chunkID > 0x0e){      if(desc->chunkID == SCTP_RELIABLE_CNTL){	SCTPdebugPrint(m,"Processing control message type %s\n",		       controlMappings[0x10]);      }else if(desc->chunkID == SCTP_RELIABLE_CNTL_ACK){	SCTPdebugPrint(m,"Processing control message type %s\n",		       controlMappings[0x11]);      }else{	nameof = controlMappings[0x0f];	SCTPdebugPrint(m,"Processing control message type %s%d\n",		       nameof,desc->chunkID);      }    }else{      nameof = controlMappings[desc->chunkID];      SCTPdebugPrint(m,"Processing control message type %s\n",nameof);    }    SCTPdebugPrint(m,"Switching through the types for desc:%d\n",		   desc->chunkID);    if(sizeOfDg < ntohs(desc->chunkLength)){      /* impossible chunk size */      SCTPdebugPrint(m,"Chunk shows %d left, calculate only %d left\n",		     ntohs(desc->chunkLength),sizeOfDg);      *rest = NULL;      return(NULL);    }    countInLoop++;    SCTPdebugPrint(m,"Into chunk switch type %d count:%d\n",		   desc->chunkID,		   countInLoop);    switch (desc->chunkID){    default:      {	SCTPdebugPrint(m,"Chunk type %d unknown!!\n",ntohs(desc->chunkID));	/* setup a op error to carry back if needed */	if((desc->chunkID & 0x40) && (asoc != NULL)){	  struct sctpUnifiedOpError *list;	  char *x;	  int aloc,len;	  /* report as a error the unknown chunk type */	  len = ntohs(desc->chunkLength);	  if(asoc->opErr == NULL){	    aloc = ((((sizeof(struct sctpUnifiedOpError) + len) + 3) >> 2) << 2);	    asoc->opErr = w_calloc(m,1,aloc);	    list = (struct sctpUnifiedOpError *)asoc->opErr;	    x = (char *)((u_long)list + sizeof(struct sctpUnifiedOpError));	    list->uh.chunkID = SCTP_OPERATION_ERR;	    list->uh.chunkFlg = 0;	    list->uh.chunkLength = htons((sizeof(struct sctpUnifiedOpError) + len));	    list->c.cause = htons(SCTP_OP_ERROR_UNK_CHUNK);	    list->c.causeLen = htons(sizeof(struct sctpOpErrorCause) + len);	    memcpy(x,desc,len);	    asoc->opErrSiz = aloc;	    	  }else{	    int newport;	    char *newList;	    newport = ((((sizeof(struct sctpUnifiedOpError) + len) + 3) >> 2) << 2);	    aloc = newport + asoc->opErrSiz;	    newList = w_calloc(m,1,aloc);	    if(newList != NULL){	      memcpy(newList,asoc->opErr,asoc->opErrSiz);	      w_free(m,asoc->opErr);	      asoc->opErr = newList;	      list = (struct sctpUnifiedOpError *)(&asoc->opErr[asoc->opErrSiz]);	      x = (char *)((u_long)list + sizeof(struct sctpUnifiedOpError));	      list->uh.chunkID = SCTP_OPERATION_ERR;	      list->uh.chunkFlg = 0;	      list->uh.chunkLength = htons((sizeof(struct sctpUnifiedOpError) + len));	      list->c.cause = htons(SCTP_OP_ERROR_UNK_CHUNK);	      list->c.causeLen = htons(sizeof(struct sctpOpErrorCause) + len);	      memcpy(x,desc,len);	      asoc->opErrSiz += newport;	    }	  }	}	if((desc->chunkID & 0x80) == 0x00){	  /* abort procssing this packet */	  *sizeLeft = 0;	  return(asoc);	}      }      break;    case SCTP_COOKIE:      {	/* pull out cookie and unpack */	int cookieLen;	char *cookie;	SCTPdebugPrint(m,"A Cookie\n");	if(countInLoop > 1){	  /* error, cookie not first */	  SCTPsendAAbort(m,asoc,from,asoc->hisTag,			 0,0);	  *rest = NULL;	  return(NULL);	}	cookie = (char *)((u_long)desc + sizeof(*desc));	cookieLen = ntohs(desc->chunkLength) - sizeof(*desc);	asoc = SCTPunpackCookie(m,cookie,cookieLen,from,as,dg,toAddr);	if(asoc == NULL){	  /* bad cookie */	  *rest = NULL;	  return(NULL);	}	sawTheCookie = 1;	*netOn1 = asoc->lastNetRcvdFrom;	SCTPdebugPrint(m,"Cookie set fixes the lastrcv netnum %d\n",		       *netOn1);      }      break;    case SCTP_ECN_ECHO:      if(asoc != NULL){	struct sctpECN_echo *dt;	struct sctpCWR *xx;	int whichLan;	u_long TSN;	dt = (struct sctpECN_echo *)desc;	TSN = ntohl(dt->Lowest_TSN);	echoSeen = 1;	whichLan = 0;	if(compare_with_wrap(TSN,asoc->lastCWR_TSN, 0xffffffff)){	  /* new TSN complained about */	  /* setup a CWR to send */	  if(asoc->CWR == NULL){	    asoc->CWR = w_calloc(m,1,sizeof(struct sctpCWR));	  }	  if(asoc->CWR != NULL){	    xx = (struct sctpCWR *)asoc->CWR;	    xx->uh.chunkID = SCTP_ECN_CWR;	    xx->uh.chunkFlg = 0;	    xx->uh.chunkLength = htons(sizeof(struct sctpCWR));	    asoc->lastCWR_TSN = findLastSentTSN(m,asoc);	    xx->TSN_reduced_at = htonl(asoc->lastCWR_TSN);	  }else{	    /* still need another reduction */	    xx = (struct sctpCWR *)asoc->CWR;	    asoc->lastCWR_TSN = findLastSentTSN(m,asoc);	    xx->TSN_reduced_at = htonl(asoc->lastCWR_TSN);	  }	  /* Now do the congestion reduction called for */	  whichLan = SCTPwhichLanSentTo(m,asoc,TSN);	  	  asoc->nets[whichLan].ssthresh = asoc->nets[whichLan].cwnd / 2;	  if(asoc->nets[whichLan].ssthresh < (asoc->nets[whichLan].MTU*2))	    asoc->nets[whichLan].ssthresh = 2 * asoc->nets[whichLan].MTU;	  asoc->nets[whichLan].cwnd = asoc->nets[whichLan].ssthresh;		}      }      break;    case SCTP_ECN_CWR:      if(asoc != NULL){	struct sctpCWR *dt;	u_long TSN;	dt = (struct sctpCWR *)desc;	TSN = ntohl(dt->TSN_reduced_at);	if((compare_with_wrap(TSN,asoc->lastEcho_TSN, 0xffffffff))||	    (asoc->lastEcho_TSN == TSN)){	  /* ok this ack's my last ECN echo to him free and release */	  if(asoc->ECN_echo != NULL){	    w_free(m,asoc->ECN_echo);	    asoc->ECN_echo = NULL;	  }	}      }      break;    case SCTP_COOKIE_ACK:      SCTPdebugPrint(m,"A Cookie-Ack\n");      if(as != NULL){	SCTPdebugPrint(m,"state of asoc is %d: calculate RTO?\n",as->state);	if(asoc->overallErrorCount == 0){	  SCTPdebugPrint(m,"No errors calculate RTO\n");	  asoc->nets[asoc->lastNetRcvdFrom].RTO = calculateRTO(m,asoc,asoc->lastNetRcvdFrom,							       asoc->timeEnteringState.tv_sec,							       asoc->timeEnteringState.tv_nsec);	}	timerWork(m,asoc,SCTP_TIMER_STOP,SctpTimerTypeCookie,0);	if((as->state&SCTP_STATE_MASK) == SCTP_STATE_COOKIE_SENT){	  /* state change only needed when I am in right state */	  if(as->state & SCTP_STATE_SHUTDOWN_PEND){	    SCTPdebugPrint(m,"Change state to OPEN AND SHUTDOWN PENDING!\n");	    as->state = SCTP_STATE_OPEN | SCTP_STATE_SHUTDOWN_PEND;	  }else{	    SCTPdebugPrint(m,"Change state to OPEN\n");	    as->state = SCTP_STATE_OPEN;	  }	  (*m->getTime)(&asoc->timeEnteringState);	  SCTPupperLayerNotification(m,asoc,				     SCTP_NOTIFY_ASSOC_UP,asoc->numnets);	  /* bring up the PMTU raise timer */	  timerWork(m,asoc,SCTP_TIMER_START,SctpTimerTypePathMtuRaise,0);	  timerWork(m,as,SCTP_TIMER_START,SctpTimerTypeHeartbeat,0);	}	/* toss the cookie if present */	if(as->cookie != NULL){	  w_free(m,as->cookie);	  as->cookie = NULL;	}      }      break;    case SCTP_INITIATION:      SCTPdebugPrint(m,"A Init message\n");      if(countInLoop > 1){	/* must be first and only chunk ignore */	*rest = NULL;	return(NULL);      }      SCTPdebugPrint(m,"size check:%d?\n",sizeOfDg);      if(sizeOfDg < (sizeof(struct sctpUnifiedInit) - sizeof(struct sctpParamDesc))){	/* can't be a init to small */	return((struct SCTP_association *)NULL);      }      {	/* Check to see if there is something else besides	 * a INIT in the chunk.	 */	int szofchk;	szofchk = ((((int)(ntohs(desc->chunkLength)) + 3) >> 2) << 2);	/* we probably should compare to 0, but 3 does not hurt either,	 * since if the trailer is 3 bytes it can't be a chunk. 	 */	if((sizeOfDg-szofchk) > 3){	  *rest = NULL;	  return(NULL);	}      }      if(((struct sctpUnifiedInit *)desc)->initm.initTag == 0){	SCTPdebugPrint(m,"Tag of 0 gets an abort!\n");	SCTPsendAAbort(m,(struct SCTP_association *)NULL,		       from,		       ((struct sctpUnifiedInit *)desc)->initm.initTag,		       SCTP_OP_ERROR_INV_PARAM,1);    	return((struct SCTP_association *)NULL);      }      SCTPdebugPrint(m,"call handleInitiateIn\n");      SCTP_handleInitateIn(m,(struct sctpUnifiedInit *)desc,from,asoc,toAddr);      *rest = NULL;      return(NULL);      break;    case SCTP_INITIATION_ACK:      SCTPdebugPrint(m,"A Init-ACK message\n");      if(countInLoop > 1){	/* must be first and only chunk ignore */	*rest = NULL;	return(NULL);      }      if(sizeOfDg < (sizeof(struct sctpUnifiedInit)-sizeof(struct sctpParamDesc))){	/* can't be a init to small */	return((struct SCTP_association *)NULL);      }      if(asoc != NULL){	/* if the assoc exists and I have	 * a cookie, decrement it so when	 * I add below it will not get over 1	 */	if(asoc->cookie != NULL){	  (*gotCookie)--;	}      }      asoc = SCTP_handleInitateAck(m,(struct sctpUnifiedInit *)desc,from,asoc,dg);      SCTPdebugPrint(m,"Handle INIT-ACK returns %x\n",(u_int)asoc);      if(asoc != NULL){	if(asoc->cookie != NULL){	  (*gotCookie)++;	}      }      *rest = NULL;      return(asoc);      break;    case SCTP_SELECTIVE_ACK:      /* Handle the SACK from the peer */      asoc->pegs[SCTP_PEG_SACKS_SEEN]++;      SCTP_handleInboundSack(m,asoc,(struct sctpUnifiedSack *)desc,from);      break;    case SCTP_HEARTBEAT_REQUEST:      {	/* must reply with a HB-Ack */	if(asoc == NULL){	  printf("Can't find asoc\n");	  break;	} 	asoc->pegs[SCTP_HBR_RECV]++; 	SCTPSendHBResp(m,asoc,(struct sctpHBunified *)desc,from,netOn);      }    break;    case SCTP_HEARTBEAT_ACK:      {	/* got a response from our HB */	if(asoc == NULL){	  printf("Can't find asoc\n");	  break;	}	asoc->pegs[SCTP_HBA_RECV]++; 	SCTPProcHBResp(m,asoc,from,(struct sctpHBsender *)desc,netOn);      }    break;    case SCTP_ABORT_ASSOCIATION:      /* other end aborts us */      SCTPhandleAbort(m,desc,asoc,toAddr);      *rest = NULL;      return(NULL);      break;    case SCTP_SHUTDOWN:      /* other end is checking out */      SCTPhandleShutdown(m,desc,asoc,from,toAddr);      break;    case SCTP_SHUTDOWN_ACK:      SCTPhandleShutdownAck(m,desc,asoc,from,toAddr);      /* you must return null so that caller will       * bail since the association is now       * destroyed.       */      *rest = NULL;      return(NULL);      break;    case SCTP_SHUTDOWN_COMPLETE:      SCTPhandleShutdownComplete(m,desc,asoc);      *rest = NULL;      return(NULL);      break;    case SCTP_ASCONF:      SCTPhandleRelReq(m,desc,asoc,from);      break;    case SCTP_ASCONF_ACK:      SCTPhandleRelAck(m,desc,asoc);      break;      /* added for u-sctp */    case SCTP_FORWARD_CUM_TSN:      SCTPhandleFwdTsn(m,desc,asoc);      break;    case SCTP_OPERATION_ERR:      {	struct sctpUnifiedOpError *er;	struct sctpParamDesc *pdesc;	u_short oper, ptype;	int j;	er = (struct sctpUnifiedOpError *)desc;	oper = ntohs(er->c.cause);	SCTPdebugPrint(m,"Got a OPER ERROR:%d\n",oper);	if(oper == SCTP_OP_ERROR_STALE_COOKIE){	  /* Here we must zap the association back to	   * its initial state. We don't ask for more	   * time, but just hope for a better RTT.	   */	  SCTPdebugPrint(m,"Got a Stale cookie\n");	  if(handleOpErrStaleCookie(m,asoc,from)){	    *rest = NULL;	    return(NULL);	  }	}else if(oper == SCTP_OP_ERROR_INV_STRM){	  /* hmm, we have a fundamental problem here. We	   * think that we have N streams and are using them	   * our peer says we are using a invalid stream. It	   * either thinks there are N-? streams OR we have a	   * bug. 	   */	  SCTPdebugPrint(m,"Got a operational error of %d\n",oper);	  SCTPdebugPrintArry(m,(char *)dg,sizeOfDg);	  SCTPsendAAbort(m,asoc,from,asoc->hisTag,0,0);	  SCTPreportAllOutboundLost(m,asoc);	  SCTPupperLayerNotification(m,asoc,SCTP_NOTIFY_ASSOC_DOWN,				     (int)from);	  SCTPfreeAssociation(m,asoc);	  *rest = NULL;	  return(NULL);	}else if(oper == SCTP_OP_ERROR_UNK_CHUNK){	  struct sctpChunkDesc *unknownchk;	  unknownchk = (struct sctpChunkDesc *)((u_long)er + sizeof(struct sctpUnifiedOpError));	  SCTPdebugPrint(m,"Unknown chunk type %x\n",			 unknownchk->chunkID);	  if((unknownchk->chunkID == SCTP_RELIABLE_CNTL) ||	     (unknownchk->chunkID == SCTP_RELIABLE_CNTL_ACK)){	    /* peer does not recognize REL-REQ/REL-ACK turn off 	     * this feature.	     */	    timerWork(m,asoc,SCTP_TIMER_STOP,SctpTimerTypeRelReq,0);	    asoc->peerCanDoRelReq = 0;	    SCTPrelrequestFailAll(m,asoc);	    SCTPdebugPrint(m,"Turning off REL-REQ/REL-ACK now\n");	  }else{	    SCTPdebugPrint(m,"Got a operational error, unrecog chunk for chunk type %d?\n",			   unknownchk->chunkID);	  }	}else if(oper == SCTP_OP_ERROR_UNK_PARAM){	  pdesc = (struct sctpParamDesc *)((u_long)er + sizeof(struct sctpUnifiedOpError));	  ptype = ntohs(pdesc->paramType);	  SCTPdebugPrint(m,"Got an unrecog parameter ptype=0x%x\n", ptype);	  if(ptype == SCTP_UNRELIABLE_STRM) {	    SCTPdebugPrint(m,"Peer does not have u-sctp\n");	    /* we need to switch all our o-streams back to reliable */	    if(asoc->strmout) {	      SCTPdebugPrint(m,"set all o-stream back to reliable\n");	      for(j=0;j<asoc->preOpenStreams;j++) {		asoc->strmout[j].reliable = SCTP_STRM_RELIABLE; 	      }	    } else {	      SCTPdebugPrint(m,"Failed to switch our o-stream back to reliable!!!\n");	    }	  }	}else{	  SCTPdebugPrint(m,"Got a operational error of %d\n",oper);	}      }      break;    };    SCTPdebugPrint(m,"Out of switch\n");    /* update the pointer to the next chunk */    tmp = (struct sctpChunkDesc *)((((u_long)desc + ntohs(desc->chunkLength) + 3) >> 2) << 2);    SCTPdebugPrint(m,"Advancing up the datagram desc:%x chunksize:%d -> new %x\n",		   (u_long)desc,ntohs(desc->chunkLength),(u_long)tmp);    sizeOfDg -= ((u_long)tmp - (u_long)desc);    desc = tmp;    if(sizeOfDg <= 0){      SCTPdebugPrint(m,"Out of while\n");      break;    }  }  if(asoc != NULL){    if((echoSeen == 0) && (asoc->CWR != NULL)){      /* ok we can clear the ECN */      w_free(m,asoc->CWR);	      asoc->CWR = NULL;    }  }  /* update to the start of the rest of the data */  if(sizeOfDg <=0){    /* all consumed */    SCTPdebugPrint(m,"All consumed, none left\n");    *rest = NULL;  }else{    /* some left */    SCTPdebugPrint(m,"Got %d bytes left at:%x\n",sizeOfDg,(u_long)desc);    *sizeLeft = sizeOfDg;    *rest = desc;  }  return(asoc);}