/* SCTP reference Implementation Copyright (C) 2001 Cisco And MotorolaThis file is part of the SCTP reference ImplementationVersion:4.0.5$Header: /home/sourceTree/src/sctp/user/sctputil.h,v 1.49 2001/07/24 11:52:39 randall Exp $The SCTP reference implementation  is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published bythe Free Software Foundation; either version 2, or (at your option)any later version.the SCTP reference implementation  is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of                ************************MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See theGNU Library General Public License for more details.You should have received a copy of the GNU Library General Public Licensealong with GNU CC; see the file COPYING.  If not, write tothe Free Software Foundation, 59 Temple Place - Suite 330,Boston, MA 02111-1307, USA.  Please send any bug reports or fixes you make to one of the following emailaddresses:rrs@cisco.comkmorneau@cisco.comqxie1@email.mot.comAny bugs reported given to us we will try to fix... any fixes shared willbe incorperated into the next SCTP release.There are still LOTS of bugs in this code... I always run on the motto"it is a wonder any code ever works :)"*/#ifndef __sctputil_h__#define __sctputil_h__/* Uncoment this and one like it in sctp.h to get * all sorts of debug and kill performance (what little * there is in this impl)  *//*#ifndef DEBUG_ON*//*#define DEBUG_ON 1*//*#endif*/#ifdef	__cplusplusextern "C" {#endif#ifndef _WRAP_MEMORY_DEBUG  /* when Memory debugging is off just optimizeto malloc/calloc/free */#define w_malloc(m,s) malloc(s)#define w_calloc(m,s,n) calloc(s,n)#define w_free(m,f) free(f)#else/* When memory debug is on, we call the wrappers */void *w_malloc(struct SCTP *m,size_t size);void *w_calloc(struct SCTP *m,size_t size,size_t num);void w_free(struct SCTP *m,void *fre);#endifFILE *SCTPsafefopen(const char *name);voidSCTPinitNetStruct(struct SCTP *m,		  struct SCTP_association *asoc,		  struct SCTP_nets *netp,		  struct sockaddr *from);struct sctpChunkDesc *SCTPbuildASAck(struct SCTP *m,	       struct SCTP_association *asoc);intSCTPaddOutboundData(struct SCTP *m,		    struct SCTP_association *asoc,		    struct SCTP_stream_out *str,char *data,int siz,		    int sndOptions,int whichnet,int strNum,int payloadtype,		    int numOfRetrans);int  SCTPselectNextLan(struct SCTP *m,				struct SCTP_association *asoc);void SCTPupperLayerNotification(struct SCTP *m,				struct SCTP_association *asoc,				int eventToNotify,				int asocAddress);voidSCTPinitAAssociation(struct SCTP *m,struct SCTP_association *asoc);intsctpVerifyNoNewAddress(struct SCTP *m,		       struct SCTP_association *prevAsoc,		       struct sctpUnifiedInit *newInit,		       struct sockaddr *from		       );void SCTPreportAllOutboundLost(struct SCTP *m,				struct SCTP_association *asoc);void SCTPProcHBResp(struct SCTP *m,		    struct SCTP_association *asoc,		    struct sockaddr *from,		    struct sctpHBsender *uh,		    int netOn);char *SCTPupdateAllAddresses(struct SCTP *m,		       struct SCTP_association *asoc,		       struct sctpUnifiedInit *uh,		       struct sockaddr *from,		       int *deadflag,		       int *sizeOfOpErr,		       struct sctpParamDesc **prefPrim);void SCTPfillRandomStore(struct SCTP *m);inttimerWork(struct SCTP *m,	  struct SCTP_association *asoc,int cmd,int type,	  int network);void clearAllTimers(struct SCTP *m,		    struct SCTP_association *asoc);/* Build this up with the networks up */extern int SCTP_gatherAddresses(struct sockaddr ***localNets1,				/* Build this up with the netmasks */				struct sockaddr_in **maskList1,				/* Build this up with the broadcast addresses */				struct sockaddr_in **broadList1,				/* Fill in here the number of nets returned */				int *numberOfNets1,				/* Fillin the number you really allocate */				int *numberOfNetsAloc1,				/* Fill in here largest MTU value of all nets */				int *max_mtu,				/* Fill this in with array of MTU's for nets */				int **mtuList1,				/* Use this fd to scan the networks please */				int fd1,				/* if set I include the loopback */				int includeLoopBack				);extern int SCTP_doesAddressExist(struct SCTP *m, 				 struct sockaddr *addr,				 struct sockaddr_in *fillMask,				 struct sockaddr_in *fillBroad				 );struct SCTP_association *SCTPspecialFindAssociation(struct SCTP *m, struct sctpUnifiedInit *uh,			   struct sockaddr *from);struct SCTP_association *SCTPfindAssociation(struct SCTP *,struct sockaddr *addr,		    int *);struct SCTP_association *findAssociationForAsconf(struct SCTP *,struct sctpRelChunkDesc *,			 struct sockaddr *);struct SCTP_association *SCTPalocAssociation(struct SCTP *,					     struct sockaddr *addr,					     int locScope,					     int siteScope,					     int ipv4Scope);int SCTPfreeAssociation(struct SCTP *, struct SCTP_association *);u_long calculateRTO(struct SCTP *,		    struct SCTP_association *,		    int ,u_long , u_long);voidupdateRTOtime(struct SCTP *m,	      struct SCTP_association *asoc,	      int netOn);void initSctpHeader(struct sctpHeader *,u_long);void SCTPmakeIntoSock(unsigned char *,		      struct SCTP_association *,		      int);void SCTPmakeIntoLocalSock(unsigned char *,			   struct SCTP_association *,			   int);voidSCTPdebugPrint(struct SCTP *m,char *f,...);voidSCTPdebugPrintArry(struct SCTP *m,unsigned char *arry,int sz);voidSCTPdebugPrintAddress(struct SCTP *m, struct sockaddr *a);voidSCTPPrintAnAddress(struct sockaddr *a);struct cookieMessage *SCTPbuildACookie(struct SCTP *m,		 struct SCTP_association *pasoc,		 struct sctpUnifiedInit *uh,		 int *lenOfCook,		 char **report,		 int *repsz,		 struct sockaddr *to);voidSCTPupdateACookie(struct SCTP *m,		  struct SCTP_association *asoc,		  struct sctpUnifiedInit *msg,		  struct sockaddr *from);u_long SCTPselectInitialTSN(struct SCTP *m);struct SCTP_association *SCTPunpackCookie(struct SCTP *m,char *cookie,int len,		 struct sockaddr *from,		 struct SCTP_association *existing,		 struct sctpHeader *dg,		 struct sockaddr *toAddr		 );voidSCTPdisplayCongestionStats(struct SCTP *m,			   struct SCTP_association *asoc,			   char *msg);intSCTPisThereAGap(struct SCTP *m,		struct SCTP_association *asoc);intSCTPwhichLanSentTo(struct SCTP *m,		   struct SCTP_association *asoc,		   unsigned long TSN);u_longfindLastSentTSN(struct SCTP *m,		struct SCTP_association *asoc);intSCTPmakeAnyDNSQuery(struct SCTP *m,		    struct SCTP_association *asoc);intSCTPisToAddressInAssociation(struct SCTP *m,			     struct SCTP_association *asoc,			     struct sockaddr *to,			     int *adrIndx,			     int fromadddel);intSCTPisToAddressInEndpoint(struct SCTP *m,			  struct sockaddr *to,			  int *adrIndx);struct sctpParamDesc *findAParameter(struct SCTP *m,	       u_short ptype,	       u_char *paramarea,	       int sizeLimit,	       int *deadflag,char **report,int *sizeOfOpErr);#ifdef	__cplusplus}#endif#endif