/* SCTP reference Implementation Copyright (C) 2001 Cisco And MotorolaThis file is part of the SCTP reference ImplementationVersion:4.0.5$Header: /home/sourceTree/src/sctp/user/sctpsenders.c,v 1.58 2001/07/24 11:52:39 randall Exp $The SCTP reference implementation  is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published bythe Free Software Foundation; either version 2, or (at your option)any later version.the SCTP reference implementation  is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of                ************************MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See theGNU Library General Public License for more details.You should have received a copy of the GNU Library General Public Licensealong with GNU CC; see the file COPYING.  If not, write tothe Free Software Foundation, 59 Temple Place - Suite 330,Boston, MA 02111-1307, USA.  Please send any bug reports or fixes you make to one of the following emailaddresses:rrs@cisco.comkmorneau@cisco.comqxie1@email.mot.comAny bugs reported given to us we will try to fix... any fixes shared willbe incorperated into the next SCTP release.There are still LOTS of bugs in this code... I always run on the motto"it is a wonder any code ever works :)"*/#include <sctp.h>#include <sctputil.h>#include <sctpmtu.h>#include <dlist.h>#include <adler32.h>/* this contains the sending type functons * used by SCTP. Anything that sends on the * socket will be found here. The module that * actually sends to the socket has been moved * to the sctpmtu.c. */intSCTPsendShutdownAck(struct SCTP *m,		    struct SCTP_association *asoc,		    struct sockaddr *from,		    u_char type,		    u_long vtag,		    struct sockaddr *toAddr){  /* send a Shutdown ACK to the specifed address    * if I find the associations use its tag otherwise   * use 0.   */  struct sctpUnifiedSingleMsg mh;  int retVal;  if((type != SCTP_SHUTDOWN_ACK) &&      (type != SCTP_SHUTDOWN_COMPLETE)){    /* only shutdown-complete or shutdown-ack can be sent     * with this routine.     */    return(-2);  }  if(asoc != NULL){    initSctpHeader(&mh.mh,asoc->hisTag);      mh.uh.chunkFlg = 0;  }else if(type == SCTP_SHUTDOWN_COMPLETE){    initSctpHeader(&mh.mh,vtag);      mh.uh.chunkFlg = SCTP_HAD_NO_TCB;  }else{    /* can't send shutdown-ack with no vtag/no assoc */    return(-3);  }  mh.uh.chunkID = type;  mh.uh.chunkLength = htons(4);  SCTPdebugPrint(m,"--->Sending out a shutdown-Ack:\n");  SCTPdebugPrintArry(m,(char *)&mh,(sizeof(struct sctpHeader)));  SCTPdebugPrint(m,"!-->\n");  retVal = SCTPlsendto(m,asoc,(char *)&mh,sizeof(mh),0,from,0,0,toAddr,-1);  return(retVal);}intsendStreamError(struct SCTP *m,		struct SCTP_association *asoc,		int strmNum,		int netNum){  int calc,retVal;  unsigned char addrFmt[SCTP_ADDRMAX];  struct sctpUnifiedStreamError err;  SCTPmakeIntoSock(addrFmt,asoc,netNum);  initSctpHeader(&err.mh,0);    err.uh.chunkID = SCTP_OPERATION_ERR;  err.uh.chunkFlg = 0;  calc = sizeof(struct sctpUnifiedStreamError)  - sizeof(err.mh);  err.uh.chunkLength = htons(calc);  err.c.cause = SCTP_OP_ERROR_INV_STRM;  err.c.causeLen = ntohs(calc - sizeof(struct sctpChunkDesc));  err.strmNum = htons(strmNum);  err.reserved = 0;  retVal = SCTPlsendto(m,asoc,(char *)&err,sizeof(err),0,(struct sockaddr *)addrFmt,0,0,NULL,0);  return(retVal);}intsendForwardTSN(struct SCTP *m,	       struct SCTP_association *asoc,	       struct sockaddr *from){  int retVal, calc;  struct sctpUnifiedForwardTSN ftsn;  initSctpHeader(&ftsn.mh, asoc->hisTag);  ftsn.ft.uh.chunkID = SCTP_FORWARD_CUM_TSN;  ftsn.ft.uh.chunkFlg = 0;  calc = sizeof(struct sctpUnifiedForwardTSN)  - sizeof(ftsn.mh);  ftsn.ft.uh.chunkLength = htons(calc);  ftsn.ft.newCumulativeTSN = htonl(asoc->advancedPeerAckPoint);  SCTPdebugPrint(m,"--->Sending out a FwdTSN:\n");  SCTPdebugPrintArry(m, (char *)&ftsn, sizeof(ftsn));  SCTPdebugPrint(m,"!-->\n");  SCTPdebugPrintAddress(m,from);  retVal = SCTPlsendto(m,asoc,(char *)&ftsn, sizeof(ftsn),0,from,0,0,NULL,-1);  return(retVal);}voidSCTPsendCookieAck(struct SCTP *m,		  struct SCTP_association *asoc,		  struct sockaddr *from){  /* send a cookie-Ack to the to address */  struct sctpUnifiedSingleMsg mh;  int retVal;  initSctpHeader(&mh.mh,asoc->hisTag);    mh.uh.chunkID = SCTP_COOKIE_ACK;  mh.uh.chunkFlg = 0;  mh.uh.chunkLength = htons(4);  SCTPdebugPrint(m,"--->Sending out a send cookie-ack :\n");  SCTPdebugPrintArry(m,(char *)&mh,sizeof(mh));  SCTPdebugPrint(m,"!-->\n");  SCTPdebugPrintAddress(m,from);  retVal = SCTPlsendto(m,asoc,(char *)&mh,sizeof(mh),0,from,0,0,NULL,0);  SCTPdebugPrint(m,"send returns %d\n",retVal);}voidSCTPsendStaleCookie(struct SCTP *m,		    u_long tag,		    struct sockaddr *from,int staleby){  /* send a stale cookie operational error    * to the address passing the stalenss measure   * specified in staleby   */  struct staleCookieMsg msg;  int retVal;  initSctpHeader(&msg.mh,tag);    msg.uh.chunkID = SCTP_OPERATION_ERR;  msg.uh.chunkFlg = 0;  msg.uh.chunkLength = htons(12);  msg.c.cause = htons(SCTP_OP_ERROR_STALE_COOKIE);  msg.c.causeLen = htons(8);  msg.moretime = htonl(staleby);  SCTPdebugPrint(m,"--->Sending out a STALE COOKIE ERROR :\n");  SCTPdebugPrintArry(m,(char *)&msg,sizeof(msg));  SCTPdebugPrint(m,"!-->\n");  SCTPdebugPrintAddress(m,from);  retVal = SCTPlsendto(m,(struct SCTP_association *)NULL,		       (char *)&msg,sizeof(msg),0,from,0,0,NULL,0);  SCTPdebugPrint(m,"send returns %d\n",retVal);}intSCTPselectHBDest(struct SCTP *m,		 struct SCTP_association *asoc,		 struct timespec now){  /* This guy should select the next network to   * heartbeat on. It should find the network that has the    * oldest time of last sent to.    */  struct timespec oldest,limit;  int i,indx;  limit = now;  limit.tv_sec -= m->baseTimeoutSecs[SCTP_TIMER_HEARTBEAT];  limit.tv_nsec -= m->baseTimeoutNSecs[SCTP_TIMER_HEARTBEAT];  if(limit.tv_nsec < 0){    limit.tv_sec--;    limit.tv_nsec = 0;  }  indx = 0;  oldest = asoc->nets[0].lastSentTime;  for(i=1;i<asoc->numnets;i++){    if(asoc->nets[i].ina == NULL){      /* skip a null address from consideration */      SCTPdebugPrint(m,"WARNING: Null address for net %d\n",		     i);      continue;    }    if(asoc->nets[i].lastSentTime.tv_sec == 0){      SCTPdebugPrint(m,"Found net %d never sent to %d sending\n",		     i,asoc->nets[i].lastSentTime);      oldest.tv_sec = 0;      indx = i;      break;    }    if((oldest.tv_sec > asoc->nets[i].lastSentTime.tv_sec) ||       ((oldest.tv_sec == asoc->nets[i].lastSentTime.tv_sec) &&	(oldest.tv_nsec > asoc->nets[i].lastSentTime.tv_nsec))){      /* Here we see that this network sent older than the oldest */       if(asoc->nets[i].intfRotationState & SCTP_ADDR_NOHB){	/* is this within limit with no HB set? */	if((asoc->nets[i].lastSentTime.tv_sec < limit.tv_sec) ||	   ((asoc->nets[i].lastSentTime.tv_sec == limit.tv_sec) &&	    (asoc->nets[i].lastSentTime.tv_nsec < limit.tv_nsec))){	  /* Our last sent to time is before the limit and HB is turned off */	  /* mark it has sent to and decay it, even though nothing	   * was sent to this address	   */	  asoc->nets[i].lastSentTime = now;	  asoc->nets[i].cwnd >>= 1;	  if(asoc->nets[i].cwnd < (asoc->nets[i].MTU<<1)){	    asoc->nets[i].cwnd = (asoc->nets[i].MTU<<1);	  }	}      }else{	/* OK, This guy is older since it is smaller than the	 * oldest. The Bigger the number in sec/nsec the more	 * current the time. Smaller numbers are back further in time.	 */	SCTPdebugPrint(m,"new oldest set to %d\n",i);	oldest = asoc->nets[i].lastSentTime;	indx = i;      }    }  }  if(oldest.tv_sec == 0){    /* never RTO'd or sent on this guy */    SCTPdebugPrint(m,"Return index %d from 0\n",indx);    return(indx);  }  if((oldest.tv_sec < limit.tv_sec) ||     ((oldest.tv_sec == limit.tv_sec) &&      (oldest.tv_nsec < limit.tv_nsec))){    /* ok, this guy is older than the HB interval */    SCTPdebugPrint(m,"Return index %d in limit\n",indx);    return(indx);  }  /* if we reach here we have sent recently to   * all destinations.   */  return(-1);}intSCTPSendHBReq(struct SCTP *m,	      struct SCTP_association *asoc,	      int whichOne){  /* this module sends a HB request to the   * association, using the above selection   * routine to find the to address to   * send it at. This version only sends one   * HB per interval and tracks it accordingly.   * The destination is present so this could   * be expanded. Since we track only one HB out   * at a time we use the realySentHB flag so that   * we don't count against someone if we don't send   * it, since it could be all destinations were   * busy.   */  int whichLan,retVal;  struct timespec now;  struct sendOut{    struct sctpHeader mh;    struct sctpHBsender hb;  }msg;  SCTPdebugPrint(m,"SEND A HB\n");  if(asoc != NULL){    initSctpHeader(&msg.mh,asoc->hisTag);    }else{    SCTPdebugPrint(m,"no tag forget it\n");    return(-1);  }  /* fill in header of chunk */  msg.hb.hdr.chunkID = SCTP_HEARTBEAT_REQUEST;  msg.hb.hdr.chunkFlg = 0;   msg.hb.hdr.chunkLength = htons(sizeof( struct sctpHBsender));    msg.hb.hb.paramType = htons(HEART_BEAT_PARAM);  msg.hb.hb.paramLength = htons(sizeof(struct sctpHBsender) -				sizeof(struct sctpChunkDesc));  (*m->getTime)(&now);  msg.hb.rtt.time_value_1 = now.tv_sec;  msg.hb.rtt.time_value_2 = now.tv_nsec;  asoc->reallySentHB = 0;  if((whichOne < 0) || (whichOne >= asoc->numnets)){    whichLan = SCTPselectHBDest(m,asoc,now);    msg.hb.userreq = 0;  }else{    msg.hb.userreq = 1;    whichLan = whichOne;  }  SCTPdebugPrint(m,"ok, lets see where to send to %d\n",whichLan);  if(whichLan < 0){    /* can't pick one since all have been active */    return(-1);  }  SCTPmakeIntoSock(msg.hb.addrFmt,asoc,whichLan);  SCTPdebugPrint(m,"--->Sending out a RTT request:\n");  SCTPdebugPrintArry(m,(char *)&msg,sizeof(msg));  SCTPdebugPrint(m,"!-->\n");  SCTPdebugPrintAddress(m,(struct sockaddr *)msg.hb.addrFmt);  retVal = SCTPlsendto(m,asoc,(char *)&msg,sizeof(msg),0,		       (struct sockaddr *)msg.hb.addrFmt,0,0,NULL,whichLan);  asoc->nets[whichLan].lastSentTime = now;  if(retVal > 0){    asoc->reallySentHB = 1;    asoc->lastNetSentTo = whichLan;  }else{    /* Problem with sending to an address */    asoc->nets[whichLan].errorCount++;  }  return(retVal);}intSCTPSendHBResp(struct SCTP *m,	       struct SCTP_association *asoc,	       struct sctpHBunified *uh,	       struct sockaddr *from,	       int netOn){  /* This guy will copy back out the HB   * and change it to a response, sending   * it back from where it came from.   */  int retVal;  char buf[8192];  int sz;  struct sendOut{    struct sctpHeader mh;    struct sctpHBunified rtu;  }*msg;  memset(buf,0,sizeof(buf));  msg = (struct sendOut *)buf;  if(asoc != NULL){    initSctpHeader(&msg->mh,asoc->hisTag);    }else{    initSctpHeader(&msg->mh,0);    }  sz = htons(uh->hdr.chunkLength);  /* copy back the HB I got and change to ACK */  memcpy((char *)&msg->rtu,(char *)uh,sz);  msg->rtu.hdr.chunkID = SCTP_HEARTBEAT_ACK;  msg->rtu.hdr.chunkFlg = 0;   SCTPdebugPrint(m,"--->Sending out a RTT response:\n");  SCTPdebugPrintArry(m,(char *)msg,(sz + sizeof(struct sctpHeader)));  SCTPdebugPrint(m,"!-->\n");  SCTPdebugPrintAddress(m,from);  retVal = SCTPlsendto(m,asoc,(char *)msg,		       (sz + sizeof(struct sctpHeader)),0,from,0,0,NULL,-1);  return(retVal);}intSCTPsendAShutdown(struct SCTP *m,struct SCTP_association *asoc, int retran){  /* send a Shutdown to the specifed   * association.   */  struct sendOut{    struct sctpHeader mh;    struct sctpUnifiedShutdown uh;  }msg;  unsigned char addrFmt[SCTP_ADDRMAX];  int retVal,whichLan;  if(asoc != NULL){    initSctpHeader(&msg.mh,asoc->hisTag);    }else{    initSctpHeader(&msg.mh,0);    }  msg.uh.uh.chunkID = SCTP_SHUTDOWN;  msg.uh.uh.chunkFlg = 0;   msg.uh.uh.chunkLength = htons(sizeof(struct sctpUnifiedShutdown));  msg.uh.shut.TSN_Seen = (u_long)htonl(asoc->mappingArrayHighestTSN);  if(retran)    whichLan = SCTPselectNextLan(m,asoc);  else    whichLan = asoc->primary_destination;  SCTPmakeIntoSock(addrFmt,asoc,whichLan);  SCTPdebugPrint(m,"--->Sending out a sendAShutdown :\n");  SCTPdebugPrintArry(m,(char *)&msg,sizeof(msg));  SCTPdebugPrint(m,"!-->\n");  SCTPdebugPrintAddress(m,(struct sockaddr *)addrFmt);    retVal = SCTPlsendto(m,asoc,(char *)&msg,sizeof(msg),0,(struct sockaddr *)addrFmt,0,0,NULL,whichLan);  if(retVal > 0){    asoc->lastNetSentTo = whichLan;  }  return(retVal);}intSCTPsendAAbort(struct SCTP *m,	       struct SCTP_association *asoc,	       struct sockaddr *to, u_long tag, int errCode,	       int useTaganyway){  /* send a abort to the to address */  char buff[SCTP_MAX_READBUFFER];  struct sctpUnifiedAbortHeavy  *mh;  int retVal,len;  SCTPdebugPrint(m,"Going to send an abort\n");  memset(buff,0,SCTP_MAX_READBUFFER);  mh = (struct sctpUnifiedAbortHeavy  *)buff;  if(asoc == NULL){    initSctpHeader(&mh->mh,tag);      mh->uh.chunkFlg = SCTP_HAD_NO_TCB;  }else{    if(useTaganyway)      initSctpHeader(&mh->mh,tag);    else      initSctpHeader(&mh->mh,asoc->hisTag);    mh->uh.chunkFlg = 0;  }  mh->uh.chunkID = SCTP_ABORT_ASSOCIATION;  mh->uh.chunkLength = htons(4);  if((errCode == SCTP_OP_ERROR_NO_RESOURCE) ||     (errCode == SCTP_OP_ERROR_INV_PARAM) ||     (errCode == SCTP_OP_ERROR_COOKIE_SHUT)){    /* we only support the ones with empty     * causes here.     */    len = sizeof(*mh);    mh->causeCode = htons(errCode);    mh->causeLen = htons(4);    mh->uh.chunkLength = htons(8);  }else{    len = sizeof(struct sctpUnifiedAbortLight);  }  /* now do we have anything from the opErr side to add? */  if(asoc != NULL){    if(asoc->opErr != NULL){      struct sctpChunkDesc *pd;      int llen;      char *copyto;      llen = len + (asoc->opErrSiz-sizeof(struct sctpChunkDesc));      mh->uh.chunkLength = htons(llen);      copyto = (char *)((u_long)mh + len);      pd = (struct sctpChunkDesc *)asoc->opErr;      /* now advance past chunk descriptor */      pd++;      memcpy(copyto,(char *)pd,(asoc->opErrSiz - sizeof(struct sctpChunkDesc)));      /* now free it all up */      w_free(m,asoc->opErr);      asoc->opErr = NULL;      asoc->opErrSiz = 0;      len = llen;    }  }  SCTPdebugPrint(m,"--->Sending out a sendAAbort %d:\n",len);  SCTPdebugPrintArry(m,(char *)mh,len);  SCTPdebugPrint(m,"!-->\n");  SCTPdebugPrintAddress(m,to);    retVal = SCTPlsendto(m,asoc,(char *)mh,len,0,to,0,0,NULL,0);  return(retVal);}intSCTPsendInitiate(struct SCTP *m,struct SCTP_association *asoc){  /* This function will send a INIT.   * INIT-ACK is now send by SCTPsendInitateAck() below...   * association address.    */  int retVal,i;  unsigned char addrFmt[SCTP_ADDRMAX];  struct sctpParamDesc *p;  char buff[SCTP_MAX_READBUFFER];  int dataSize;  struct sctpSendableInit *msg;  char *sendMsg;  struct sctpV4IpAddress *addrs;  struct sctpV6IpAddress *addrs6;  int whichLan,adrSizes;  memset(buff,0,SCTP_MAX_READBUFFER);  msg = (struct sctpSendableInit *)buff;  /* hisTag will be 0 if this is a init */  initSctpHeader(&msg->mh,0);  adrSizes = 0;  /* set in the INIT */  msg->msg.uh.chunkID = SCTP_INITIATION;  /* place in my tag */  msg->msg.uh.chunkFlg = 0;  msg->msg.initm.initTag = htonl(asoc->curTag);  /* set up some of the credits. */  msg->msg.initm.rcvWindowCredit = htonl(m->maxWindow);  msg->msg.initm.NumPreopenStreams = htons(asoc->preOpenStreams);  msg->msg.initm.MaxInboundStreams = htons(MAX_SCTP_STREAMS);  msg->msg.initm.initialTSN = htonl(asoc->initSeqNumber);  SCTPdebugPrint(m,"-------NOW building in params------\n");  /* build in the addresses for all the networks I have   * bound.   */  addrs = (struct sctpV4IpAddress *)((u_long)msg + 				     sizeof(struct sctpSendableInit));  SCTPdebugPrint(m,"Addr is set to %x\n",(u_long)addrs);  for(i=0;i<asoc->numberOfNets;i++){    if(asoc->localNets[i]->sa_family == AF_INET){      struct sockaddr_in *a;      SCTPdebugPrint(m,"placing IPV4 type at address %x\n",		     (u_long)&addrs->p.paramType);      addrs->p.paramType = htons(SCTP_IPV4_PARAM_TYPE);      SCTPdebugPrint(m,"placing length at address %x\n",		     (u_long)&addrs->p.paramLength);      addrs->p.paramLength = htons(sizeof(struct sctpV4IpAddress));      SCTPdebugPrint(m,"placing address at address %x\n",		     (u_long)&addrs->ipAddress);      a = (struct sockaddr_in *)asoc->localNets[i];      addrs->ipAddress = a->sin_addr.s_addr;      addrs++;      adrSizes += sizeof(struct sctpV4IpAddress);    }else if((asoc->localNets[i]->sa_family == AF_INET6) &&	     (!m->disableV6)){      struct sockaddr_in6 *a6;      addrs6 = (struct sctpV6IpAddress *)addrs;      a6 = (struct sockaddr_in6 *)asoc->localNets[i];      if(IN6_IS_ADDR_LINKLOCAL(&a6->sin6_addr)){	      /* don't tell link local please */	      SCTPdebugPrint(m,"Skip IPV6 LL address\n");	      continue;      }      SCTPdebugPrint(m,"placing IPV6 type at address %x\n",		     (u_long)&addrs6->p.paramType);      addrs6->p.paramType = htons(SCTP_IPV6_PARAM_TYPE);      SCTPdebugPrint(m,"placing length at address %x\n",		     (u_long)&addrs6->p.paramLength);      addrs6->p.paramLength = htons(sizeof(struct sctpV6IpAddress));      SCTPdebugPrint(m,"placing address at address %x\n",		     (u_long)&addrs6->ipAddress);      memcpy(addrs6->ipAddress,a6->sin6_addr.s6_addr,	  sizeof(addrs6->ipAddress));      addrs6++;      addrs = (struct sctpV4IpAddress *)addrs6;      adrSizes += sizeof(struct sctpV6IpAddress);    }else{      SCTPdebugPrint(m,"Skipping address %d family unknown\n",		     asoc->localNets[i]->sa_family);    }  }  /* add on ECN parameter since we are ECN capable */  SCTPdebugPrint(m,"Add in ECN flags TLV\n");  p = (struct sctpParamDesc *)addrs;  p->paramType = htons(SCTP_ECN_I_CAN_DO_ECN);  p->paramLength = htons(sizeof(struct sctpParamDesc));  p++;  /* set the size in place */  dataSize = (sizeof(struct sctpSendableInit) +	      sizeof(struct sctpParamDesc) +	      (adrSizes));  /* we always add a u-sctp parameter here */  {    struct sctpParamDesc *upd;    struct sctpUnrelStrmRange *sr;    int k, ulen, sp, ep;    SCTPdebugPrint(m,"Add in Unreliable Stream Param\n");    upd = p;    upd->paramType = htons(SCTP_UNRELIABLE_STRM);    /* length will be set later */    p++;    dataSize += sizeof(struct sctpParamDesc);    k = 0;    sr = (struct sctpUnrelStrmRange *)(p);    for(i=0; i<MAX_UNRELSTREAM_SETS*2; i+=2) {      sp = m->unrelStreamSets[i]; /* start */      ep = m->unrelStreamSets[i+1]; /* end */      if(sp < 0 || ep <0) break; /* done */      SCTPdebugPrint(m,"u-strm start:%d - end:%d\n", sp, ep);      sr->UnrelStrmStart = htons(sp);      sr->UnrelStrmEnd = htons(ep);      sr++;      k++;    }    ulen = k * sizeof(struct sctpUnrelStrmRange);    upd->paramLength = htons(sizeof(struct sctpParamDesc) + ulen);    p = (struct sctpParamDesc *)((u_long)p + ulen);    dataSize += ulen;  }  /* Now do we need to have a list of addresses supported */  if(asoc->restrictAddresses){    /* this is the INIT case with a request to     * set in the list of addresses I cant handle.     */    unsigned short *addmore;    p->paramType = htons(SCTP_RESTRICT_ADDR_TO);    p->paramLength = htons((sizeof(struct sctpParamDesc)) + 4);    p++;    addmore = (unsigned short *)p;    /* we only specify IPV4 addresses, when we extend to     * include IPV6 this will need to enhanced and the     * size will need to be increased by 2      */    *addmore = htons(SCTP_IPV4_PARAM_TYPE);    /* null out where we would put the IPV6 address */    addmore++;    *addmore = htons(SCTP_IPV6_PARAM_TYPE);    addmore++;    dataSize += (sizeof(struct sctpParamDesc) + 4);    dataSize += 3;    dataSize >>= 2;    dataSize <<= 2;    /* now set in for any additional parameter added next */    p = (struct sctpParamDesc *)addmore;  }  /* Additional parameters can be tacked in here using *p has   * where to put them and of course increasing dataSize as they   * go.   */  if(m->preferedRemPrimary != NULL){    SCTPdebugPrint(m,"Add in request for peer primary to be set to ds:%d\n",		   dataSize);    SCTPdebugPrintAddress(m,m->preferedRemPrimary);    p->paramType = htons(SCTP_SETADDRESS_PRIMARY);    if(m->preferedRemPrimary->sa_family == AF_INET){      p->paramLength = htons((sizeof(struct sctpParamDesc) +			      sizeof(struct sctpV4IpAddress)));    }else if(m->preferedRemPrimary->sa_family == AF_INET6){      p->paramLength = htons((sizeof(struct sctpParamDesc) +			      sizeof(struct sctpV6IpAddress)));    }    p++;    if(m->preferedRemPrimary->sa_family == AF_INET){      struct sockaddr_in *a;      addrs = (struct sctpV4IpAddress *)p;      addrs->p.paramType = htons(SCTP_IPV4_PARAM_TYPE);      addrs->p.paramLength = htons(sizeof(struct sctpV4IpAddress));      a = (struct sockaddr_in *)m->preferedRemPrimary;      addrs->ipAddress = a->sin_addr.s_addr;      addrs++;      p = (struct sctpParamDesc *)addrs;      dataSize += (sizeof(struct sctpParamDesc) + sizeof(struct sctpV4IpAddress));      dataSize += 3;      dataSize >>= 2;      dataSize <<= 2;      SCTPdebugPrint(m,"IPv4 primary set grows INIT to %d bytes\n",		     dataSize);    }else if(m->preferedRemPrimary->sa_family == AF_INET6){      struct sockaddr_in6 *a6;      addrs6 = (struct sctpV6IpAddress *)p;      a6 = (struct sockaddr_in6 *)m->preferedRemPrimary;      addrs6->p.paramType = htons(SCTP_IPV6_PARAM_TYPE);      addrs6->p.paramLength = htons(sizeof(struct sctpV6IpAddress));      memcpy(addrs6->ipAddress,a6->sin6_addr.s6_addr,	  sizeof(addrs6->ipAddress));      addrs6++;      dataSize += (sizeof(struct sctpParamDesc) + sizeof(struct sctpV6IpAddress));      dataSize += 3;      dataSize >>= 2;      dataSize <<= 2;      p = (struct sctpParamDesc *)addrs6;      SCTPdebugPrint(m,"IPv6 primary set grows INIT to %d bytes\n",		     dataSize);    }  }  msg->msg.uh.chunkLength = htons((dataSize-sizeof(struct sctpHeader)));  SCTPdebugPrint(m,"Ok data size for init is %d\n",dataSize);  /* Build the socket address based on where this   * came from. There is actually a bug here since   * lastNetRcvdFrom has not been reset   * correctly if my net list is expanded. It is   * rather harmless but you should fix this if   * you are converting this to use internally.   */    whichLan = asoc->lastNetRcvdFrom;  SCTPdebugPrint(m,"last rcvd from %d\n",whichLan);  SCTPmakeIntoSock(addrFmt,asoc,whichLan);  sendMsg = (char *)msg;  SCTPdebugPrint(m,"--->Sending out a INIT message\n");  SCTPdebugPrintArry(m,sendMsg,dataSize);  SCTPdebugPrint(m,"!-->\n");  SCTPdebugPrintAddress(m,(struct sockaddr *)addrFmt);  retVal = SCTPlsendto(m,asoc,sendMsg,dataSize,0,(struct sockaddr *)addrFmt,0,0,NULL,whichLan);  if(retVal >= 0){    retVal = 1;    asoc->lastNetSentTo = whichLan;  }  return(retVal);}intSCTPsendOpErr(struct SCTP *m,struct sockaddr *to,char *operr,int sz,u_long tag){  int retVal;  int sndsz;  struct sctpSendableInit *msg;  struct sctpHeader *hdr;  char buff[SCTP_MAX_READBUFFER];  retVal = 0;  sndsz = (((sz+sizeof(struct sctpHeader)+3) >> 2) << 2);  hdr = (struct sctpHeader *)buff;  msg = (struct sctpSendableInit *)buff;  memset(buff,0,sndsz);  initSctpHeader(hdr,tag);  hdr++;  /* copy in the op error */  memcpy((char *)hdr,operr,sz);  SCTPdebugPrint(m,"!-->\n");  SCTPdebugPrint(m,"--->Sending out a OPERATIONAL-ERROR\n");    retVal = SCTPlsendto(m,(struct SCTP_association *)NULL,buff,sndsz,0,to,0,0,NULL,0);  return(retVal);}intSCTPsendInitiateAck(struct SCTP *m,struct sockaddr *from,		    struct cookieMessage *cookie,int cookieLength,		    u_long tag,		    char *operr,		    int opersz,		    struct sockaddr *toAddr){  /* This function will send a INIT-ACK to the   * sender of the INIT.   */  int retVal,i;  char buff[SCTP_MAX_READBUFFER];  int dataSize;  u_short tsize;  struct sctpSendableInit *msg;  char *sendMsg;  struct sctpParamDesc *param;  struct sctpV4IpAddress *addrs;  struct sctpV6IpAddress *addrs6;  struct sockaddr_in6 *a6;  struct sockaddr_in *a;  int addrSize,tmp;  addrSize = 0;    /* round cookie size to 4 byte value for calc */  tmp = cookieLength;  tmp += 3;  tmp >>= 2;    tmp <<= 2;  for(i=0;i<m->numberOfNets;i++){    if(m->localNets[i]->sa_family == AF_INET){      a = (struct sockaddr_in *)m->localNets[i];      if((cookie->ipv4Scope == 0) && (IN4_ISPRIVATE_ADDRESS(&a->sin_addr))){	continue;      }      addrSize += sizeof(struct sctpV4IpAddress);    }else if(m->localNets[i]->sa_family == AF_INET6){      if(m->disableV6)	continue;      a6 = (struct sockaddr_in6 *)m->localNets[i];      if(IN6_IS_ADDR_LINKLOCAL(&a6->sin6_addr)){	      SCTPdebugPrint(m,"Skipping ipv6 ll address\n");	continue;      }else if((cookie->siteScope == 0) && (IN6_IS_ADDR_SITELOCAL(&a6->sin6_addr))){	continue;      }      addrSize += sizeof(struct sctpV6IpAddress);    }  }  dataSize = (sizeof(struct sctpSendableInit) +	      (addrSize) +	      sizeof(struct sctpParamDesc) +	      sizeof(struct sctpParamDesc) + tmp + 	      opersz  	      );  if(m->preferedRemPrimary != NULL){    /* need space for prefered primary */    if(m->preferedRemPrimary->sa_family == AF_INET)      dataSize += (sizeof(struct sctpParamDesc) + sizeof(struct sctpV4IpAddress));    else if(m->preferedRemPrimary->sa_family == AF_INET6)      dataSize += (sizeof(struct sctpParamDesc) + sizeof(struct sctpV6IpAddress));  }  SCTPdebugPrint(m,"Total sizes to send is %d addr:%d cookie:%d \n",		 dataSize,		 addrSize,cookieLength);  /* Round up to a even word boundary */  /*    tsize = htons((dataSize-sizeof(struct sctpHeader)));    dataSize += 3;    dataSize >>= 2;    dataSize <<= 2;  */  memset(buff,0,dataSize);  msg = (struct sctpSendableInit *)buff;  initSctpHeader(&msg->mh,tag);  /*  msg->msg.uh.chunkLength = tsize; */  /* Add INIT-ACK chuck id */  msg->msg.uh.chunkID = SCTP_INITIATION_ACK;  /* place in my tag */  msg->msg.uh.chunkFlg = 0;  memcpy(&msg->msg.initm,&cookie->initAckISent,sizeof(struct sctpInitiation));  /* tell peer I can DO ECN, if he has the same I enable it */  param = (struct sctpParamDesc *)((u_long)msg + sizeof(struct sctpSendableInit));  param->paramType = htons(SCTP_ECN_I_CAN_DO_ECN);  param->paramLength = htons(sizeof(struct sctpParamDesc));  param++;  /* build in the addresses for all the networks I have   * bound.   */  addrs = (struct sctpV4IpAddress *)(param);  SCTPdebugPrint(m,"Addr is set to %x\n",(u_long)addrs);  for(i=0;i<m->numberOfNets;i++){    struct sockaddr_in *min;    a = (struct sockaddr_in *)m->localNets[i];    if(m->localNets[i]->sa_family == AF_INET){      if((cookie->ipv4Scope == 0) && (IN4_ISPRIVATE_ADDRESS(&a->sin_addr))){	continue;      }      min = (struct sockaddr_in *)m->localNets[i];      addrs->p.paramType = htons(SCTP_IPV4_PARAM_TYPE);      addrs->p.paramLength = htons(sizeof(struct sctpV4IpAddress));      addrs->ipAddress = min->sin_addr.s_addr;      addrs++;    }else if(m->localNets[i]->sa_family == AF_INET6){      if(m->disableV6)	continue;      addrs6 = (struct sctpV6IpAddress *)addrs;      a6 = (struct sockaddr_in6 *)m->localNets[i];      if(IN6_IS_ADDR_LINKLOCAL(&a6->sin6_addr)){	continue;      }else if((cookie->siteScope == 0) && (IN6_IS_ADDR_SITELOCAL(&a6->sin6_addr))){	continue;      }      addrs->p.paramType = htons(SCTP_IPV6_PARAM_TYPE);      addrs->p.paramLength = htons(sizeof(struct sctpV6IpAddress));      memcpy(addrs6->ipAddress,a6->sin6_addr.s6_addr,sizeof(addrs6->ipAddress));      addrs6++;      addrs = (struct sctpV4IpAddress *)addrs6;    }  }  /* add the prefered address parameter */  param = (struct sctpParamDesc *)addrs;  if(m->preferedRemPrimary != NULL){    SCTPdebugPrint(m,"Add in request for peer primary to be set to\n");    SCTPdebugPrintAddress(m,m->preferedRemPrimary);    param->paramType = htons(SCTP_SETADDRESS_PRIMARY);    if(m->preferedRemPrimary->sa_family == AF_INET){      param->paramLength = htons((sizeof(struct sctpParamDesc) +			      sizeof(struct sctpV4IpAddress)));    }else if(m->preferedRemPrimary->sa_family == AF_INET6){      param->paramLength = htons((sizeof(struct sctpParamDesc) +			      sizeof(struct sctpV6IpAddress)));    }    param++;    if(m->preferedRemPrimary->sa_family == AF_INET){      struct sockaddr_in *a;      addrs = (struct sctpV4IpAddress *)param;      addrs->p.paramType = htons(SCTP_IPV4_PARAM_TYPE);      addrs->p.paramLength = htons(sizeof(struct sctpV4IpAddress));      a = (struct sockaddr_in *)m->preferedRemPrimary;      addrs->ipAddress = a->sin_addr.s_addr;      addrs++;    }else if(m->preferedRemPrimary->sa_family == AF_INET6){      struct sockaddr_in6 *a6;      addrs6 = (struct sctpV6IpAddress *)param;      a6 = (struct sockaddr_in6 *)m->preferedRemPrimary;      addrs6->p.paramType = htons(SCTP_IPV6_PARAM_TYPE);      addrs6->p.paramLength = htons(sizeof(struct sctpV6IpAddress));      memcpy(addrs6->ipAddress,a6->sin6_addr.s6_addr,	  sizeof(addrs6->ipAddress));      addrs6++;      addrs = (struct sctpV4IpAddress *)addrs6;    }  }  /* add the cookie */  param = (struct sctpParamDesc *)addrs;  param->paramType = htons(SCTP_RESPONDER_COOKIE);  param->paramLength = htons((cookieLength + (sizeof(struct sctpParamDesc))));  param++;  if(cookieLength){    char *addmore;    u_long calc;    addmore = (char *)param;    memcpy(addmore,(char *)cookie,cookieLength);    calc = (u_long)addmore;    calc += cookieLength;    /* round up */    calc += 3;    calc >>= 2;    calc <<= 2;    param = (struct sctpParamDesc *)(calc);  }  /* Additional parameters could be added here at the end of the cookie.   * Make sure to increase the size set in dataSize.   */  /* here comes our U-SCTP parameter */  {    struct sctpParamDesc *upd;    struct sctpUnrelStrmRange *sr;    int k, ulen, sp, ep;    SCTPdebugPrint(m,"Add in Unreliable Stream Param\n");    upd = param;    upd->paramType = htons(SCTP_UNRELIABLE_STRM);    /* length will be set later */    param++;    dataSize += sizeof(struct sctpParamDesc);    k = 0;    sr = (struct sctpUnrelStrmRange *)param;    for(i=0; i<MAX_UNRELSTREAM_SETS*2; i+=2) {      sp = m->unrelStreamSets[i]; /* start */      ep = m->unrelStreamSets[i+1]; /* end */      if(sp < 0 || ep <0) break; /* done */      SCTPdebugPrint(m,"u-strm start:%d - end:%d\n", sp, ep);      sr->UnrelStrmStart = htons(sp);      sr->UnrelStrmEnd = htons(ep);      sr++;      k++;    }    ulen = k * sizeof(struct sctpUnrelStrmRange);    upd->paramLength = htons(sizeof(struct sctpParamDesc) + ulen);    param = (struct sctpParamDesc *)((u_long)param + ulen);    dataSize += ulen;  }  if(operr != NULL){    char *addmore;    u_long calc;    addmore = (char *)param;    memcpy(addmore,operr,opersz);    calc = (u_long)addmore;    calc += opersz;    /* round up */    calc += 3;    calc >>= 2;    calc <<= 2;    param = (struct sctpParamDesc *)(calc);  }else{    opersz = 0;  }  tsize = htons((dataSize-sizeof(struct sctpHeader)));  dataSize += 3;  dataSize >>= 2;  dataSize <<= 2;  msg->msg.uh.chunkLength = tsize;  sendMsg = buff;  SCTPdebugPrint(m,"Ok FINAL data size for init-ack is %d\n",dataSize);  SCTPdebugPrint(m,"--->Sending out a INIT-ACK\n");  SCTPdebugPrintArry(m,sendMsg,dataSize);  SCTPdebugPrint(m,"!-->\n");  SCTPdebugPrintAddress(m,from);  retVal = SCTPlsendto(m,(struct SCTP_association *)NULL,sendMsg,dataSize,0,from,0,0,toAddr,0);  return(retVal);}intSCTPsendChunkList(struct SCTP *m,struct SCTP_association *asoc,		  struct sctpChunkDesc **listToSend,int num,		  int whichLan,		  int flg,		  int flow,		  char tos){ /* This is the main send routine. It could  * be done more efficently, but for this implementation  * we have a stack buf or SCTP_WINDOW_MAX (65k), copy all the array  * of chunks into it and then blast it out. There  * is no safety here either it is always assumed that  * SCTP_MAX_READBUFFER is larger than the largest MTU we can send.  */  unsigned char addrFmt[SCTP_ADDRMAX];  char sendbuffer[SCTP_MAX_READBUFFER];  int i,sz,retVal;  struct sctpHeader *mh;  int sendSize;  memset(sendbuffer,0,SCTP_MAX_READBUFFER);  mh = (struct sctpHeader *)sendbuffer;  initSctpHeader(mh,asoc->hisTag);  sendSize = sizeof(struct sctpHeader);  SCTPdebugPrint(m,"Going to group %d chunks sendSize:%d\n",num,sendSize);  if(asoc->ECN_Allowed){    /* check to see if we have any ECN_Echo or CWR to send */    if(asoc->ECN_echo != NULL){      /* include the ecn echo */      memcpy(&sendbuffer[sendSize],asoc->ECN_echo,sizeof(struct sctpECN_echo));      sendSize += sizeof(struct sctpECN_echo);    }    if(asoc->CWR != NULL){      /* include the cwr ack */      memcpy(&sendbuffer[sendSize],asoc->CWR,sizeof(struct sctpCWR));      sendSize += sizeof(struct sctpCWR);    }  }  for(i=0;i<num;i++){    /* copy in each chunk and increment     * the addresses of where next     * to begin. Could probably change to a uvec     * type send for better performance. This     * would mean a change to sctpmtu.c to send     * via a uvec.     */    sz = ntohs(listToSend[i]->chunkLength);    memcpy(&sendbuffer[sendSize],(char *)listToSend[i],sz);    sz += 3;    sz >>= 2;    sz <<= 2;    sendSize += sz;  }  SCTPmakeIntoSock(addrFmt,asoc,whichLan);  SCTPdebugPrintAddress(m,(struct sockaddr *)addrFmt);  retVal = SCTPlsendto(m,asoc,(char *)sendbuffer,sendSize,flg,		       (struct sockaddr *)addrFmt,flow,tos,NULL,whichLan);  SCTPdebugPrint(m,"Returns a %d\n",retVal);  return(retVal);}intSCTPsendSackFlag(struct SCTP *m,		 struct SCTP_association *asoc){  /* this sends a stand alone SACK to the   * peer.    */  struct sctpChunkDesc *listToSend[3];  struct sctpUnifiedShutdown shut;  int retVal,dupseen,whichLan,numChunks,sackIdx;    dupseen = asoc->numduptsns;  listToSend[0] = NULL;  listToSend[1] = NULL;  listToSend[2] = NULL;  if((asoc->state&SCTP_STATE_MASK) == SCTP_STATE_SHUTDOWN){    /* we are bundling in a SHUTDOWN with this SACK */    numChunks = 2;    sackIdx = 1;    shut.uh.chunkID = SCTP_SHUTDOWN;    shut.uh.chunkFlg = 0;     shut.uh.chunkLength = htons(sizeof(struct sctpUnifiedShutdown));    shut.shut.TSN_Seen = (u_long)htonl(asoc->mappingArrayHighestTSN);    listToSend[0] = &shut.uh;  }else{    numChunks = 1;    sackIdx = 0;  }  listToSend[sackIdx] = SCTPbuildASAck(m,asoc);  if(listToSend[sackIdx] == NULL){    /* no memory .. build complained so I     * won't here      */    return(-1);  }  /* Now at this point I have a SACK chunk,   * must combine it with the header to   * be able to send it.   */  whichLan = 0;  SCTPdebugPrint(m,"lastNetRcvdFrom is %d\n",asoc->lastNetRcvdFrom);  if(dupseen == 0){    if(asoc->lastNetRcvdFrom < asoc->numnets){      /* go back to last net rcvd on */      whichLan = asoc->lastNetRcvdFrom;    }else{      /* strange bail out to lan 0 */      whichLan = 0;    }  }else{    /* we have seen duplicates, don't use     * the network that we received this on      */    if(asoc->numnets > 1){      asoc->lastNetRcvdFrom++;      if(asoc->lastNetRcvdFrom >= asoc->numnets)	asoc->lastNetRcvdFrom = 0;      whichLan = asoc->lastNetRcvdFrom;    }else{      /* no choice he is singly homed */      whichLan = 0;    }  }  retVal = SCTPsendChunkList(m,asoc,listToSend,numChunks,whichLan,SCTP_DONT_FRAGMENT,0,0);  if(retVal > 0){    asoc->pegs[SCTP_PEG_SACKS_SENT]++;  }  /* now free it up */  w_free(m,(char *)listToSend[0]);  return(retVal);}voidsendRelReqAck(struct SCTP *m,	      struct SCTP_association *asoc,	      struct sockaddr *from){  struct sctpChunkDesc *listToSend[2];  struct SCTP_association *tasoc;  int ret,whichLan;  if(asoc->lastSentRelAck == NULL){    return;  }  /* re-lookup the association, so we can figure out which index to   * send the response to. We are cheating here so we don't have   * to craft the response ourself.. of course we still will need to    * change this (along with any other findAssoc call when we get    * the hash table in place AND IPv6 in ).   */  tasoc = SCTPfindAssociation(m,from,&whichLan);  listToSend[0] = (struct sctpChunkDesc *)asoc->lastSentRelAck;  listToSend[1] = NULL;  if(tasoc != asoc){    SCTPdebugPrint(m,"Strange, from does not lead to association? TSNH!\n");    return;  }  ret = SCTPsendChunkList(m,asoc,listToSend,1,whichLan,SCTP_FRAGMENT_OK,0,0);  SCTPdebugPrint(m,"Returns a %d\n",ret);}intSCTPsendRelReqOut(struct SCTP *m,		  struct SCTP_association *asoc,		  int retransmitFlag){  /* sends out a reliable request */  struct sctpRelChunkDesc *chunkToSend;  struct sctpChunkDesc *listToSend[2];  int fs,curFlight,cnt,i;  u_int TLVseq;  int whichLan,ret;  cnt = 0;  if(retransmitFlag){    SCTPdebugPrint(m,"Doing a retransmit\n");    if(asoc->lastSentRelReq == NULL){      /* TSNH */      return(-2);    }    /* pick up the last one we sent for retran */    chunkToSend = asoc->lastSentRelReq;    /* select a network to send it to */    if(asoc->lastNetSentTo == asoc->relReqLastSentTo){      /* give it a direct query since       * the algorithm perfers other       * networks first then the       * one last sent to.       */      whichLan = SCTPselectNextLan(m,asoc);    }else{      /* rig so selection algorithm will last       * consider the last we sent to.       */      int x;      x = asoc->lastNetSentTo;      asoc->lastNetSentTo = asoc->relReqLastSentTo;      whichLan = SCTPselectNextLan(m,asoc);      asoc->lastNetSentTo = x;    }  }else if(dlist_getCnt(asoc->queueOfRelReq) <= 0){    /* nothing to send */    return(-2);  }else{    /* ok we must build a chunk to send out of the list */    int sizToAloc,augment,sz,oddball;    struct sctpParamDesc *cparam,*copyPoint;    sizToAloc = sizeof(struct sctpRelChunkDesc);    SCTPdebugPrint(m,"Doing an initial transmit\n");    dlist_reset(asoc->queueOfRelReq);    TLVseq = 1;    /* count how much we need to handle all of this */    while((cparam = ((struct sctpParamDesc *)dlist_get(asoc->queueOfRelReq))) != NULL){      augment = (((ntohs(cparam->paramLength) + 3) >> 2) << 2);      SCTPdebugPrint(m,"Augment is %d\n",augment);      if((sizToAloc + augment + sizeof(u_int)) > asoc->smallestMTU){	/* this one won't fit */	SCTPdebugPrint(m,"Done size is to large now\n");	break;      }      cnt++;      sizToAloc += augment;      sizToAloc += sizeof(u_int);    }    if(cnt == 0){      /* TSNH since the queuing module protects against this */      SCTPdebugPrint(m,"TSNH??? cnt==0\n");      return(-1);    }    SCTPdebugPrint(m,"Allocating %d + 4\n",sizToAloc);    chunkToSend = w_calloc(m,1,(sizToAloc + 4));    if(chunkToSend == NULL){      /* out of memory oh-oh */      SCTPdebugPrint(m,"Allocating failed\n");      return(-1);    }    memset(chunkToSend,0,(sizToAloc+4));    chunkToSend->chk.chunkID = SCTP_RELIABLE_CNTL;    chunkToSend->chk.chunkFlg = 0;    chunkToSend->serialNumber = htonl(asoc->relReqSeqOut);    for(i=0;i<asoc->numberOfNets;i++){      SCTPdebugPrint(m,"Looking for a lookup address at %d val:%d\n",		     i,asoc->addrStats[i]);      if((asoc->addrStats[i] != 0) && 	 (asoc->addrStats[i] != SCTP_ADDR_NOT_IN_ASSOC)){	/* Any reachable address that is part of the association 	 * even the one being deleted is ok to place in here.	 */	SCTPdebugPrint(m,"Ok, lets look at it\n");	if(asoc->localNets[i]->sa_family == AF_INET6){	  /* IPv6 */	  struct sockaddr_in6 *sin6;	  sin6 = (struct sockaddr_in6 *)asoc->localNets[i];	  SCTPdebugPrint(m,"Its a v6 address\n");	  chunkToSend->addressType = (u_char)(0x00ff & SCTP_IPV6_PARAM_TYPE);	  memcpy(chunkToSend->lookupAddress,&sin6->sin6_addr,sizeof(struct in6_addr));	}else{	  /* IPv4 */	  struct sockaddr_in *sin;	  SCTPdebugPrint(m,"Its a v4 address\n");	  sin = (struct sockaddr_in *)asoc->localNets[i];	  chunkToSend->addressType = (u_char)(0x00ff & SCTP_IPV4_PARAM_TYPE);	  memcpy(chunkToSend->lookupAddress,&sin->sin_addr,sizeof(struct in_addr));	}	break;      }    }    copyPoint = (struct sctpParamDesc *)(chunkToSend + 1);    SCTPdebugPrint(m,"Setup to add %d TLV's\n",cnt);    dlist_reset(asoc->queueOfRelReq);    sizToAloc = sizeof(struct sctpRelChunkDesc);    oddball = 0;    while((cparam = ((struct sctpParamDesc *)dlist_get(asoc->queueOfRelReq))) != NULL){      sz = ntohs(cparam->paramLength);      augment = (((sz + 3) >> 2) << 2);      if((sizToAloc + augment + sizeof(u_int)) > asoc->smallestMTU){	/* all done */	SCTPdebugPrint(m,"All done\n");	break;      }      oddball = augment - sz;      SCTPdebugPrint(m,"Copy in %d bytes\n",sz);      memcpy((char *)copyPoint,&TLVseq,sizeof(TLVseq));      copyPoint = (struct sctpParamDesc *)((u_long)copyPoint + sizeof(TLVseq));      TLVseq++;      memcpy((char *)copyPoint,(char *)cparam,sz);      copyPoint = (struct sctpParamDesc *)((u_long)copyPoint + augment);      SCTPdebugPrint(m,"Move up %d bytes\n",augment);      sizToAloc += augment;      sizToAloc += sizeof(u_int);    }    /* chop off the last round up for savings and fun :-) */    sizToAloc -= oddball;    SCTPdebugPrint(m,"Took away oddball from last %d end with %d to send\n",		   oddball,sizToAloc);    chunkToSend->chk.chunkLength = htons(sizToAloc);    /* select a network to send it to */    if((asoc->nets[asoc->primary_destination].intfRotationState&SCTP_ADDR_NOT_REACHABLE) == 0){      whichLan = asoc->primary_destination;    }else{      /* primary is broken, select something else */      whichLan = SCTPselectNextLan(m,asoc);    }    SCTPdebugPrint(m,"Selected lan %d\n",whichLan);  }  /* ok, we are have a destination selected (in whichLan), we   * have a chunk ready to go in chunkToSend, now is there at   * least 1 byte of room in the flight size?   */  if(retransmitFlag == 0){    fs = asoc->nets[whichLan].flightSize;    curFlight = asoc->totalFlight;    SCTPdebugPrint(m,"fs:%d  > cwd:%d?\n",		   fs,asoc->nets[whichLan].cwnd);    if(fs >= asoc->nets[whichLan].cwnd){      /* can't now no room to send,       * now if we really wanted to cheat here we could       * select a different destination and try that until       * we found one that the REL-REQ would fit on, but we won't.       * One thing to note, only retransmits obey the cwnd, if I       * was granted permission to send the original chunk and it       * is now time to retransmit, I go ahead and send it, no matter       * the flight size since the ship is already launched so to speak.       */      w_free(m,(char *)chunkToSend);      asoc->relReqSent = 0;      SCTPdebugPrint(m,"No room - flightsize:%d > cwnd:%d\n",		     fs,asoc->nets[whichLan].cwnd);          return(-1);    }    SCTPdebugPrint(m,"Not ok to send\n");  }  /* now we are set to go, we must prepare the arg's for the   * chunking sender.   */  listToSend[0] = (struct sctpChunkDesc *)chunkToSend;  listToSend[1] = NULL;  ret = SCTPsendChunkList(m,asoc,listToSend,1,whichLan,SCTP_DONT_FRAGMENT,0,0);  SCTPdebugPrint(m,"chunk list send returns %d\n",ret);  if(ret >= 0){    /* success */    asoc->relReqLastSentTo = asoc->lastNetSentTo = whichLan;    if(retransmitFlag == 0){      /* setup the lock flag to the count of chunks sent */      asoc->relReqSent = cnt;      if(asoc->lastSentRelReq != NULL){        w_free(m,(char *)asoc->lastSentRelReq);      }      asoc->lastSentRelReq = chunkToSend;    }    if(cnt > 0){      struct sctpParamDesc *toSave;      struct SCTP_RelReqKey *key;      SCTPdebugPrint(m,"Now try to remove and free %d TLV's\n",cnt);      TLVseq = 1;      dlist_reset(asoc->queueOfRelReq);      /* pull the first cnt chunks from the list and free */      for(i=0;i<cnt;i++){	toSave = (struct sctpParamDesc *)dlist_getNext(asoc->queueOfRelReq);	key = (struct SCTP_RelReqKey *)w_calloc(m,1,(sizeof(struct SCTP_RelReqKey)));	if(key == NULL){	  /* A real bad problem if we get here. Only thing I can	   * think to do is free the toSave and lose track of what	   * I did... bummer dude but we are in a bad way and things	   * are probably going to get worse :<	   */	  SCTPdebugPrint(m,"Bummer, we are in a memory alloc problem... don't know how to recover realy!\n");	  w_free(m,(char *)toSave);	}else{	  /* we only look at the first u_int of the key structure, the rest	   * is used to hold the reply (if any) on return.	   */	  key->key = TLVseq;	  key->reply = NULL;	}	TLVseq++;	if(key != NULL){	  if(HashedTbl_enter(asoc->pendingChunks,(void*)key,(void *)toSave,sizeof(u_int)) < LIB_STATUS_GOOD){	    /* Again we are in trouble */	    SCTPdebugPrint(m,"Bummer, Can't enter into hash table?? free it all what a mess!\n");	    w_free(m,(char *)toSave);	    w_free(m,(char *)key);	  }	}      }    }    SCTPdebugPrint(m,"REL-REQ:OUT OF HERE\n");    return(0);  }else{    if(retransmitFlag == 0){      /* we failed to send, leave all chunks on queue       * and hopefully we will get them out       * next time (unless this is a retransmit.       */      w_free(m,(char *)chunkToSend);      asoc->relReqSent = 0;    }    SCTPdebugPrint(m,"Bummer send failed\n");    return(-1);  }}struct SCTP_transmitOnQueue *SCTPgetNextRetransmit(struct SCTP *m, struct SCTP_association *asoc, int lessThan,		      struct SCTP_transmitOnQueue *beginAt, 		      struct SCTP_transmitOnQueue **leftOff		      ){  struct SCTP_transmitOnQueue *ret,*tp;  int roundsize, rl;  /* find the next one to be retransmitted within   * the size parameters specified. This too could   * be improved in performance.   */  ret = NULL;  tp = beginAt;  while(tp){    /* check state */    if(tp->sent != SCTP_DATAGRAM_RESEND) {      tp = tp->next; continue;    }    /* check unreliability */    if(tp->streamNumber == 0) {      rl = asoc->outbound.reliable;    } else {      rl = asoc->strmout[tp->streamNumber - 1].reliable;    }    if(rl == SCTP_STRM_UNRELIABLE) {      if(tp->numOfRetrans < 0) {	/* we don't mark it here. we want to let the SACK handler 	 * to drop it from the queue.	 */	SCTPdebugPrint(m,"Skip an unreliable retrans tsn=%d\n",tp->TSN_seq);	tp = tp->next; continue;      }     }     /* check size */    roundsize = (((tp->sizeOfTmit+3) >> 2) << 2);    if((roundsize <= lessThan) || (tp->sendOptions & SCTP_FRAGMENT_OK)) {      SCTPdebugPrint(m,"Sent flag set to %d will retransmit it! (rl=%d rt=%d)\n",		     tp->sent, rl, tp->numOfRetrans);      ret = tp;      break;    }    tp = tp->next;  }  if(tp != NULL){    *leftOff = tp->next;  }else{    *leftOff = NULL;  }  return(ret);}intSCTPsendRetransmits(struct SCTP *m,		    struct SCTP_association *asoc){  /* Send one MTU worth of retransmissions out to   * the association. We try to select a new destination   * address if possible based on cwnd. If the new one   * does not allow us to send we resend to the   * original address.   */  int cntSnt;  int roundSize;  int retVal,whichLan;  int sizeLeftForData,at,tmitAt;  struct sctpChunkDesc *listToSend[SCTP_MAX_BUNDLE_UP];  struct SCTP_transmitOnQueue *tmits[SCTP_MAX_BUNDLE_UP];  struct SCTP_transmitOnQueue *leftAt;  int x,xxx;  int fs,curFlight;  at = tmitAt = 0;  whichLan = cntSnt = 0;  /* for safety we use the smallestMTU */  if(asoc->ECN_Allowed){    sizeLeftForData = asoc->smallestMTU -       (sizeof(struct sctpHeader) + IP_HDR_SIZE + sizeof(struct sctpECN_echo));  }else{    sizeLeftForData = asoc->smallestMTU - (sizeof(struct sctpHeader) + IP_HDR_SIZE);  }  fs = asoc->nets[whichLan].flightSize;  curFlight = asoc->totalFlight;  /* we only gate retransmits to the rwnd if we have some in   * flight   */  if(curFlight > 0){    xxx = asoc->peersRwnd + (sizeof(struct sctpUnifiedDatagram));    if(sizeLeftForData > xxx){      sizeLeftForData = xxx;    }  }  SCTPdebugPrint(m,"Retran anything called sizelimit:%d\n",sizeLeftForData);  if(asoc->cookie != NULL){    /* if there is a cookie only retransmit it */    listToSend[at] = (struct sctpChunkDesc *)asoc->cookie;    at++;    whichLan = SCTPselectNextLan(m,asoc);    retVal = SCTPsendChunkList(m,asoc,			       listToSend,at,whichLan,SCTP_DONT_FRAGMENT,0,0);    if(retVal > 0){      asoc->lastNetSentTo = whichLan;    }    return(1);  }  /* Find the first one to retransmit */  /* set for beginning of queue */  leftAt = asoc->sendqueue;  /* now find one */  tmits[tmitAt] = SCTPgetNextRetransmit(m,asoc,sizeLeftForData,leftAt,&leftAt);  if(tmits[tmitAt] == NULL){    SCTPdebugPrint(m,"none to retransmit\n");    /* verify that flight size is not 0 */    return(0);  }  listToSend[at] = (struct sctpChunkDesc *)tmits[tmitAt]->data;  /* first order of business is to try to select a dest addr */  if(asoc->numnets > 1){    /* ok try to transmit on the last one rcv'd on     * unless that is what this was sent on      */    /* ok this means the where we sent this guy is     * possibly where we last got data from. Lets rotate     * around and find someway to send it other than the     * original destination if possible     */    if(asoc->lastNetSentTo == tmits[tmitAt]->whichNet){      /* give it a direct query since       * the algorithm perfers other       * networks first then the       * one last sent to.       */      whichLan = SCTPselectNextLan(m,asoc);    }else{      /* rig so selection algorithm will last       * consider whichNet        */      x = asoc->lastNetSentTo;      asoc->lastNetSentTo = tmits[tmitAt]->whichNet;      whichLan = SCTPselectNextLan(m,asoc);      asoc->lastNetSentTo = x;    }  }else{    /* only one network */    whichLan = 0;  }  SCTPdebugPrint(m,"Retran on %d selected\n",whichLan);#ifdef SCTP_IGNORE_CWND_ON_FR  if(tmits[0]->doingFastRetransmit == 0){    fs = asoc->nets[whichLan].flightSize;    curFlight = asoc->totalFlight;  }else{    /* if the lowest retran to send is a fast retransmit     * we will allow one MTU of retransmits out     */    fs = 0;    curFlight = 0;  }#else  fs = asoc->nets[whichLan].flightSize;  curFlight = asoc->totalFlight;#endif  if((asoc->peersRwnd <=0) && curFlight){    /* can't now no room to send */    SCTPdebugPrint(m,"No room in rwnd\n");    return(0);  }  if(whichLan != tmits[tmitAt]->whichNet){    /* We are probably moving dg's to a new     * destination. Is there at least 1 byte     * of room? if so we can get away with sending     * there since we only send 1 dg and that      * squeakes us by within the rules.     */    SCTPdebugPrint(m,"check fs:%d to cwnd:%d\n",		   fs,asoc->nets[whichLan].cwnd);    if(fs >= asoc->nets[whichLan].cwnd){      /* sorry, lets divert back to the original       * network, this is the cautious approach. However       * if this guy is pointed to some other dest then all others       * that will get packed together, then this simple       * check is probably not adeqate.       */      whichLan = tmits[tmitAt]->whichNet;      SCTPdebugPrint(m,"fall back lan to %d\n",whichLan);    }  }#ifdef SCTP_IGNORE_CWND_ON_FR  if(tmits[0]->doingFastRetransmit == 0){    fs = asoc->nets[whichLan].flightSize;  }else{    /* if the lowest retran to send is a fast retransmit     * we will allow one MTU of retransmits out     */    fs = 0;  }#else    fs = asoc->nets[whichLan].flightSize;#endif  SCTPdebugPrint(m,"fs:%d net:%d cwnd=%d mtu:%d\n",fs,		 whichLan,asoc->nets[whichLan].cwnd,asoc->nets[whichLan].MTU);  if(fs >= asoc->nets[whichLan].cwnd){    /* can't now no room to send */    SCTPdebugPrint(m,"No room - flightsize:%d > cwnd:%d\n",		   fs,asoc->nets[whichLan].cwnd);    return(0);  }  /* now use the true MTU */  if(asoc->ECN_Allowed){    roundSize = (((sizeof(struct sctpHeader) + tmits[tmitAt]->sizeOfTmit + 3 + 		   IP_HDR_SIZE + sizeof(struct sctpECN_echo)		   ) >> 2) << 2);  }else{    roundSize = (((sizeof(struct sctpHeader) + tmits[tmitAt]->sizeOfTmit + 3 + IP_HDR_SIZE		   ) >> 2) << 2);  }  sizeLeftForData = asoc->nets[whichLan].MTU - roundSize;  SCTPdebugPrint(m,"Size left for transmit is %d mtu-(%d+20)\n",roundSize,tmits[tmitAt]->sizeOfTmit);  xxx = asoc->peersRwnd + sizeof(struct sctpUnifiedDatagram);  if(sizeLeftForData > xxx){    SCTPdebugPrint(m,"Hmm %d > xxx:%d\n",sizeLeftForData,xxx);    sizeLeftForData = xxx;  }  SCTPdebugPrint(m,"Size left for transmit is %d mtu-(%d+20)\n",sizeLeftForData,tmits[tmitAt]->sizeOfTmit);  at++;  tmits[tmitAt]->sent = SCTP_READY_TO_TRANSMIT;  tmitAt++;  /* Now lets pack up a bunch of this stuff in a   * datagram that will fit in one MTU.   */  while((at < SCTP_MAX_BUNDLE_UP) && (sizeLeftForData > 0)){    /* Now get all we can to our arrays */    tmits[tmitAt] = SCTPgetNextRetransmit(m,asoc,sizeLeftForData,leftAt,&leftAt);    if(tmits[tmitAt] == NULL){      /* we are out of here */      break;    }    tmits[tmitAt]->sent = SCTP_READY_TO_TRANSMIT;    listToSend[at++] = (struct sctpChunkDesc *)tmits[tmitAt]->data;    SCTPdebugPrint(m,"Size left for transmit[%d] is %d-(%d+20)\n",tmitAt,sizeLeftForData,tmits[tmitAt]->sizeOfTmit);    sizeLeftForData -= (((tmits[tmitAt]->sizeOfTmit + 3) >> 2) << 2);    tmitAt++;  }  /* at this point we have a list of dg's to re-tran   * lets do it.   */  retVal = SCTPsendChunkList(m,asoc,listToSend,at,whichLan,			     tmits[0]->sendOptions,tmits[0]->ipv6_flow,tmits[0]->tos);  SCTPdebugPrint(m,"Ok re-send chunks returns %d\n",retVal);  if(retVal >= 0){    /* it was sent so now start the timer and mark eveyone     * to sent.     */    int i;    timerWork(m,asoc,SCTP_TIMER_STOP,SctpTimerTypeSend,whichLan);    SCTPdebugPrint(m,"Retran suceeds of %d entites\n",at);    cntSnt+= at;    asoc->lastNetSentTo = whichLan;    asoc->pegs[SCTP_RETRANTSN_SENT] += at;    asoc->pegs[SCTP_DATA_DG_SENT]++;    for(i=0;i<at;i++){      /* never do RTT on a retransmit */      if(tmits[i]->sent_rcv_Time.tv_sec){	/* no RTO pending now */	asoc->nets[i].rtoPending = 0;       }      asoc->nets[whichLan].flightSize += tmits[i]->sizeOfTmit;      asoc->totalFlight += tmits[i]->sizeOfTmit;      tmits[i]->sent_rcv_Time.tv_sec = tmits[i]->sent_rcv_Time.tv_nsec = 0;      tmits[i]->whichNet = whichLan;      SCTPdebugPrint(m,"Mark %x to sent [%d]\n",		     tmits[i]->TSN_seq,		     i);      if(tmits[i]->doingFastRetransmit == 0){	tmits[i]->sent = SCTP_DATAGRAM_SENT;      }else{	/* mark it up one above RESEND, 	 * which means we won't send it again until a T-O.	 */	tmits[i]->sent = SCTP_DATAGRAM_RESEND + 1;	SCTPdebugPrint(m,"******Fast Retransmit marked to %d\n",		       tmits[i]->sent);      }      tmits[i]->numOfRetrans--; /* for unreliable data use */      tmits[i]->sndCount++;      SCTPdebugPrint(m,"Rwnd drops by %d FROM %d\n",		     (tmits[i]->sizeOfTmit - sizeof(struct sctpUnifiedDatagram)),		      asoc->peersRwnd);      asoc->peersRwnd -= (tmits[i]->sizeOfTmit - sizeof(struct sctpUnifiedDatagram));      SCTPdebugPrint(m,"NEW RWND %d\n",asoc->peersRwnd);    }    timerWork(m,asoc,SCTP_TIMER_START,SctpTimerTypeSend,whichLan);  }else{    /* Hmm could not send, reverse the marks and     * start the timer. It is sure to go off and then     * maybe by then whatever is wrong will be fixed      * (kinda optimistic :-)     */    int i;    SCTPdebugPrint(m,"Ok re-send chunks returns %d fails\n",retVal);    for(i=0;i<tmitAt;i++){      /* Reverse the marking */      tmits[i]->sent = SCTP_DATAGRAM_RESEND;    }    timerWork(m,asoc,SCTP_TIMER_START,SctpTimerTypeSend,whichLan);  }  SCTPdebugPrint(m,"Sent %d\n",cntSnt);  return(cntSnt);}struct SCTP_transmitOnQueue *SCTPgetNextUnsent(struct SCTP *m, struct SCTP_association *asoc,int lessThan,int indx){  /* Find the next one that has not yet been sent */  struct SCTP_transmitOnQueue *ret,*tp;  int roundsize;  ret = NULL;  tp = asoc->outqueue;  while(tp){    roundsize = (((tp->sizeOfTmit+3) >> 2) << 2);    if((tp->sent == SCTP_DATAGRAM_UNSENT) && (roundsize <= lessThan)){      ret = tp;      break;    }else if((tp->sent == SCTP_DATAGRAM_UNSENT) && (indx == 0) &&	     (tp->sendOptions &= SCTP_FRAGMENT_OK)){      ret = tp;      break;    }else if(tp->sent == SCTP_DATAGRAM_UNSENT){      break;    }    tp = tp->next;  }  return(ret);}intSCTPsendAnyWeCan(struct SCTP *m,		 struct SCTP_association *asoc,int pegit){  /* this sends anything it can up to a   * full MTU's worth, that is in   * the outbound queue.   */  int whichLan,retVal;  int totSent,lsent;  int flight,curFlight;  int xx,yy,xxx,overheadBytes,cookieOverhead;  int sizeLeftForData,at,docleanUp,tmitAt;  int sackToStrip,operToStrip;  struct sctpChunkDesc *listToSend[SCTP_MAX_BUNDLE_UP];  struct SCTP_transmitOnQueue *tmits[SCTP_MAX_BUNDLE_UP];    if((asoc->state & SCTP_STATE_COOKIE_WAIT) == SCTP_STATE_COOKIE_WAIT){    return(0);  }  if(!(asoc->sendMode & SCTP_MY_ADDRESS_ONLY)){    /* no override default to primary lan */    if((asoc->nets[asoc->primary_destination].intfRotationState&SCTP_ADDR_NOT_REACHABLE) == 0){      SCTPdebugPrint(m,"primary destination %d at first blush\n",asoc->primary_destination);      whichLan = asoc->primary_destination;    }else{      /* primary is broken, select something else */      whichLan = SCTPselectNextLan(m,asoc);    }  }else{    /* do selection later */    whichLan = 0;  }  memset((char *)listToSend,0,(sizeof(struct sctpChunkDesc *) *SCTP_MAX_BUNDLE_UP));   lsent = totSent = 0;  yy = xx = totSent = tmitAt = docleanUp = at = 0;  sackToStrip = operToStrip = 0;  /* If theres is    * room in the window to   * send more information.   * We should:   * 1> See if we need to have a cookie sent.   * 2> See if we need to send a SACK   * 3> See if we have something that needs sending, if not return    *    but send a cookie if it is there.   * 4> See if rwnd of peer says no room, if 0 we can probe one dg worth   *    if set, we must keep total flight sizes below rwnd.   */  if(asoc->ECN_Allowed){    /* Always reserve size (8 bytes) for ECN */    sizeLeftForData = asoc->smallestMTU - ((sizeof(struct sctpHeader) + IP_HDR_SIZE) + 					   sizeof(struct sctpECN_echo));  }else{    sizeLeftForData = asoc->smallestMTU - ((sizeof(struct sctpHeader) + IP_HDR_SIZE));  }  SCTPdebugPrint(m,"size of smallest MTU is %d\n",sizeLeftForData);  SCTPdebugPrint(m,"First lets look for a cookie\n");  cookieOverhead = overheadBytes = 0;  if(asoc->cookie != NULL){    SCTPdebugPrint(m,"Picked up a cookie\n");    listToSend[at] = (struct sctpChunkDesc *)asoc->cookie;    cookieOverhead = (((ntohs(listToSend[at]->chunkLength) + 3) >> 2) << 2);    sizeLeftForData -= cookieOverhead;    at++;  }  if(asoc->needToAck){    /* Need to add a SACK ? */    SCTPdebugPrint(m,"Picked up a SACK\n");    listToSend[at] = SCTPbuildASAck(m,asoc);    xx = 1;    if(listToSend[at]){      overheadBytes = (((ntohs(listToSend[at]->chunkLength) + 3) >> 2) << 2);      sizeLeftForData -= overheadBytes;      at++;      sackToStrip = 1;    }  }  if(asoc->opErr != NULL){    SCTPdebugPrint(m,"Any errors to send too?\n");    listToSend[at] = (struct sctpChunkDesc *)asoc->opErr;    sizeLeftForData -= (((asoc->opErrSiz + 3) >> 2) << 2);    at++;    operToStrip = 1;  }  SCTPdebugPrint(m,"Now, revector the size limit, size of smallest MTU is %d (minus control oh)\n",		 sizeLeftForData);  xxx = asoc->peersRwnd + sizeof(struct sctpUnifiedDatagram);  SCTPdebugPrint(m,"Peers rwnd:%d add header overhead %d is %d\n",		 asoc->peersRwnd,sizeof(struct sctpHeader),xxx);  if(sizeLeftForData > xxx){    sizeLeftForData = xxx;    SCTPdebugPrint(m,"Gating effect on sizelimit now-> %d\n",sizeLeftForData);  }  /* Here we should probably check to see if we could send   * a datagram with no piggyback control as well.    * This is because it is possible that the cookie or SACK   * takes up all the room and thus there is no way   * we can join them but there could still be room to   * send some. This may cause a in-efficency in this   * implementation that should be fixed in a production   * version.   */  SCTPdebugPrint(m,"Getting next unsent limit of size %d\n",sizeLeftForData);  tmits[tmitAt] = SCTPgetNextUnsent(m,asoc,sizeLeftForData,tmitAt);  flight = asoc->nets[whichLan].flightSize;  curFlight = asoc->totalFlight;  SCTPdebugPrint(m,"Current flight to lan:%d is %d total:%d\n",		 whichLan,flight,curFlight);  if(tmits[tmitAt] == NULL){    /* Nothing to send, or the next one will not fit */    SCTPdebugPrint(m,"Nothing found for tmitAt:%d\n",tmitAt);    if(pegit){      if(sizeLeftForData == xxx){	/* gated by rwnd */	asoc->pegs[SCTP_NONE_LFT_RWND]++;	asoc->fsp1[asoc->fsidx] = curFlight;	asoc->fsp2[asoc->fsidx] = asoc->peersRwnd;	asoc->fsp3[asoc->fsidx] = asoc->nets[whichLan].cwnd;	asoc->fsp5[asoc->fsidx] = xxx;	asoc->fsidx++;	if(asoc->fsidx >= MAX_FSID){	  asoc->fsidx = 0;	}      }else{	/* gated by nothing left to send */	asoc->pegs[SCTP_NONE_LFT_TO]++;      }    }    if(curFlight){      SCTPdebugPrint(m,"Nothing to transmit data wise - 1\n");      docleanUp = 1;    }    /* try again we must may need to have one in flight */    if(asoc->ECN_Allowed){      sizeLeftForData = asoc->smallestMTU - (((sizeof(struct sctpHeader) + IP_HDR_SIZE + sizeof(struct sctpECN_echo) + 3) >> 2) << 2);    }else{      sizeLeftForData = asoc->smallestMTU - (((sizeof(struct sctpHeader) + IP_HDR_SIZE + 3) >> 2) << 2);    }    /* take off the cookie if present */    sizeLeftForData -= cookieOverhead;    /* take off any sack or cookie size */    SCTPdebugPrint(m,"Second call to getNextUnsent sizelimit at:%d\n",sizeLeftForData);    tmits[tmitAt] = SCTPgetNextUnsent(m,asoc,sizeLeftForData,tmitAt);    sizeLeftForData = 0;    if(tmits[tmitAt] == NULL){      SCTPdebugPrint(m,"Nothing to transmit data wise - 2\n");      docleanUp = 1;    }else{      /* ok we need to strip back out the piggyback'ed sacks */      if(sackToStrip && operToStrip){	/* ok there exists both a operr and a sack */	w_free(m,(char *)listToSend[(at-2)]);	listToSend[at-1] = listToSend[at-2] = NULL;	at-=2;      }else if(sackToStrip){	w_free(m,(char *)listToSend[(at-1)]);	listToSend[(at-1)] =  NULL;	at--;      }else if(operToStrip){	listToSend[(at-1)] = NULL;	at--;      }      operToStrip = sackToStrip = 0;    }  }  if(asoc->sendMode & SCTP_MY_ADDRESS_ONLY){    /* assoc has been overrided to use only the original     * destined address if it is reachable.     */    if((asoc->nets[tmits[tmitAt]->whichNet].intfRotationState&SCTP_ADDR_NOT_REACHABLE) == 0){      whichLan = tmits[tmitAt]->whichNet;    }else{      /* specified is broken, select something else */      whichLan = SCTPselectNextLan(m,asoc);    }    flight = asoc->nets[whichLan].flightSize;    curFlight = asoc->totalFlight;  }  SCTPdebugPrint(m,"Select which destination to use picks:%d\n",whichLan);  SCTPdebugPrintAddress(m,asoc->nets[whichLan].ina);  if(docleanUp == 0){    yy = 1;    /* check where it goes to see if there     * is room to send, curFlight ends up with      * the total flight size.     */    SCTPdebugPrint(m,"TEST rwnd:%d && curFlight:%d\n",		   asoc->peersRwnd,curFlight);    if((asoc->nets[whichLan].cwnd - flight) <= 0){      /* no room for more data */      SCTPdebugPrint(m,"Set for cleanup, cwnd:%d - flight:%d <= 0\n",		     asoc->nets[whichLan].cwnd,flight);      if(pegit)	asoc->pegs[SCTP_NONE_LFT_CWND]++;      docleanUp = 1;    }else if((asoc->peersRwnd <= 0) && curFlight){      /* Got to much heading his way, and I do have something in       * flight to him, i.e. I have a probe out for a a_rwnd change       */      SCTPdebugPrint(m,"Set for cleanup, rwnd:%d && curFlight:%d\n",		     asoc->peersRwnd,curFlight);		           docleanUp = 1;    }else{      /* There is room in cwnd for the network and I have rwnd room or       * am probing for more room       */      SCTPdebugPrint(m,"Room for this guy %d rwnd:%d flight:%d\n",		     tmits[tmitAt]->sizeOfTmit,asoc->peersRwnd,		     curFlight);      listToSend[at++] = (struct sctpChunkDesc *)tmits[tmitAt]->data;      sizeLeftForData -= (((tmits[tmitAt]->sizeOfTmit + 3) >> 2) << 2);      tmits[tmitAt]->sent = SCTP_READY_TO_TRANSMIT;      tmitAt++;    }  }  SCTPdebugPrint(m,"Test again against docleanUp\n");  if(docleanUp){    /* no user data we can send so clean up as needed */    SCTPdebugPrint(m,"Is there a cookie?\n");    if((asoc->cookie != NULL) || (asoc->opErr != NULL)){      /* got to send a cookie, no data to bundle, use primary dest. */      SCTPdebugPrint(m,"Transmiting\n");      totSent += SCTPsendChunkList(m,asoc,listToSend,at,whichLan,0,0,0);      SCTPdebugPrint(m,"totsent now %d\n",totSent);      if(totSent > 0){	if(asoc->opErr != NULL){	  /* only include it once */	  w_free(m,asoc->opErr);	  asoc->opErr = NULL;	  asoc->opErrSiz = 0;	}      }    }else if(asoc->needToAck && at){      /* clean up the SACK */      SCTPdebugPrint(m,"Free the sack?\n");      w_free(m,(char *)listToSend[0]);    }    SCTPdebugPrint(m,"Ret totsent:%d\n",totSent);    return(totSent);  }  /* Now at this point, if we reach here we can   * send a MTU's worth, so pack up as much as I can    */  while(at < SCTP_MAX_BUNDLE_UP){    /* Now get all we can to our arrays */    SCTPdebugPrint(m,"adding to the bundle .. size left %d\n",sizeLeftForData);    tmits[tmitAt] = SCTPgetNextUnsent(m,asoc,sizeLeftForData,tmitAt);    if(tmits[tmitAt] == NULL){      /* we are out of here */      break;    }    tmits[tmitAt]->sent = SCTP_READY_TO_TRANSMIT;	    listToSend[at++] = (struct sctpChunkDesc *)tmits[tmitAt]->data;    sizeLeftForData -= (((tmits[tmitAt]->sizeOfTmit + 3) >> 2) << 2);    tmitAt++;      }    /* now we have a bunch o chunks ready to spew.. could   * be a cookie in there too (:-) .   * Call the routine that will send all the chunks.   */   SCTPdebugPrint(m,"2:Transmitting\n");  retVal = SCTPsendChunkList(m,asoc,listToSend,at,whichLan,			     tmits[0]->sendOptions,tmits[0]->ipv6_flow,tmits[0]->tos);  SCTPdebugPrint(m,"Return value of send is now %d\n",retVal);  if(retVal >= 0){    int i;    /* the timerwork could be done a little bit     * more intelligently with a flag or two like     * the needToAck flag, but for now     * we just call timerWork since it will not     * duplicate start a timer     */    if(xx){      /* a sack to peg the count */      asoc->pegs[SCTP_PEG_SACKS_SENT]++;    }    if(yy){      asoc->pegs[SCTP_DATA_DG_SENT]++;    }    /* mark the things we need to track */    asoc->lastNetSentTo = whichLan;      lsent+= tmitAt;    totSent+= tmitAt;    asoc->pegs[SCTP_PEG_TSNS_SENT] += tmitAt;    asoc->numberUnsent -= tmitAt;    if(asoc->numberUnsent < 0){      asoc->numberUnsent = 0;    }    if(operToStrip && (asoc->opErr != NULL)){      /* only include it once */      w_free(m,asoc->opErr);      asoc->opErr = NULL;      asoc->opErrSiz = 0;    }    for(i=0;i<tmitAt;i++){      /* mark off all the tmit structs as being sent */      /* Pull the guy off the outqueue and move to tail of       * send queue        */      /* First, get it off the outqueue */      if(tmits[i]->prev == NULL){	/* it is the head of the outqueue, mostlikely case */		/* make back pointer head of queue */	if(tmits[i]->next)	  tmits[i]->next->prev = NULL;	else{	  /* tail of the out queue */	  asoc->tailoutq = NULL;	}	/* set outqueue to new top */	asoc->outqueue = tmits[i]->next;      }else{	if(tmits[i]->next){	  tmits[i]->next->prev = tmits[i]->prev;	}else{	  if(asoc->tailoutq == tmits[i])	    asoc->tailoutq = tmits[i]->prev;	}	tmits[i]->prev->next = tmits[i]->next;      }      /* Now on to the sendqueue */      tmits[i]->prev = tmits[i]->next = NULL;      if(asoc->sendqueue == NULL){	/* No one on send queue */	asoc->sendqueue = tmits[i];	asoc->sendqueuetail = tmits[i];      }else{	/* use tail of send queue to attach */	asoc->sendqueuetail->next = tmits[i];	tmits[i]->prev = asoc->sendqueuetail;	asoc->sendqueuetail = tmits[i];      }      tmits[i]->whichNet = whichLan;      tmits[i]->numOfRetrans--; /* for unreliable data use */      tmits[i]->sndCount = 1;      asoc->nets[whichLan].flightSize += tmits[i]->sizeOfTmit;      asoc->totalFlight += tmits[i]->sizeOfTmit;      tmits[i]->sent = SCTP_DATAGRAM_SENT;       tmits[i]->sent_rcv_Time.tv_sec = tmits[i]->sent_rcv_Time.tv_nsec = 0;      SCTPdebugPrint(m,"Rwnd drops by %d FROM %d\n",		     (tmits[i]->sizeOfTmit - sizeof(struct sctpUnifiedDatagram)),		     asoc->peersRwnd);      asoc->peersRwnd -= (tmits[i]->sizeOfTmit - sizeof(struct sctpUnifiedDatagram));      SCTPdebugPrint(m,"NEW RWND %d\n",asoc->peersRwnd);    }    (*m->getTime)(&asoc->nets[whichLan].lastSentTime);    if(asoc->nets[whichLan].rtoPending == 0){      /* Authorize a RTO measurment */      SCTPdebugPrint(m,"RTO authorized\n");      asoc->nets[whichLan].rtoPending = 1;      tmits[0]->sent_rcv_Time = asoc->nets[whichLan].lastSentTime;    }    if(asoc->needToAck && sackToStrip){      /* need to stop the rcv timer since we just       * ack'd with a outbound dg       */      /* free up the alloc SACK */      w_free(m,(char *)listToSend[0]);      asoc->needToAck = 0;      timerWork(m,asoc,SCTP_TIMER_STOP,SctpTimerTypeRecv,0);    }    timerWork(m,asoc,SCTP_TIMER_START,SctpTimerTypeSend,whichLan);  }else{    int i;    /* Can't send for some reason      * we are done now, if I had     * a TLI based impl I would possibly     * stick in here a poll for POLLOUT.     * could also be a bad route?     */    SCTPdebugPrint(m,"All done\n");    for(i=0;i<tmitAt;i++){      /* Reverse the marking */      tmits[i]->sent = SCTP_DATAGRAM_UNSENT;    }    timerWork(m,asoc,SCTP_TIMER_START,SctpTimerTypeSend,whichLan);    return(totSent);  }  SCTPdebugPrint(m,"%d returned\n",totSent);  return(totSent);}