/* SCTP reference Implementation Copyright (C) 2001 Cisco Systems Inc.This file is part of the SCTP reference ImplementationVersion:4.0.5$Header: /home/sourceTree/src/sctp/user/sctpAdaptor.c,v 1.16 2001/07/24 11:52:39 randall Exp $The SCTP reference implementation  is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published bythe Free Software Foundation; either version 2, or (at your option)any later version.the SCTP reference implementation  is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of                ************************MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See theGNU Library General Public License for more details.You should have received a copy of the GNU Library General Public Licensealong with GNU CC; see the file COPYING.  If not, write tothe Free Software Foundation, 59 Temple Place - Suite 330,Boston, MA 02111-1307, USA.  Please send any bug reports or fixes you make to one of the following emailaddresses:rrs@cisco.comkmorneau@cisco.comAny bugs reported given to us we will try to fix... any fixes shared willbe incorperated into the next SCTP release.There are still LOTS of bugs in this code... I always run on the motto"it is a wonder any code ever works :)"*/#include <sctpAdaptor.h>sctpAdaptorMod *object_in = NULL;static int lastStream=0;static int lastStreamSeq=0;intsctpReadInput(struct SCTP *m, distributor *o){  /* receive some number of datagrams and   * act on them.   */  int sz,str,seq,i,disped,payloadtype;  u_int tsn;  messageEnvolope msgout;  unsigned char to[SCTP_ADDRMAX],from[SCTP_ADDRMAX];  char readBuffer[65535];  disped = i = 0;  sz = sctpRECEIVE(m,readBuffer,65535,&str,&seq,		   (struct sockaddr *)from,		   (struct sockaddr *)to,		   &payloadtype,&tsn);  if(sz <= 0){    return(0);  }  msgout.takeOk = 0;  msgout.TSN = tsn;  msgout.protocolId = payloadtype;  lastStream = msgout.streamNo = str;  lastStreamSeq = msgout.streamSeq = seq;  msgout.totSize = sz;  msgout.totData = readBuffer;  msgout.siz = sz;  msgout.data = readBuffer;  msgout.from = &from;  msgout.type = PROTOCOL_Sctp;  msgout.to = &to;  msgout.origFrom = NULL;  msgout.origType =  PROTOCOL_Unknown;  msgout.sender = (void *)m;  dist_sendmessage(o,&msgout);  return(1);}intsctpFdInput(void *arg,int fd ,int event){  int ret;  sctpAdaptorMod *m;  m = (sctpAdaptorMod *)arg;  /* setin the object in session */  object_in = m;  if(event != 0){    sctpfdEvent(m->m,event,fd);  }  ret = sctpReadInput(m->m, m->o);  return(ret);}voidsctp_adaptor_timer_up(void *arg1, void *arg2){  sctpAdaptorMod *m;  m = (sctpAdaptorMod *)arg1;  /* setin the object in session */  object_in = m;  sctptimerExpires(m->m,arg2);}voidSCTP_timer_util(struct SCTP *sctpP, void *arg, int opType, int sec, int usec){  int ret;  /* we always use the object_in last set, since if we are in   * the timer_up it is set current. If we are in a fd event   * it is set current.   */  ret = 0;  if(object_in == NULL)    /* error, init never called? */    return;  if(opType == SCTP_TIMER_START){    ret = dist_TimerStart(object_in->o,sctp_adaptor_timer_up,sec,		usec,(void *)object_in, arg);  }else if(opType == SCTP_TIMER_STOP){    ret = dist_TimerStop(object_in->o,sctp_adaptor_timer_up,			 (void *)object_in,arg);  }  if(ret < LIB_STATUS_GOOD){    printf("TSNH:Timer fails to stop/start:%d %s (arg:%x)\n",	   ret,	   ((opType == SCTP_TIMER_START) ? "Start": "Stop"  ),	   (u_int)arg);  }}voidSCTP_adaptor_changeEvent(int fd,int newmask){  if(object_in == NULL)    return;  dist_changeFd(object_in->o,fd,newmask);}static int continualINIT=0;static unsigned char to_ip[SCTP_ADDRMAX];intSCTP_setContinualInit(int value){  continualINIT = value;  return(value);}/* A protocol-independent substitute to SCTP_setIPaddr(), SCTP_setIPaddr6(), * SCTP_setport(). */intSCTP_setIPaddrinfo(struct addrinfo *res){    if (res->ai_family != AF_INET && res->ai_family != AF_INET6) {        printf("protocol family unsupported\n");        return 1;    }        memcpy(to_ip, res->ai_addr, res->ai_addrlen);        return 0;}voidSCTP_setIPaddr(u_int addr){  struct sockaddr_in *to;  to = (struct sockaddr_in *)to_ip;  to->sin_family = AF_INET;#ifdef USES_BSD_4_4_SOCKET    to->sin_len = sizeof(struct sockaddr_in);#endif  to->sin_addr.s_addr = addr;}voidSCTP_setIPaddr6(u_char *addr){  struct sockaddr_in6 *to;  to = (struct sockaddr_in6 *)to_ip;  to->sin6_family = AF_INET6;#ifdef USES_BSD_4_4_SOCKET    to->sin6_len = sizeof(struct sockaddr_in6);#endif  memcpy((char *)&to->sin6_addr,addr,sizeof(struct in6_addr));}voidSCTP_setIPv6scope(u_int scope){  struct sockaddr_in6 *to;  to = (struct sockaddr_in6 *)to_ip;  to->sin6_scope_id = scope;}/* XXX works only for IPv4 * prt must be in network byte order */voidSCTP_setport(u_short prt){  struct sockaddr_in *to;  to = (struct sockaddr_in *)to_ip;  to->sin_port = prt;}struct sockaddr *SCTP_getAddr(){  return((struct sockaddr *)to_ip);}u_short SCTP_getport(){  return(((struct sockaddr_in *)to_ip)->sin_port);}/* * need to convert this into a module * that sends a message to the stack. * * [MM] partially done. Once the message sending works fine, we have to * remove all the output to the user, since this is the task of the * function registered to receive the messages. * We may want to provide a replaceable default function that just * does output to the user. */voidSCTPnotify(int event, char *data, int size){#ifdef SOCKET_API  messageEnvolope msg;  eventNotify en;#endif /* SOCKET_API */  int *ptr;#ifdef SOCKET_API  if(object_in == NULL){    /* [MM] We are going to crash soon, probably we should do something     * more than just issuing a warning. */    printf("SCTPnotify: Error: object_in == NULL\n");  }  /* [MM] protocolId is used by the distributor to send messages,   * type is the msg type. We need to set both since protocolId   * may clash with a IANA assigned protocol number. */  msg.TSN = 0;  msg.protocolId = PROTOCOL_SCTP_EVENT;  msg.streamNo = 0;  msg.streamSeq = 0;  msg.totSize = sizeof(en);  msg.totData = &en;  msg.siz = sizeof(en);  msg.data = &en;  msg.from = NULL;  msg.to = NULL;  msg.type = PROTOCOL_SCTP_EVENT;  msg.origFrom = NULL;  msg.origType = 0;  msg.takeOk = 0;  msg.distrib = object_in->o;  msg.sender = NULL;  en.eventType = event;#endif /* SOCKET_API */  switch(event){  case SCTP_NOTIFY_HB_RESP:    printf("SCTP Got your HB response\n");    break;  case SCTP_NOTIFY_ASSOC_UP:    printf("SCTP ASSOCIATION UP\n");    break;  case SCTP_NOTIFY_ASSOC_DOWN:    printf("SCTP ASSOCIATION DOWN\n");    if(continualINIT){      sctpASSOCIATE(object_in->m,(struct sockaddr *)to_ip,0);      continualINIT--;      if(continualINIT < 0){        continualINIT = 0;      }      printf("Continual INIT flag set, retrying, left to go = %d\n",	     continualINIT);    }    break;  case SCTP_NOTIFY_ASSOC_ABORTED:    printf("SCTP ASSOCIATION ABORTED\n");    if(continualINIT){      sctpASSOCIATE(object_in->m,(struct sockaddr *)to_ip,0);      continualINIT--;      if(continualINIT < 0){        continualINIT = 0;      }      printf("Continual INIT flag set, retrying, left to go = %d\n",	     continualINIT);    }    break;  case SCTP_NOTIFY_INTF_DOWN:    printf("SCTP ASSOCIATION INTERFACE DOWN\n");    break;  case SCTP_NOTIFY_INTF_UP:    printf("SCTP ASSOCIATION INTERFACE UP\n");    break;  case SCTP_NOTIFY_DG_FAIL:    printf("SCTP ASSOCIATION DG FAIL\n");    break;  case SCTP_NOTIFY_DG_FAIL_SENT:    printf("In transit DG failed\n");    break;  case SCTP_NOTIFY_ASSOC_RESTART:    printf("SCTP RESTART NOTIFICATION\n");    break;  case SCTP_NOTIFY_STREAM_OPENED_OK:    printf("SCTP ASSOCIATION STREAM OPENED\n");    break;  case SCTP_NOTIFY_PEER_OPENED_STR:    printf("SCTP ASSOCIATION PEER OPENED STREAM\n");    if((data != NULL) && size){      ptr = (int *)data;      printf("  Stream data (size %d): %d\n",	     size, *ptr);    }    break;  case SCTP_NOTIFY_RELREQ_RESULT_OK:    printf("\nRel-Request of %x succeeds\n",(u_int)size);    printf(">");    fflush(stdout);    break;  case SCTP_NOTIFY_RELREQ_RESULT_FAILED:    {      u_int reason,len;      struct sctpParamDesc *reply;      reply = (struct sctpParamDesc *)data;      reason = ntohs(reply->paramType);      len = ntohs(reply->paramLength);      printf("Rel-Request of %x fails reason=%d len=%d\n",(u_int)size,	     (int)reason,	     (int)len);    }    break;  default:    printf("Warning: SCTPnotify called with unknown event %d, data size %d\n",	   event, size);  }#ifdef SOCKET_API  dist_sendmessage(object_in->o, &msg);#endif /* SOCKET_API */  printf(">");  fflush(stdout);}voidSCTPgettime(struct timespec *arg){#if (defined (LINUX) || defined(TRU64) || defined(AIX))   struct timeval tv;  gettimeofday(&tv,NULL);  TIMEVAL_TO_TIMESPEC(&tv,arg);#else    clock_gettime(CLOCK_REALTIME, arg);#endif}sctpAdaptorMod *create_SCTP_adaptor(distributor *o,u_short port){  sctpAdaptorMod *r;  int *fds;  int events,num,i;  memset(to_ip,0,sizeof(to_ip));  r = calloc(1,sizeof(sctpAdaptorMod));  if(r == NULL)    return(r);  r->o = o;  r->m = sctpINITIALIZE(SCTP_timer_util,			SCTP_adaptor_changeEvent,			SCTPnotify,			SCTPgettime,			port);  if(r->m == NULL){    free(r);    r = NULL;    return(r);  }  fds = getSCTPfileDescriptor(r->m,&events,&num);  for(i=0;i<num;i++){    printf("Register fd[%d]=%d of %d event:%d\n",	   i,fds[i],num,events);    dist_addFd(o,fds[i],sctpFdInput,events,(void *)r);  }  object_in = r;  return(r);}voiddestroy_SCTP_adaptor(sctpAdaptorMod *r){  int *fds;  int events,num,i;  fds = getSCTPfileDescriptor(r->m,&events,&num);  sctpABORT(r->m);  for(i=0;i<num;i++){    dist_deleteFd(r->o,fds[i]);  }  free(r);  object_in = NULL;  r = NULL;}voidSCTP_setcurrent(sctpAdaptorMod *r){  object_in = r;}