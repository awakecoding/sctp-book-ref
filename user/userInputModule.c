/* SCTP reference Implementation Copyright (C) 2001 Cisco And MotorolaThis file is part of the SCTP reference ImplementationVersion:4.0.5$Header: /home/sourceTree/src/sctp/user/userInputModule.c,v 1.60 2001/07/25 18:47:55 randall Exp $The SCTP reference implementation  is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published bythe Free Software Foundation; either version 2, or (at your option)any later version.the SCTP reference implementation  is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of                ************************MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See theGNU Library General Public License for more details.You should have received a copy of the GNU Library General Public Licensealong with GNU CC; see the file COPYING.  If not, write tothe Free Software Foundation, 59 Temple Place - Suite 330,Boston, MA 02111-1307, USA.  Please send any bug reports or fixes you make to one of the following emailaddresses:rrs@cisco.comkmorneau@cisco.comqxie1@email.mot.comAny bugs reported given to us we will try to fix... any fixes shared willbe incorperated into the next SCTP release.There are still LOTS of bugs in this code... I always run on the motto"it is a wonder any code ever works :)"*//* Parser for user commands. * * Support for command completion and history added by * Marco Molteni <mmolteni@cisco.com>. */#include <userInputModule.h>#include <distributor.h>#include <sctpAdaptor.h>#include <ctype.h>/* These should not be included except for our test * module to generate TLV's to dump in the REL-REQ */#include <sctputil.h>#include <sctprelreq.h>/* Line editing. */#include <readline/readline.h>#include <readline/history.h>static int execute_line(const char *line);static char *command_generator(char *text, int state);/* Line editing. * Each command must have its own function, with the prefix "cmd_". */static int cmd_addip(char *argv[], int argc);static int cmd_assoc(char *argv[], int argc);static int cmd_bulk(char *argv[], int argc);static int cmd_bulkseen(char *argv[], int argc);static int cmd_chgcookielife(char *argv[], int argc);static int cmd_clearpegs(char *argv[], int argc);static int cmd_continual(char *argv[], int argc);static int cmd_defretryi(char *argv[], int argc);static int cmd_defretrys(char *argv[], int argc);static int cmd_defrwnd(char *argv[], int argc);static int cmd_delip(char *argv[], int argc);static int cmd_disablev6(char *argv[], int argc);static int cmd_doheartbeat(char *argv[], int argc);static int cmd_getcurcookielife(char *argv[], int argc);static int cmd_getdefcookielife(char *argv[], int argc);static int cmd_getfsids(char *argv[], int argc);static int cmd_gethbdelay(char *argv[], int argc);static int cmd_getpegs(char *argv[], int argc);static int cmd_getprimary(char *argv[], int argc);static int cmd_getrtt(char *argv[], int argc);static int cmd_heart(char *argv[], int argc);static int cmd_heartdelay(char *argv[], int argc);static int cmd_help(char *argv[], int argc);static int cmd_hulkstart(char *argv[], int argc);static int cmd_hulkstop(char *argv[], int argc);static int cmd_initmultping(char *argv[], int argc);static int cmd_inqueue(char *argv[], int argc);static int cmd_markustrms(char *argv[], int argc);static int cmd_multping(char *argv[], int argc);static int cmd_netstats(char *argv[], int argc);static int cmd_ping(char *argv[], int argc);static int cmd_quit(char *argv[], int argc);static int cmd_rftp(char *argv[], int argc);static int cmd_printrftpstat(char *argv[], int argc);static int cmd_routes(char *argv[], int argc);static int cmd_rwnd(char *argv[], int argc);static int cmd_send(char *argv[], int argc);static int cmd_sendloop(char *argv[], int argc);static int cmd_sendloopend(char *argv[], int argc);static int cmd_sendreltlv(char *argv[], int argc);static int cmd_setbulkmode(char *argv[], int argc);static int cmd_setdefcookielife(char *argv[], int argc);static int cmd_setdefstream(char *argv[], int argc);static int cmd_seterr(char *argv[], int argc);static int cmd_sethost(char *argv[], int argc);static int cmd_sethost6(char *argv[], int argc);static int cmd_setneterr(char *argv[], int argc);static int cmd_setopts(char *argv[], int argc);static int cmd_setpay(char *argv[], int argc);static int cmd_setport(char *argv[], int argc);static int cmd_setprimary(char *argv[], int argc);static int cmd_setremprimary(char *argv[], int argc);static int cmd_setscope(char *argv[], int argc);static int cmd_setstreams(char *argv[], int argc);static int cmd_startmultping(char *argv[], int argc);static int cmd_tella(char *argv[], int argc);static int cmd_term(char *argv[], int argc);static int cmd_whereto(char *argv[], int argc);/* Line editing. */typedef int f2(char **, int);struct command {    char *co_name;      /* Command name. */    char *co_desc;      /* Command description. */    f2 *co_func;        /* Function to call to execute the command. */};/* Line editing. * Store the commands and the help descriptions. * Please keep this list sorted in alphabetical order. */static struct command commands[] = {    {"addip", "addip address how - add ip address where how is the mask/action to pass\n"     "                    SCTP_ACTION_UPDATE_ALL_ASSOC=0x1\n"     "                    SCTP_ACTION_UPDATE_ENDPOINT=0x02\n"     "                    SCTP_ACTION_UPDATE_ONLY_ASSOC=0x04\n"     "                    SCTP_ACTION_QUEUE_REQUEST_ONLY=0x08\n"     "                    (which can all be or'd together if you want)",     cmd_addip},    {"assoc", "assoc - associate with the set destination",     cmd_assoc},    {"bulk", "bulk size stream count - send a bulk of messages",     cmd_bulk},    {"bulkseen", "bulkseen - display count of bulk packets seen (time resets)",     cmd_bulkseen},    {"chgcookielife", "chgcookielife val - change the current assoc cookieLife",     cmd_chgcookielife},    {"clearpegs", "clearpegs - clear the peg counts",     cmd_clearpegs},    {"continual", "continual num - set continuous init to num times",      cmd_continual},    {"defretryi", "defretryi num - set a new association failure threshold for initing",      cmd_defretryi},    {"defretrys", "defretrys num - set a new association failure threshold for sending",      cmd_defretrys},    {"defrwnd", "defrwnd num - set the default rwnd of the SCTP",      cmd_defrwnd},    {"delip", "delip address [how] - delete ip address where how is the mask/action to pass",      cmd_delip},    {"disablev6", "disablev6 1/0 - Disable V6",      cmd_disablev6},    {"doheartbeat", "doheartbeat - preform a on demand HB",      cmd_doheartbeat},    {"getcurcookielife", "getcurcookielife - display current assoc cookieLife",     cmd_getcurcookielife},    {"getdefcookielife", "getdefcookielife - display default cookie life",     cmd_getdefcookielife},    {"getfsids", "getfsids [prntlimit] - print prntlimit fsid entries",     cmd_getfsids},    {"gethbdelay", "gethbdelay - get the hb delay",     cmd_gethbdelay},    {"getpegs", "getpegs - retrieve the peg counts",     cmd_getpegs},    {"getprimary", "getprimary - tells which net number is primary",     cmd_getprimary},    {"getrtt", "getrtt - Return the RTO of the current default address of the assoc",     cmd_getrtt},    {"heart", "heart on/off - Turn HB on or off to the destination",     cmd_heart},    {"heartdelay", "heartdelay time - Add number of seconds + RTO to hb interval",     cmd_heartdelay},    {"help", "help [cmd] - display help for cmd, or for all the commands if no cmd specified",     cmd_help},    {"hulkstart", "hulkstart filename - start the hulk hogan process",     cmd_hulkstart},    {"hulkstop", "hulkstop - stop the hulk hogan process",     cmd_hulkstop},    {"initmultping", "initmultping - init contexts for a fast test",     cmd_initmultping},    {"inqueue", "inqueue - report inqueue counts",     cmd_inqueue},    {"markustrms", "markustrms (ranges, e.g. 1-2,3,5-9) - mark the unreliable stream range(s)",     cmd_markustrms},    {"multping", "multping size stream count blockafter sec - add a ping pong context and block\n"     "after <blockafter> instances for <sec> seconds",     cmd_multping},    {"netstats", "netstats - return all network stats",     cmd_netstats},    {"ping", "ping size stream count - play ping pong",     cmd_ping},    {"quit", "quit - quit the program",     cmd_quit},    {"rftp", "rftp filename strm1 strm2 blocksz [n] - round-trip ftp",     cmd_rftp},    {"rftp_stat", "rftp_stat - get stream status on read side of rftp and clear",     cmd_printrftpstat},        {"routes", "routes - Dump the routing table",     cmd_routes},    {"rwnd", "rwnd - get rwnds",     cmd_rwnd},    {"send", "send string [n] - send string to a peer if a peer is set [and retrans n times]",     cmd_send},    {"sendloop", "sendloop [num] - send test script loopback request of num size",     cmd_sendloop},    {"sendloopend", "sendloopend [num] - send test script loopback request of num size and terminate",     cmd_sendloopend},    {"sendreltlv", "sendreltlv num - send a rel-tlv of num bytes of data",     cmd_sendreltlv},    {"setbulkmode", "setbulkmode ascii/binary - set bulk transfer mode",     cmd_setbulkmode},    {"setdefcookielife", "setdefcookielife num - set default cookie life",     cmd_setdefcookielife},    {"setdefstream", "setdefstream num - set the default stream to",     cmd_setdefstream},    {"seterr", "seterr num - set the association send error thresh",     cmd_seterr},    {"sethost", "sethost host|X.Y.Z.A - set the destination host IP address",     cmd_sethost},    {"sethost6", "sethost6 host|xx:xx:xx...:xx - set the destination host IPv6 address",     cmd_sethost6},    {"setneterr", "setneterr net val - set the association network error thresh",     cmd_setneterr},    {"setopts", "setopts val - set options to specified value",     cmd_setopts},    {"setpay", "setpay payloadt - set the payload type",     cmd_setpay},    {"setport", "setport port - set the destination SCTP port number",     cmd_setport},    {"setprimary", "setprimary - set current ip address to the primary address",     cmd_setprimary},    {"setremprimary", "setremprimary address - set remote's primary address",     cmd_setremprimary},    {"setscope", "setscope num - Set the IPv6 scope id",     cmd_setscope},    {"setstreams", "setstreams numpreopenstrms - set the number of streams I request",     cmd_setstreams},    {"startmultping", "startmultping - start the defined ping pong contexts ",     cmd_startmultping},    {"tella", "tella host - confess what translateIPAddress returns",     cmd_tella},    {"term", "term - terminate the set destination association (graceful shutdown)",     cmd_term},    {"whereto", "whereto - tell where the default sends",     cmd_whereto},    {NULL, NULL, NULL}};/* XXX [MM] this is dirty */static sctpAdaptorMod *adap;int payload=0;int pingPongCount=0;char pingBuffer[SCTP_MAX_READBUFFER];int pingBufSize=0;int pingStream=0;int defStream = 0;distributor *dist;/* SCTP_PB */static SPingPongContext pingPongTable[MAX_PING_PONG_CONTEXTS];int pingPongsDefined=0;int bulkCount=0;int bulkBufSize=0;int bulkStream=0;int bulkSeen=0;struct sctpdataToProduce{  char string[8];  struct timeval sent;  struct timeval recvd;  struct timeval stored;  u_int seq;};static u_int curSeq=0;static int period = 20000;FILE *hulkfile=NULL;FILE *rftp_in1=NULL, *rftp_in2=NULL;FILE *rftp_out1=NULL, *rftp_out2=NULL;int rftp_strm1, rftp_strm2, rftp_bsz, rftp_rt;int rftp_ending1, rftp_ending2;/* how many message to read out at one time, max */#define LIMIT_READ_AT_ONCE 200extern int mainnotDone;extern int destinationSet;extern int portSet;extern int sendOptions;extern int bulkInProgress;extern int bulkPingMode;  /* wire test structures */typedef struct {    u_char  type;    u_char  padding;    u_short dgramLen;    u_long  dgramID;}testDgram_t;#define SCTP_TEST_LOOPREQ   1#define SCTP_TEST_LOOPRESP  2#define SCTP_TEST_SIMPLE    3#define SCTP_TEST_RFTP	    4#define SCTP_TEST_RFTPRESP  5char *namelist[]={  "SCTP_PEG_SACKS_SEEN",  "SCTP_PEG_SACKS_SENT",  "SCTP_PEG_TSNS_SENT",  "SCTP_PEG_TSNS_RCVD",  "SCTP_DATAGRAMS_SENT",  "SCTP_DATAGRAMS_RCVD",  "SCTP_RETRANTSN_SENT",  "SCTP_DUPTSN_RECVD",  "SCTP_HBR_RECV",  "SCTP_HBA_RECV",  "SCTP_HB_SENT",  "SCTP_DATA_DG_SENT",  "SCTP_DATA_DG_RECV",  "SCTP_TMIT_TIMER",  "SCTP_RECV_TIMER",  "SCTP_HB_TIMER",    "SCTP_FAST_RETRAN",  "SCTP_TSNS_READ",  "SCTP_NONE_LEFT_TOSEND",  "SCTP_NONE_LEFT_RWND_GATE",  "SCTP_NONE_LEFT_CWND_GATE",  "SCTP_SEND_STREAM_0",  "SCTP_SEND_STREAM_1",  "SCTP_SEND_STREAM_2",  "SCTP_SEND_STREAM_3",  "SCTP_SEND_STREAM_OTHER",  "SCTP_RECV_STREAM_0",  "SCTP_RECV_STREAM_1",  "SCTP_RECV_STREAM_2",  "SCTP_RECV_STREAM_3",  "SCTP_RECV_STREAM_OTHER",  "UNKNOWN"};struct routingAdaptor *ra=NULL;/*--------------------------------------------------*/void resetPingPongTable() {  int i;  for(i=0;i<MAX_PING_PONG_CONTEXTS;i++){    pingPongTable[i].stream = -1;    pingPongTable[i].nbRequests = 0;    pingPongTable[i].counter = 0;    pingPongTable[i].started = 0;    pingPongTable[i].blockAfter = 0;    pingPongTable[i].blockDuring = 0;    pingPongTable[i].blockTime = 0;  }  pingPongsDefined = 0;  return;}/*--------------------------------------------------*/void initPingPongTable(int max){  int i;    for(i=0;i<max;i++){    pingPongTable[i].stream = i;    pingPongTable[i].nbRequests = 2000;    pingPongTable[i].counter = 0;    pingPongTable[i].started = 0;    if(i == 2){      pingPongTable[i].blockAfter = 100;      pingPongTable[i].blockDuring = 3;    }else{      pingPongTable[i].blockAfter = 0;      pingPongTable[i].blockDuring = 0;    }    pingPongsDefined++;  }   return;}u_long translateIPAddress(char *host){  struct sockaddr_in sa;  struct hostent *hp;  int len,cnt,i;  sa.sin_addr.s_addr = htonl(inet_network(host));  len = strlen(host);  cnt = 0;  for(i=0;i<len;i++){    if(host[i] == '.')      cnt++;    else if(host[i] == ':')      cnt++;  }  if(cnt < 3){    /* make it fail since it can't be a . or : based address */    sa.sin_addr.s_addr = 0xffffffff;  }  if(sa.sin_addr.s_addr == 0xffffffff){    hp = gethostbyname(host);    if(hp == NULL){      return(htonl(strtoul(host,NULL,0)));    }    memcpy(&sa.sin_addr,hp->h_addr_list[0],sizeof(sa.sin_addr));  }  return(sa.sin_addr.s_addr);}voidfillPingBuffer(struct SCTP *m,int len){  u_int *pbp;  int i,rlen;  rlen = (len/4) + 1;  pbp = (u_int *)&pingBuffer[4];  for(i=0;i<rlen;i++){    *pbp = (u_int)mrand48();    pbp++;  }}intsendBulkTransfer(struct SCTP *m,int sz){  char buffer[10000];  testDgram_t *tt;  static unsigned int dgramCount=0;  int sndsz,ret;  if((sz+sizeof(testDgram_t)) > (sizeof(buffer))){    sndsz = sizeof(buffer) -  sizeof(testDgram_t);  }else{    sndsz = sz +  sizeof(sizeof(testDgram_t));  }  memset(buffer,0,sndsz);  tt = (testDgram_t *)buffer;  tt->type = SCTP_TEST_SIMPLE;  tt->dgramLen = sndsz - sizeof(testDgram_t);  tt->dgramID = dgramCount++;  ret = sctpSEND(m,defStream,buffer,sndsz,SCTP_getAddr(),sendOptions,payload,0);  return(ret);}voidcheckBulkTranfer(void *v,void *xxx){	  struct SCTP *m;  int ret,cnt;  int limit;  cnt = 0;  ret = 0;  m = (struct SCTP *)v;  limit = 0;  while(bulkCount > 0){    if(bulkPingMode == 0){      fillPingBuffer(m,(bulkBufSize-4));      ret = sctpSEND(m,bulkStream,pingBuffer,bulkBufSize,SCTP_getAddr(),sendOptions,0,0);    }else{      ret = sendBulkTransfer(m,bulkBufSize);    }    limit++;    if(ret < 0){      dist_TimerStart(dist,checkBulkTranfer,0,		      20000,v,xxx);      return;    }    if(limit > 400){      dist_TimerStart(dist,checkBulkTranfer,0,		      20000,v,xxx);      return;    }    cnt++;    bulkCount--;  }  /* ask for the time again */  if(bulkPingMode == 0){    strcpy(pingBuffer,"time");    ret = sctpSEND(m,bulkStream,pingBuffer,5,SCTP_getAddr(),sendOptions,0,0);    if(ret < 0){      printf("Could not get time in, will wait ret:%d\n",ret);      dist_TimerStart(dist,checkBulkTranfer,0,		      20000,v,xxx);      return;    }  }  bulkInProgress = 0;  printf("bulk message are now queued time q ret:%d\n",ret);}voidhandleMultiplePongs(struct SCTP *m, struct sockaddr *from, int theStream){  int    i, blocked = 0;  time_t now;      for(i = 0;i < MAX_PING_PONG_CONTEXTS;i++){    if(pingPongTable[i].stream == theStream){      pingPongTable[i].counter++;      if(pingPongTable[i].counter >= pingPongTable[i].nbRequests){	/* The party is finished */	time_t x;	struct tm *timeptr;	pingPongsDefined--;	x = time(0);	timeptr = localtime(&x);	printf("%s",asctime(timeptr));	printf("--> Stream %d: ping pong completed \n", theStream);	printf(">");	fflush(stdout);	pingPongTable[i].stream = -1;	pingPongTable[i].nbRequests = 0;	pingPongTable[i].counter = 0;	pingPongTable[i].started = 0;	pingPongTable[i].blockAfter = 0;	pingPongTable[i].blockDuring = 0;	pingPongTable[i].blockTime = 0;      }else{	if((pingPongTable[i].counter % 10) == 0){	  printf("--> Stream %d: sending ping %d \n",theStream,pingPongTable[i].counter);	  printf(">");	  fflush(stdout);	}	if(pingPongTable[i].blockAfter == pingPongTable[i].counter){	  printf("--> Stream %d: blocked at ping pong %d for %d seconds \n", 		 theStream, pingPongTable[i].counter, pingPongTable[i].blockDuring);	  printf(">");	  pingPongTable[i].blockTime = time(0);	  fflush(stdout);	}else{	  sctpSEND(m,theStream,pingBuffer,pingBufSize,from,sendOptions,0,0);  	}      }    }   }  /* Restart all candidate blocked streams */  for(i=0;i<MAX_PING_PONG_CONTEXTS;i++){    if(pingPongTable[i].blockTime != 0){      blocked++;    }  }  for(i=0;i<MAX_PING_PONG_CONTEXTS;i++){    if(pingPongTable[i].blockTime != 0){      /* blockTime set means that the context is blocked */      now = time(0);      if(now >= (pingPongTable[i].blockTime +  pingPongTable[i].blockDuring)){	pingPongTable[i].counter++;	pingPongTable[i].blockTime = 0; 	printf("--> Stream %d: unblocked after %d seconds \n", 	       pingPongTable[i].stream, pingPongTable[i].blockDuring);	printf(">");	sctpSEND(m,pingPongTable[i].stream,pingBuffer,pingBufSize,from,sendOptions,0,0);	blocked--;      }      if(pingPongsDefined <= blocked){	/* Hum: the remaining ping pongs are all blocked: we must force their unblocking, else	   they will never wake up */	pingPongTable[i].counter++;	pingPongTable[i].blockTime = 0;	printf("--> Stream %d: unblocked since the remaining %d streams are all blocked \n", 	       pingPongTable[i].stream, blocked);	printf(">");	sctpSEND(m,pingPongTable[i].stream,pingBuffer,pingBufSize,from,sendOptions,0,0);        }    }  }  return;}/*--------------------------------------------------*/voidSCTPdataTimerTicks(void *o,void *b){  int ret;  struct SCTP *m;  struct sctpdataToProduce dp;  m = (struct SCTP *)b;  memset(&dp,0,sizeof(dp));  strcpy(dp.string,"hulk");  dp.sent = dist->lastKnownTime;  dp.seq = curSeq;  curSeq++;  ret = sctpSEND(m,defStream,(char *)&dp,sizeof(dp),		 SCTP_getAddr(),sendOptions,payload,0);        if(ret < 0){    printf("Send failed? errno:%d\n",errno);    return;  }  /* Restart the timer */  dist_TimerStart(dist,		  SCTPdataTimerTicks, 		  0,period,o,b);}voidprintArry(unsigned char *data,int sz){  /* if debug is on hex dump a array */  int i,j,linesOut;  char buff1[64];  char buff2[64];  char *ptr1,*ptr2,*dptrlast,*dptr;  char *hexes = "0123456789ABCDEF";  ptr1 = buff1;  ptr2 = buff2;  dptrlast = dptr = (char *)data;  for(i=0,linesOut=0;i<sz;i++){    *ptr1++ = hexes[0x0f&((*dptr)>>4)];    *ptr1++ = hexes[0x0f&(*dptr)];    *ptr1++ = ' ';    if((*dptr >= 040) && (*dptr <= 0176))      *ptr2++ = *dptr;    else      *ptr2++ = '.';    dptr++;    if(((i+1) % 16) == 0){      *ptr1 = 0;      *ptr2 = 0;      printf("%s %s\n",buff1,buff2);      linesOut++;      ptr1 = buff1;      ptr2 = buff2;      dptrlast = dptr;    }  }  if((linesOut*16) < sz){    char spaces[64];    int dist,sp;    j=(linesOut*16);    dist = ((16 - (i - j)) * 3) + 2;    *ptr1 = 0;    *ptr2 = 0;    for(sp=0;sp<dist;sp++){      spaces[sp] = ' ';    }    spaces[sp] = 0;    printf("%s %s%s\n",buff1,spaces,buff2);  }  fflush(stdout);}static int str1Flow=0;static int str2Flow=0;voidsendRftpTransfer(void *v, void *xxx){  char cbuf[10000];  int bsz, readsz, ret1, ret2, sndsz;  testDgram_t *data;  int limit;  struct SCTP *m;  m = (struct SCTP *)v;  limit = 0;  if(rftp_bsz > 10000-sizeof(testDgram_t))    bsz = 10000-sizeof(testDgram_t);  else bsz = rftp_bsz;  data = (testDgram_t *)cbuf;  data->type = SCTP_TEST_RFTP;  while(1) {    /* do first stream */    if(rftp_ending1 == 0) {      readsz = fread((void *)(cbuf+sizeof(testDgram_t)), 1, bsz, rftp_in1);      if(readsz == 0) rftp_ending1 = 1;    } else {      readsz = 0;      if(++rftp_ending1 == 5) {	printf("read done for stream %d\n",rftp_strm1);	fclose(rftp_in1);      }    }    if(rftp_ending1 <= 5){      data->dgramLen = readsz;      sndsz = readsz + sizeof(testDgram_t);      ret1 = sctpSEND(m,rftp_strm1,cbuf,sndsz,SCTP_getAddr(),sendOptions,payload,rftp_rt);      if(ret1 < 0) {	str1Flow++;	if(readsz > 0) 	  fseek(rftp_in1, (-1 * (long)readsz), SEEK_CUR); /* rewind position */	break;      } else {	limit++;      }    }    /* do second stream */    if(rftp_ending2 == 0) {      readsz = fread((void *)(cbuf+sizeof(testDgram_t)), 1, bsz, rftp_in2);      if(readsz == 0) rftp_ending2 = 1;    } else {      readsz = 0;      if(++rftp_ending2 == 5) {	printf("read done for stream %d\n", rftp_strm2); 	fclose(rftp_in2);      }    }    if(rftp_ending2 <= 5){      data->dgramLen = readsz;      sndsz = readsz + sizeof(testDgram_t);      ret2 = sctpSEND(m,rftp_strm2,cbuf,sndsz,SCTP_getAddr(),sendOptions,payload,rftp_rt);      if(ret2 < 0) {	str2Flow++;	if(readsz > 0)	  fseek(rftp_in2, (-1 * (long)readsz), SEEK_CUR); /* rewind position */	break;      } else {	limit++;      }    }    if(rftp_ending1 >= 5 && rftp_ending2 >= 5) {      printf("Transfer to send queues complete s1flow:%d s2flow:%d\n",	     str1Flow,str2Flow);      return;    }  }  if(rftp_ending1 >= 5 && rftp_ending2 >= 5) {    printf("Transfer 2 send queues complete\n");    return;  }  dist_TimerStart(dist,sendRftpTransfer,0,20000,v,xxx);}voidhandleRftpTransfer(struct SCTP *m, messageEnvolope *msg){  int ret;  char *dat;  int wrtSz;  dat = (char *)((u_long)msg->data + sizeof(testDgram_t));  wrtSz = msg->siz - sizeof(testDgram_t);  if(msg->streamNo == rftp_strm1) {    if(wrtSz > 0) {      ret = fwrite((void *)dat, 1, wrtSz, rftp_out1);      if(ret != wrtSz) {	printf("write to strm 1 file incomplete\n");      }    } else {      if(rftp_out1) {	fclose(rftp_out1);	rftp_out1 = NULL;	printf("done rcv strm %d\n", rftp_strm1);      }    }  }else if(msg->streamNo == rftp_strm2) {    if(wrtSz > 0) {      ret = fwrite((void *)dat, 1, wrtSz, rftp_out2);      if(ret != wrtSz) {	printf("write to strm 2 file incomplete\n");      }    } else {      if(rftp_out2) {	fclose(rftp_out2);	rftp_out2 = NULL;	printf("done rcv strm %d\n", rftp_strm2);      }    }  }else {    printf("RFTP bad stream num %d!\n",msg->streamNo);  }}intsendLoopRequest(struct SCTP *m,int sz){  char buffer[15000];  testDgram_t *tt;  static unsigned int dgramCount=0;  int sndsz,ret;  if((sz+sizeof(testDgram_t)) > (sizeof(buffer))){    sndsz = sizeof(buffer) -  sizeof(testDgram_t);  }else{    sndsz = sz +  sizeof(sizeof(testDgram_t));  }  memset(buffer,0,sizeof(buffer));  tt = (testDgram_t *)buffer;  tt->type = SCTP_TEST_LOOPREQ;  tt->dgramLen = sndsz - sizeof(testDgram_t);  tt->dgramID = dgramCount++;  ret = sctpSEND(m,defStream,buffer,sndsz,SCTP_getAddr(),sendOptions,payload,0);        return(ret);}voidhandlePong(struct SCTP *m,struct sockaddr *from,int mode){  pingPongCount--;  if(pingPongCount <= 0){    /* done */    time_t x;    struct tm *timeptr;    x = time(0);    timeptr = localtime(&x);    printf("%s",asctime(timeptr));    printf("--Ping pong completes\n");    fflush(stdout);    return;  }  if(mode == 0){    sctpSEND(m,pingStream,pingBuffer,pingBufSize,from,sendOptions,0,0);    }else{    sendLoopRequest(m,pingBufSize);  }}voiddoPingPong(struct SCTP *m){  time_t x;  int i;  struct tm *timeptr;  if(bulkPingMode == 0){    /* use ascii bulk ping mode.*/    strncpy(pingBuffer,"ping",4);    for(i=4;i<pingBufSize;i++){      pingBuffer[i] = 'A' + (i%26);    }    sctpSEND(m,pingStream,pingBuffer,pingBufSize,SCTP_getAddr(),sendOptions,payload,0);        }else{     /* use binary bulk ping mode */    sendLoopRequest(m,pingBufSize);  }  x = time(0);  timeptr = localtime(&x);  printf("%s",asctime(timeptr));}voidhandleHulk(struct SCTP *m,	   struct sockaddr *to,	   struct sctpdataToProduce *dp){  int ret;  strcpy(dp->string,"sulk");  dp->recvd = dist->lastKnownTime;  ret = sctpSEND(m,defStream,(char *)dp,sizeof(*dp),		 to,sendOptions,payload,0);  if(ret < 0){    printf("Could not reply to a hulk with a sulk! %d:%d\n",	   ret,errno);  }}static int str1read=0;static int str2read=0;voidsctpInput(void *arg,messageEnvolope *msg){  /* receive some number of datagrams and   * act on them.   */  int disped,i;  struct SCTP *m;  testDgram_t *testptr;  disped = i = 0;  SCTP_setcurrent((sctpAdaptorMod *)arg);  if(msg->type == PROTOCOL_Sctp){    m = (struct SCTP *)msg->sender;  }else{    /* we don't deal with non-sctp data */    return;  }  testptr = (testDgram_t *)msg->data;  if(testptr->type == SCTP_TEST_LOOPREQ){    /* another ping/pong type */    testptr->type = SCTP_TEST_LOOPRESP;    sctpSEND(m,msg->streamNo,msg->data,msg->siz,(struct sockaddr *)msg->from,	     sendOptions,	     msg->protocolId,0);    msg->data = NULL;  }else if(testptr->type == SCTP_TEST_LOOPRESP){    handlePong(m,(struct sockaddr *)msg->from,1);    msg->data = NULL;  }else if(testptr->type == SCTP_TEST_SIMPLE){    msg->data = NULL;  }else if(testptr->type == SCTP_TEST_RFTP){    /* send the data back */    testptr->type = SCTP_TEST_RFTPRESP;    if(msg->streamNo == 1){      str1read++;    }else{      str2read++;    }    sctpSEND(m,msg->streamNo,msg->data,msg->siz,(struct sockaddr *)msg->from,	     sendOptions, msg->protocolId,0);    msg->data = NULL;  }else if(testptr->type == SCTP_TEST_RFTPRESP){    handleRftpTransfer(m, msg);    msg->data = NULL;  }else if(strncmp(msg->data,"ping",4) == 0){    /* it is a ping-pong message, send it back after changing     * the first 4 bytes to pong      */    strncpy(msg->data,"pong",4);    sctpSEND(m,msg->streamNo,msg->data,msg->siz,(struct sockaddr *)msg->from,	     sendOptions,	     msg->protocolId,0);    msg->data = NULL;  }else if(strcmp(msg->data,"time") == 0){    time_t x;    struct tm *timeptr;    x = time(0);    timeptr = localtime(&x);    printf("%s",asctime(timeptr));    msg->data = NULL;    bulkSeen = 0;  }else if(strncmp(msg->data,"pong",4) == 0){    if(pingPongsDefined > 0){      handleMultiplePongs(m,(struct sockaddr *)msg->from,msg->streamNo);    }else{      handlePong(m,(struct sockaddr *)msg->from,0);    }  }else if(strncmp(msg->data,"hulk",4) == 0){    handleHulk(m,(struct sockaddr *)msg->from,	       (struct sctpdataToProduce *)msg->data);    msg->data = NULL;  }else if(strncmp(msg->data,"sulk",4) == 0){    if(hulkfile != NULL){      struct sctpdataToProduce *dp;      dp = (struct sctpdataToProduce *)msg->data;      dp->stored = dist->lastKnownTime;      fwrite(msg->data,sizeof(struct sctpdataToProduce),1,hulkfile);    }    msg->data = NULL;  }else if(strncmp(msg->data,"bulk",4) == 0){    bulkSeen++;  }else{    /* display a text message */    if(isascii(((char *)msg->data)[0])){      printf("From:");      SCTPPrintAnAddress(msg->from);      printf("To:");      SCTPPrintAnAddress(msg->to);      printf("strm:%d seq:%d %d:'%s'\n",	     msg->streamNo,	     msg->streamSeq,	     msg->siz,	     (char *)msg->data);      disped = 1;      msg->data = NULL;    }else{      printf("From:");      SCTPPrintAnAddress(msg->from);      printf("To:");      SCTPPrintAnAddress(msg->to);      printf("strm:%d seq:%d %d:\n",	     msg->streamNo,	     msg->streamSeq,	     msg->siz);      printArry((char *)msg->data,msg->siz);      msg->data = NULL;      disped = 1;    }  }  if(disped){    printf(">");    fflush(stdout);  }}/* * Called with a complete line of input by the readline library. */static voidhandleStdin2(char *line){    if (line == NULL || *line == '\0')        return;    execute_line(line);    add_history(line);    free(line);}/* To be used when libreadline isn't available */#if 0static voidhandleStdin_nolibreadline(void){    /* Algorithm:     *     * read imput line     * cmd = find_command(line)     * if cmd != NULL     *     execute item.command     * else     *     print "command not found"     */}#endif/* receive USER input and act upon it.  * * OLD parser, before libreadline was introduced.  * Please do no touch this function, to add new commands see the explanation  * in the commit log. * To be removed and substituted by handleStdin_nolibreadline() when * we are sure that libreadline works ok. */voidhandleStdin(sctpAdaptorMod *mod){  struct SCTP *m;  int lenread;  char readBuffer[256];  m = mod->m;  SCTP_setcurrent(mod);  fgets(readBuffer,256,stdin);  lenread = strlen(readBuffer);  if(readBuffer[(lenread-1)] == '\n'){    readBuffer[(lenread-1)] = 0;  }  payload = 0;  if(lenread == 0){    printf(">");    fflush(stdout);    return;  }  if(strcmp(readBuffer,"help") == 0){    printf("Available commands are:\n");    printf(" assoc - associate with the set destination\n");    printf(" addip,address,how - add ip address where how is the mask/action to pass\n");    printf("                     SCTP_ACTION_UPDATE_ALL_ASSOC=0x1\n");    printf("                     SCTP_ACTION_UPDATE_ENDPOINT =0x02\n");    printf("                     SCTP_ACTION_UPDATE_ONLY_ASSOC =0x04\n");    printf("                     SCTP_ACTION_QUEUE_REQUEST_ONLY	=0x08\n");    printf("                     (which can all be or'd together if you want)\n");    printf(" bulk:size:stream:number - send a bulk of messages\n");    printf(" bulkseen - Display count of bulk packets seen (time resets)\n");    printf(" chgcookielife:val  - change the current assoc cookieLife\n");    printf(" clearpegs - clear the peg counts\n");    printf(" continual:flagval - set continuous init to n times\n");    printf(" defretryi:num - set a new association failure threshold for initing\n");    printf(" defretrys:num - set a new association failure threshold for sending\n");    printf(" defrwnd:num - set the default rwnd of the SCTP\n");    printf(" doheartbeat - preform a on demand HB\n");    printf(" delip,address,how - delete ip address where how is the mask/action to pass\n");    printf(" disablev6:bool - Disable V6 set flag to bool (0 or 1)\n");    printf(" hulkstart:filename - start the hulk hogan process\n");    printf(" hulkstop - stop the hulk hogan process\n");    printf(" getcurcookielife  - display current assoc cookieLife\n");    printf(" getdefcookielife - display default cookie life\n");    printf(" getfsids:prntlimit - print prntlimit fsid entries\n");    printf(" gethbdelay - get the hb delay\n");    printf(" getpegs - retrieve the peg counts\n");    printf(" getprimary - tells which net number is primary\n");    printf(" getrtt - Return the RTO of the current default address of the assoc\n");    printf(" heart:on/off - Turn HB on or off  to the destination\n");    printf(" heartdelay:time - Add number of seconds + RTO to hb interval\n");    printf(" help - get this menu\n");    printf(" initmultping - init contexts for a fast test\n");    printf(" inqueue - report inqueue counts\n");    printf(" multping:size:str:times:blockafter:sec  - add a ping pong context and block after\n");    printf("                                         <blockafter> instances for <sec> seconds \n");    printf(" ping:size:stream:times - play ping pong\n");    printf(" quit - exit the program\n");    printf(" netstats - return all network stats\n");    printf(" routes - Dump the routing table\n");    printf(" rwnd - get rwnds\n");    printf(" sendloop:N - send test script loopback request of N size\n");    printf(" sendloopend:N - send test script loopback request of N size and terminate\n");    printf(" sendreltlv:N - send a rel-tlv of N bytes of data\n");    printf(" setbpmode:ascii - set bulk transfer mode to ascii\n");    printf(" setbpmode:binary - set bulk transfer mode to binary\n");    printf(" setdefcookielife:N - set default cookie life\n");    printf(" setdefstrm:num - set the default stream to\n");    printf(" seterr:num - set the association send error thresh\n");    printf(" sethost:host/X.Y.Z.A - set the destination host IP address\n");    printf(" sethost6:host/xx:xx:xx...:xx - set the destination host IPv6 address\n");    printf(" setneterr:net:num - set the association network error thresh\n");    printf(" setopts:val    - set options to specified value\n");    printf(" setpay:payloadt - set the payload type\n");    printf(" setport:port   - set the destination SCTP port number\n");    printf(" setprimary     - set current ip address to the primary address\n");    printf(" setremprimary,ipv4 or ipv6 addr - set remote's primary address\n");    printf(" setscope:num - Set the IPv6 scope id\n");    printf(" setstrms:numpreopenstrms - set the number of strms I request\n");    printf(" startmultping - start the defined ping pong contexts \n");    printf(" tella:host - confess what translateIPAddress returns\n");    printf(" term - terminate the set destination association (graceful shutdown )\n");    printf(" whereto - tell where the default sends\n");    printf("\n");    printf(" any-other-string - send this to a peer if a peer is set\n");  }else if(strcmp(readBuffer,"hulkstop") == 0){    curSeq = 0;    if(hulkfile != NULL)      fclose(hulkfile);    hulkfile = NULL;    dist_TimerStop(dist,		   SCTPdataTimerTicks, 		      (void *)NULL,(void *)m);      }else if(strncmp(readBuffer,"hulkstart:",10) == 0){    if(strlen(&readBuffer[10]) < 1){      printf("Gak, no file name\n");      printf(">");      fflush(stdout);      return;    }    hulkfile = fopen(&readBuffer[10],"w+");    if(hulkfile != NULL){      printf("hulk scheduler begun\n");      dist_TimerStart(dist,		      SCTPdataTimerTicks, 		      0,period,(void *)NULL,(void *)m);    }else{      printf("Can't open file err:%d for file '%s'\n",	     errno,&readBuffer[10]);    }  }else if(strncmp(readBuffer,"disablev6:",10) == 0){    int x,y;    x = strtol(&readBuffer[10],NULL,0);    y = sctpSETV6DISABLE(m,x);    printf("Disable v6 set to %d it was at %d\n",	   x,y);  }else if(strncmp(readBuffer,"addip,",6) == 0){    struct sockaddr_in newaddr;    struct sockaddr_in6 newaddr6;    struct sockaddr *addthis;    void *filladdr;    int flag,ret,i,len;    char *addressp,*next;    filladdr = NULL;    /* first insert a : at the end */    ret = strlen(readBuffer);    readBuffer[ret] = ',';    readBuffer[(ret+1)] = 0;    memset((char *)&newaddr,0,sizeof(newaddr));    addressp = strtok(&readBuffer[6],",");    if(addressp == NULL){      printf("syntax error\n");      printf(">");      fflush(stdout);      return;    }    next = strtok(NULL,":");    if(next == NULL){      printf("syntax error\n");      printf(">");      fflush(stdout);      return;    }    addthis = NULL;    flag = strtol(next,NULL,0);    len = strlen(addressp);    for(i=0;i<len;i++){      if(addressp[i] == '.'){	newaddr.sin_port = 0;	newaddr.sin_family = AF_INET;#ifdef USES_BSD_4_4_SOCKET	newaddr.sin_len =  sizeof(struct sockaddr_in);#endif		addthis = (struct sockaddr *)&newaddr;	filladdr = (void *)&newaddr.sin_addr;      }else if(addressp[i] == ':'){	newaddr6.sin6_port = 0;	newaddr6.sin6_family = AF_INET6;#ifdef USES_BSD_4_4_SOCKET	newaddr6.sin6_len =  sizeof(struct sockaddr_in6);#endif		addthis = (struct sockaddr *)&newaddr6;	filladdr = (void *)&newaddr6.sin6_addr;      }    }    if(addthis == NULL){      printf("Unable to determine type of '%s' no : or .\n",	     addressp);      printf(">");      fflush(stdout);      return;    }    if(inet_pton(addthis->sa_family,addressp,filladdr) != 1){      printf("inet_pton fails to translate '%s'\n",	     addressp);      printf(">");      fflush(stdout);      return;    }    printf("Add IP address %s action=%x\n",addressp,flag);    ret = sctpADDIPADDRESS(m,addthis,SCTP_getAddr(),flag);    printf("Add call returns %d\n",ret);  }else if(strcmp(readBuffer,"bulkseen") == 0){    printf("bulk seen is %d\n",bulkSeen);  }else if(strncmp(readBuffer,"delip,",6) == 0){    struct sockaddr_in newaddr;    struct sockaddr_in6 newaddr6;    struct sockaddr *delthis;    void *filladdr;    int flag,ret,i,len;    char *addressp,*next;    /* first insert a : at the end */    filladdr = NULL;    ret = strlen(readBuffer);    readBuffer[ret] = ',';    readBuffer[(ret+1)] = 0;    memset((char *)&newaddr,0,sizeof(newaddr));    addressp = strtok(&readBuffer[6],",");    if(addressp == NULL){      printf("syntax error\n");      printf(">");      fflush(stdout);      return;    }    next = strtok(NULL,",");    if(next == NULL){      printf("syntax error\n");      printf(">");      fflush(stdout);      return;    }    flag = strtol(next,NULL,0);    len = strlen(addressp);    delthis = NULL;    for(i=0;i<len;i++){      if(addressp[i] == '.'){	newaddr.sin_port = 0;	newaddr.sin_family = AF_INET;#ifdef USES_BSD_4_4_SOCKET	newaddr.sin_len =  sizeof(struct sockaddr_in);#endif		delthis = (struct sockaddr *)&newaddr;	filladdr = (void *)&newaddr.sin_addr;      }else if(addressp[i] == ':'){	newaddr6.sin6_port = 0;	newaddr6.sin6_family = AF_INET6;#ifdef USES_BSD_4_4_SOCKET	newaddr6.sin6_len =  sizeof(struct sockaddr_in6);#endif		delthis = (struct sockaddr *)&newaddr6;	filladdr = (void *)&newaddr6.sin6_addr;      }    }    if(delthis == NULL){      printf("Unable to determine type of '%s' no : or .\n",	     addressp);      printf(">");      fflush(stdout);      return;    }    if(inet_pton(delthis->sa_family,addressp,filladdr) != 1){      printf("inet_pton fails to translate '%s'\n",	     addressp);      printf(">");      fflush(stdout);      return;    }    ret = sctpDELIPADDRESS(m,delthis,SCTP_getAddr(),flag);    printf("Del call returns %d\n",ret);  }else if(strcmp(readBuffer,"routes") == 0){    if(ra != NULL)      printRoutingTable(ra);    else      printf("Sorry, routing adaptor not setup\n");  }else if(strncmp(readBuffer,"setremprimary,",14) == 0){    struct sockaddr_in newaddr;    struct sockaddr_in6 newaddr6;    struct sockaddr *setthis;    void *filladdr;    int ret,i,len;    char *addressp;    addressp = &readBuffer[14];    filladdr = NULL;    setthis = NULL;    len = strlen(addressp);    for(i=0;i<len;i++){      if(addressp[i] == '.'){	newaddr.sin_port = 0;	newaddr.sin_family = AF_INET;#ifdef USES_BSD_4_4_SOCKET	newaddr.sin_len =  sizeof(struct sockaddr_in);#endif		setthis = (struct sockaddr *)&newaddr;	filladdr = (void *)&newaddr.sin_addr;      }else if(addressp[i] == ':'){	newaddr6.sin6_port = 0;	newaddr6.sin6_family = AF_INET6;#ifdef USES_BSD_4_4_SOCKET	newaddr6.sin6_len =  sizeof(struct sockaddr_in6);#endif		setthis = (struct sockaddr *)&newaddr6;	filladdr = (void *)&newaddr6.sin6_addr;      }    }    if(setthis == NULL){      printf("Unable to determine type of '%s' no : or .\n",	     addressp);      printf(">");      fflush(stdout);      return;    }    if(inet_pton(setthis->sa_family,addressp,filladdr) != 1){      printf("inet_pton fails to translate '%s'\n",	     addressp);      printf(">");      fflush(stdout);      return;    }    ret = sctpREMOTESETPRIMARY(m,setthis,SCTP_getAddr(),0);    printf("Set remote primary call returns %d\n",ret);  }else if(strcmp(readBuffer,"getprimary") == 0){    printf("The primary address is %d\n",sctpGETPRIMARY(m,SCTP_getAddr()));  }else if(strncmp(readBuffer,"sendreltlv:",11) == 0){    int sz,ret;    char *xxx;    struct sctpParamDesc *TLVout;    struct SCTP_association *asoc;    struct sockaddr *add;    /* This is actually a violation, we are calling a module that we     * really should not.. but this is so we can do     * a test by dumpping inqueue anything we want for a REL-REQ.     */    add = SCTP_getAddr();    asoc = SCTPfindAssociation(m, (struct sockaddr *)add, &sz);    if(asoc == NULL){      printf("sorry can't find the association\n");      printf(">");      fflush(stdout);      return;    }    sz = strtol(&readBuffer[11],NULL,0);    sz += sizeof(struct sctpParamDesc);    xxx = calloc(1,sz);    TLVout = (struct sctpParamDesc *)xxx;    if(TLVout != NULL){      u_short val,len,i;      printf("TLV value:");      fflush(stdout);      fgets(readBuffer,256,stdin);            val = (u_short)strtol(readBuffer,NULL,0);      len = sz;      TLVout->paramType = htons(val);      TLVout->paramLength = htons(len);      for(i=0,len=sizeof(struct sctpParamDesc);len<sz;len++,i++){	printf("Value for byte %d (0-255)",i);	fflush(stdout);	fgets(readBuffer,256,stdin);	val = strtol(readBuffer,NULL,0);	if(val > 255){	  printf("Error input:%d to big, replacing with 255\n",val);	  xxx[len] = 255;	}else{	  xxx[len] = val;	}      }      printf("Delayed send (y, n, e, def=n):");      fflush(stdout);      fgets(readBuffer,256,stdin);            if(readBuffer[0] == 'y'){	ret = SCTPqueueARelReq(m,asoc,TLVout,1);      }else{	struct sctpParamDesc *TLVout2;		TLVout2 = NULL;	if(readBuffer[0] == 'e'){		  xxx = calloc(1,sz);	  if(xxx != NULL){	    memcpy(xxx,(char *)TLVout,sz);	  }	  TLVout2 = (struct sctpParamDesc *)xxx;	}	ret = SCTPqueueARelReq(m,asoc,TLVout,0);	/* echo out a copy again to queue */	if(TLVout2 != NULL){	  ret = SCTPqueueARelReq(m,asoc,TLVout2,0);	}      }      printf("Queue of REL-REQ returns %d\n",ret);      if(ret < 0){	free(xxx);      }    }else{      printf("Sorry malloc failed.. queue fails\n");    }  }else if(strncmp(readBuffer,"setprimary",10) == 0){    sctpSETPRIMARY(m,SCTP_getAddr());    printf("Primary address set to ");    SCTPPrintAnAddress(SCTP_getAddr());  }else if(strncmp(readBuffer,"getfsids:",9) == 0){    int *fp1, *fp2, *fp3, *fp4, *fp5;    int len,i;    fp1 = sctpGETFSID(m,SCTP_getAddr(),0);    fp2 = sctpGETFSID(m,SCTP_getAddr(),1);    fp3 = sctpGETFSID(m,SCTP_getAddr(),2);    fp4 = sctpGETFSID(m,SCTP_getAddr(),3);    fp5 = sctpGETFSID(m,SCTP_getAddr(),4);    if((fp1 != NULL) ||       (fp2 != NULL) ||       (fp3 != NULL) ||       (fp4 != NULL) ||       (fp5 != NULL)){      len = strtol(&readBuffer[9],NULL,0);      if(len > MAX_FSID)	len = MAX_FSID;	printf("totalflt:peerrwnd:cwnd    :numseeni:gate\n");	for(i=0;i<len;i++){	  printf("%8.8d:%8.8d:%8.8d:%8.8d:%8.8d\n",		 fp1[i],		 fp2[i],		 fp3[i],		 fp4[i],		 fp5[i]);	}    }else{      printf("Sorry, a null came back\n");    }  }else if(strncmp(readBuffer,"sendloopend:",12) == 0){    int x;    x = (int)strtol(&readBuffer[12],NULL,0);    if(x == 0){      printf("N was 0? defaulting to 64\n");      x = 64;    }    printf("Send loop request returns:%d\n",sendLoopRequest(m,x));        sctpTERMINATE(m,SCTP_getAddr());    printf("Sent loop and termintate queued\n");  }else if(strncmp(readBuffer,"sendloop:",9) == 0){    int x,ret;    x = (int)strtol(&readBuffer[9],NULL,0);    if(x == 0){      printf("N was 0? defaulting to 64\n");      x = 64;    }    ret = sendLoopRequest(m,x);    printf("Sent loop returned %d\n",ret);  }else if(strcmp(readBuffer,"getcurcookielife") == 0){    printf("Current cookie life is %d seconds\n",	   sctpGET_CURCOOKIELIFE(m,SCTP_getAddr()));  }else if(strcmp(readBuffer,"getdefcookielife") == 0){    printf("Default cookie life is %d seconds\n",	   sctpGET_DEFCOOKIELIFE(m));  }else if(strncmp(readBuffer,"setpay:",7) == 0){    payload = strtol(&readBuffer[10],NULL,0);    printf("payloadtype set to %d\n",payload);  }else if(strncmp(readBuffer,"continual:",10) == 0){    int x,y;    x = strtol(&readBuffer[10],NULL,0);    y = SCTP_setContinualInit(x);    printf("continual INIT set to %d\n",y);  }else if(strncmp(readBuffer,"chgcookielife:",14) == 0){    int val;    val = strtol(&readBuffer[14],NULL,0);    if(val == 0){      printf("sorry can't set cookie life to 0\n");    }else{      int old;      old = sctpCHANGE_COOKIELIFE(m,SCTP_getAddr(),val);      if(old > 0){	printf("I set cookie life to %d it was %d\n",val,old);      }else{	printf("Could not set cookielife, have you a asoc up yet?\n");      }    }  }else if(strncmp(readBuffer,"tella:",6) == 0){    u_long x;    x = ntohl(translateIPAddress(&readBuffer[6]));    printf("Address is %d.%d.%d.%d\n",	   (int)((x>>24) & 0x000000ff),	   (int)((x>>16) & 0x000000ff),	   (int)((x>>8) & 0x000000ff),	   (int)(x & 0x000000ff)	   );  }else if(strcmp(readBuffer,"whereto") == 0){    struct sockaddr *to;    printf("Currently sending to:");    to = SCTP_getAddr();    SCTPPrintAnAddress(to);  }else if(strcmp(readBuffer,"quit") == 0){    /* print no prompt, we are out of here once all     * datagrams de-queue     */    dist_setDone(dist);    return;  }else if(strncmp(readBuffer,"rwnd",4) == 0){    int rwnd,myrwnd;    myrwnd = sctpGET_MY_RWND(m,SCTP_getAddr());    rwnd = sctpGET_PEERS_RWND(m,SCTP_getAddr());    printf("My rwnd:%d peers rwnd:%d\n",	   myrwnd,rwnd);  }else if(strncmp(readBuffer,"heart:",6) == 0){    if(strncmp(&readBuffer[6],"off",3) == 0){      sctpSETHB(m,SCTP_getAddr(),0);    }else{      sctpSETHB(m,SCTP_getAddr(),1);    }  }else if(strcmp(readBuffer,"getrtt") == 0){    printf("RTT of TO is %d\n",sctpGETRTTREPORT(m,SCTP_getAddr()));  }else if(strncmp(readBuffer,"defrwnd:",8) == 0){    int newrwnd;    newrwnd = strtol(&readBuffer[8],NULL,0);    sctpSetRwindowSize(m,newrwnd);  }else if(strncmp(readBuffer,"defretrys:",10) == 0){    int newrtry;    newrtry = strtol(&readBuffer[10],NULL,0);    sctpSetRetryCount(m, SCTP_MAXATTEMPT_SEND , newrtry);  }else if(strncmp(readBuffer,"defretryi:",10) == 0){    int newrtry;    newrtry = strtol(&readBuffer[10],NULL,0);    sctpSetRetryCount(m, SCTP_MAXATTEMPT_INIT , newrtry);  }else if(strcmp(readBuffer,"doheartbeat") == 0){    int ret;    ret = sctpREQUESTHEARTBEAT(m,SCTP_getAddr());    printf("Request returns %d\n",ret);  }else if(strncmp(readBuffer,"heartdelay:",11) == 0){    int newdelay;    newdelay = strtol(&readBuffer[11],NULL,0);    sctpCHANGEHEARTBEAT(m,SCTP_getAddr(),newdelay);  }else if(strcmp(readBuffer,"gethbdelay") == 0){    printf("HB delay is %d plus RTT\n",sctpGETHEARTBEATDELAY(m,SCTP_getAddr()));  }else if(strcmp("inqueue",readBuffer) == 0){    printf("Outbound queue count to dest = %d\n",sctpHOWMANYINQUEUE(m,SCTP_getAddr()));    printf("Inbound queue count = %d\n",sctpHOWMANYINBOUND(m));  }else if(strcmp("term",readBuffer) == 0){    if(m != NULL)      sctpTERMINATE(m,SCTP_getAddr());    else      printf("sorry m is NULL?\n");  }else if(strncmp("setstrms:",readBuffer,9) == 0){    int preOpenStrm;    preOpenStrm = strtol(&readBuffer[9],NULL,0);    sctpSetOutStream(m, preOpenStrm);  }else if(strcmp("assoc",readBuffer) == 0){	  if(m != NULL){		  printf("Init to address\n");		  SCTPPrintAnAddress(SCTP_getAddr());		  sctpASSOCIATE(m,SCTP_getAddr(),0);	  }    else      printf("sorry m is NULL?\n");  }else if(strncmp("ping:",readBuffer,5) == 0){    char *end,*nxt;    int skip;    skip = 0;    if(pingPongCount){      printf("Sorry ping-pong already in progress\n");      printf(">");      fflush(stdout);      return;    }    pingBufSize = strtol(&readBuffer[5],&end,0);    if(end != NULL){      if(*end != ':'){	skip = 1;      }    }else{      skip = 1;    }    if(pingBufSize > SCTP_MAX_READBUFFER ){      printf("%d is to large, override to largest I can handle %d\n",	     pingBufSize,SCTP_MAX_READBUFFER);      pingBufSize = SCTP_MAX_READBUFFER;    }    if(skip){      printf("mal-formed request at size\n");      printf(">");      fflush(stdout);      return;    }    nxt = end;    nxt++;    pingStream = strtol(nxt,&end,0);    if(end != NULL){      if(*end != ':'){	skip = 1;      }    }else{      skip = 1;    }    if(skip){      printf("mal-formed request stream\n");      printf(">");      fflush(stdout);      return;    }        nxt = end;    nxt++;    pingPongCount = strtol(nxt,NULL,0);    if(pingPongCount == 0){      printf("mal-formed request at times\n");      printf(">");      fflush(stdout);      return;    }    /* prepare ping buffer */    printf("Starting PING size:%d stream:%d\n",pingBufSize,pingStream);    doPingPong(m);  }else if(strncmp("setbpmode:a",readBuffer,11) == 0){    bulkPingMode = 0;    printf("bulk/ping transfer set to ascii mode\n");  }else if(strncmp("setbpmode:b",readBuffer,11) == 0){    bulkPingMode = 1;    printf("bulk/ping transfer set to binary mode\n");  }else if(strncmp("bulk:",readBuffer,5) == 0){    int ret;    char *end,*nxt;    int skip;    skip = 0;    if(bulkInProgress){      printf("sorry bulk already in progress\n");      printf(">");      fflush(stdout);    }    bulkBufSize = strtol(&readBuffer[5],&end,0);    if(end != NULL){      if(*end != ':'){	skip = 1;      }    }else{      skip = 1;    }    if(bulkBufSize > SCTP_MAX_READBUFFER ){      printf("%d is to large, override to largest I can handle %d\n",	     pingBufSize,SCTP_MAX_READBUFFER);      skip = 1;    }else if(bulkBufSize < 1){      printf("Can't send 0 size\n");      skip = 1;    }        if(skip){      printf("mal-formed request at size\n");      printf(">");      fflush(stdout);      return;    }    nxt = end;    nxt++;    bulkStream = strtol(nxt,&end,0);    if(end != NULL){      if(*end != ':'){	skip = 1;      }    }else{      skip = 1;    }    if(skip){      printf("mal-formed request stream\n");      printf(">");      fflush(stdout);      return;    }        nxt = end;    nxt++;    bulkCount = strtol(nxt,NULL,0);    if(bulkCount == 0){      printf("mal-formed request at times\n");      printf(">");      fflush(stdout);      return;    }    /* prepare ping buffer */        /* ask for the time */    if(bulkPingMode == 0){      strcpy(pingBuffer,"time");      ret = sctpSEND(m,bulkStream,pingBuffer,5,SCTP_getAddr(),sendOptions,payload,0);      strncpy(pingBuffer,"bulk",4);    }    bulkInProgress = 1;    checkBulkTranfer(m,NULL);    if(bulkCount == 0){      printf("bulk message are now queued\n");    }else{      printf("bulk transfer now in progress\n");    }  }else if ( strcmp("initmultping", readBuffer) == 0 ) {    initPingPongTable(sctpGETNUMOUTSTREAMS(m,SCTP_getAddr()));    printf("%d ping pong contexts are defined \n", pingPongsDefined);    printf("Type startmultping to proceed \n");    fflush(stdout);    return;  }else if(strncmp("multping:", readBuffer, 9) == 0){    char *end,*nxt;    int  i, myPingCount = 0, myPingStream = 0, myBlockAfter = 0, myBlockDuring = 0;    /* Buffer size */    pingBufSize = strtol(&readBuffer[9], &end, 0);        if(end != NULL){       if(*end != ':'){	printf("Getting buffer size \n");	printf("mal-formed request \n");	printf(">");	fflush(stdout);	return;      }     }else{      printf("Getting buffer size \n");      printf("mal-formed request \n");      printf(">");      fflush(stdout);      return;    }    if(pingBufSize > SCTP_MAX_READBUFFER ){      printf("%d is to large, override to largest I can handle %d\n",	     pingBufSize,SCTP_MAX_READBUFFER);      pingBufSize = SCTP_MAX_READBUFFER;    }    nxt = end; nxt++;         /* Stream */    myPingStream = strtol(nxt, &end, 0);        if(end != NULL){       if(*end != ':'){	printf("Getting stream \n");	printf("mal-formed request \n");	printf(">");	fflush(stdout);	return;      }     }else{      printf("Getting stream \n");      printf("mal-formed request \n");      printf(">");      fflush(stdout);      return;    }    nxt = end; nxt++;     if(myPingStream > (MAX_PING_PONG_CONTEXTS - 1)){      printf("Invalid stream value \n");      printf("mal-formed request \n");      printf(">");      fflush(stdout);      return;    }        /* Times */    myPingCount = strtol(nxt, &end, 0);    if(end != NULL){       if(*end != ':'){	printf("Getting ping pong count \n");	printf("mal-formed request \n");	printf(">");	fflush(stdout);	return;      }     }else{      printf("Getting ping pong count \n");      printf("mal-formed request \n");      printf(">");      fflush(stdout);      return;    }    nxt = end; nxt++;     if(myPingCount <= 0){      printf("Invalid ping pong count \n");      printf("mal-formed request \n");      printf(">");      fflush(stdout);      return;    }    /* Block start */    myBlockAfter = strtol(nxt, &end, 0);    if(end != NULL){       if(*end != ':'){	printf("Getting block after \n");	printf("mal-formed request \n");	printf(">");	fflush(stdout);	return;      }     }else{      printf("Getting block after \n");      printf("mal-formed request \n");      printf(">");      fflush(stdout);      return;    }    nxt = end; nxt++;     if(myBlockAfter <= 0){      printf("Invalid block after \n");      printf("mal-formed request \n");      printf(">");      fflush(stdout);      return;    }    /* Block during */    myBlockDuring = strtol(nxt, NULL, 0);        if(myBlockDuring <= 0){      printf("Invalid block during \n");      printf("mal-formed request \n");      printf(">");      fflush(stdout);      return;    }    for(i=0;i<MAX_PING_PONG_CONTEXTS;i++){      if(pingPongTable[i].stream == -1){	pingPongTable[i].stream = myPingStream;	pingPongTable[i].counter = 0;	pingPongTable[i].nbRequests = myPingCount;	pingPongTable[i].blockAfter = myBlockAfter;	pingPongTable[i].blockDuring = myBlockDuring;	pingPongTable[i].blockTime  = 0;	break;      }    }    pingPongsDefined++;    printf("%d ping pong contexts are defined \n", pingPongsDefined);    printf("Type startmultping to proceed \n");    fflush(stdout);    return;  }else if ( strcmp("startmultping",readBuffer) == 0 ) {    int i;    time_t x;    struct tm *timeptr;    if(pingPongsDefined <= 0){      printf("No ping pong contexts defined \n");    }else{      /* prepare ping buffer */      pingBufSize = 500;      strncpy(pingBuffer,"ping", 4);      for(i = 4;i<pingBufSize;i++) {	pingBuffer[i] = 'A' + (i%26);      }      for(i = 0;i< MAX_PING_PONG_CONTEXTS;i++){	if((pingPongTable[i].stream  != -1) && (pingPongTable[i].started == 0)){	  sctpSEND(m,pingPongTable[i].stream,pingBuffer,pingBufSize,SCTP_getAddr(),		   sendOptions,payload,-1);      	  pingPongTable[i].started = 1;	  x       = time(0);	  timeptr = localtime(&x);	  printf("Starting on stream %d at %s",pingPongTable[i].stream,asctime(timeptr));	}      }    }    printf(">");    fflush(stdout);    return;  }else if(strcmp("netstats",readBuffer) == 0){    int num,i;    struct SCTP_nets *np;    num = sctpHOWMANYNETS(m,SCTP_getAddr());    printf("There are %d networks for the destination peersRwnd:%d\n",	   num,sctpRWND(m,SCTP_getAddr()));    for(i=0;i<num;i++){      np = sctpGETNET(m, SCTP_getAddr(), i);      if(np != NULL){	printf("Net[%d] errorCount:%d address: ",	       i,	       np->errorCount);	SCTPPrintAnAddress(np->ina);	printf("lastsa:%d lastsv:%d RTO:%d\n",	       np->lastsa,	       np->lastsv,	       np->RTO);	printf("cwd:%d pba:%d rtoPend:%d ssthresh:%d flight:%d\n",	       np->cwnd,	       np->partial_bytes_acked,	       np->rtoPending,	       np->ssthresh,	       np->flightSize);	printf("MTU:%d failThresh:%d state:%x\n",	       np->MTU,	       np->failureThreshold,	       np->intfRotationState);      }    }  }else if(strncmp("setdefstrm:",readBuffer,11) == 0){    defStream = strtol(&readBuffer[11],NULL,0);  }else if(strncmp("seterr:",readBuffer,7) == 0){    int newrtry;    newrtry = strtol(&readBuffer[7],NULL,0);    sctpSET_ASOC_ERR_THRESH(m,SCTP_getAddr() , newrtry);  }else if(strncmp("setneterr:",readBuffer,10) == 0){    char *nxt;    int newrtry,net;    net = strtol(&readBuffer[10],&nxt,0);    if(nxt == NULL){      printf("syntax error 'setneterr:net-num:val' please\n");      printf(">");      fflush(stdout);      return;    }    nxt++;    newrtry = strtol(nxt,NULL,0);    if((newrtry < 1) || (net >= sctpHOWMANYNETS(m,SCTP_getAddr()))){      printf("syntax error 'setneterr:net-num:val' please\n");      printf(">");      fflush(stdout);      return;    }    printf("Setting net:%d failure threshold to %d\n",	   net,newrtry);    sctpSET_NET_ERR_THRESH(m,SCTP_getAddr() ,net, newrtry);  }else if(strncmp("setscope:",readBuffer,9) == 0){    u_int scop;    scop = (u_int)strtol(&readBuffer[9],NULL,0);    SCTP_setIPv6scope(scop);    printf("Set scope id of %d address\n",scop);    SCTPPrintAnAddress(SCTP_getAddr());  }else if(strncmp("sethost6:",readBuffer,9) == 0){    struct in6_addr in6;    if(inet_pton(AF_INET6,	      &readBuffer[9],		 (void *)&in6)){      SCTP_setIPaddr6((u_char *)&in6);    }else{      printf("Invalid address format\n");    }    destinationSet++;    printf("To Set ");    SCTPPrintAnAddress(SCTP_getAddr());  }else if(strncmp("sethost:",readBuffer,8) == 0){    struct in_addr in;    if(inet_pton(AF_INET,		 &readBuffer[8],		 (void *)&in)){      SCTP_setIPaddr(in.s_addr);    }else{      printf("IPV4 can't set:Sorry incorrect address format\n");    }    destinationSet++;    printf("To Set ");    SCTPPrintAnAddress(SCTP_getAddr());  }else if(strncmp("setport:",readBuffer,8) == 0){    unsigned short pt;    pt = (unsigned short)strtol(&readBuffer[8],NULL,0);    SCTP_setport(htons(pt));     printf("Port set to %d\n",ntohs(SCTP_getport()));    destinationSet++;  }else if(strncmp("setopts:",readBuffer,8) == 0){    sendOptions = strtol(&readBuffer[8],NULL,0);    sctpSetSendOptions(m,sendOptions);  }else if(strcmp("getpegs",readBuffer) == 0){    int i;    unsigned int *x;    x = sctpGETPEGS(m, SCTP_getAddr());    if(x != NULL){      for(i=0;i<SCTP_NUMBER_OF_PEGS;i++){	printf("Peg[%s] = %d\n",namelist[i],x[i]);      }    }  }else if(strcmp("clearpegs",readBuffer) == 0){    sctpCLEARPEGS(m, SCTP_getAddr());  }else if(strncmp("printmap:",readBuffer,9) == 0){    sctpPrintMappings(m,SCTP_getAddr(),&readBuffer[9]);    printf("print mapping completes\n");  }else if(strncmp("setdefcookielife:",readBuffer,17) == 0){    int cl;    cl = strtol(&readBuffer[17],NULL,0);    if(cl <= 0){      printf("error: cookie life must be positive\n");    }else{      int old;      old = sctpSET_DEFCOOKIELIFE(m,cl);      printf("Default cookie life set to %d (was %d)\n", cl, old);    }  }else if(destinationSet >= 2){    /* default send the string to our peer */    if((pingPongCount>0) || bulkInProgress){      printf("Sorry bulk or ping in progress, you must wait for completion before sending\n");    }else{      int xsxx;      xsxx = sctpSEND(m,defStream,readBuffer, lenread, SCTP_getAddr(),		sendOptions,payload,-1);      printf("Returned %d from the send\n",xsxx);    }  }else{    printf("sorry first set a destination before sending\n");  }  printf(">");  fflush(stdout);}/* Called by the distributor each time stdin is ready for reading. */intstdinInFdHandler(void *arg,int fd, int event){  if(fd != 0)    return(0);  /*handleStdin((sctpAdaptorMod *)arg);*/  /* XXX [MM] as a quick and dirty hack, set the adaptor to the global "adap".   * The correct fix is modify rl_callback_read_char to accept more   * than one parameter.   */  adap = (sctpAdaptorMod *) arg;  /* Read the next character from the input. If that completes the line,   * then call what has been setup with rl_callback_handler_install.   */  rl_callback_read_char();  return(0);}/* Initialize user interface handling. */voidinitUserInterface(distributor *o,sctpAdaptorMod *s,		  struct routingAdaptor *r){  /* Init the readline library, callback mode. */  /* Override the default completion done by the library, because   * we want to complete commands, not filenames.   */  rl_completion_entry_function = (Function *) command_generator;  /*  Call handleStdin2 when a complete line of input has been entered. */  rl_callback_handler_install(">>>", handleStdin2);  dist = o;  dist_addFd(o,0,stdinInFdHandler,POLLIN,(void *)s);  resetPingPongTable();  /* now subscribe for messages */  ra = r;  dist_msgSubscribe(s->o,		    sctpInput,		    DIST_SCTP_PROTO_ID_DEFAULT,DIST_STREAM_DEFAULT,		    10,(void *)s);}/* Clean up the terminal and readline state. */voiddestroyUserInterface(void){    /* _rl_clean_up_for_exit(); */    rl_deprep_term_function();}/* Look up NAME as the name of a command, and return a pointer to that * command or NULL if not found. */static struct command *find_command(char *name){    int i;    for (i = 0; commands[i].co_name != NULL; i++)        if (strcmp(name, commands[i].co_name) == 0)            return(&commands[i]);    return NULL;}/* Execute a command line. * * The line syntax is "command arg1 arg2 ..." (whitespace is separator). * Put the args in an argv[] and invoke the proper function. * * Preconditions: *   line is not empty */static intexecute_line(const char *line){    struct command *command;    char *argv[10]; /* more than enough */    char *buf, *cmd;    int i, ret;    if (*line == '\0')	return -1;    bzero(argv, sizeof(argv));    if ( (buf = strdup(line)) == NULL) {	perror("strdup");	return -1;    }    /* break buf into pieces and put them in argv[] */    cmd = strtok(buf, " \t");    for (i = 0; i < 10; i++) {	if ( (argv[i] = strtok(NULL, " \t")) == NULL)	    break;    }    /* Since the line may have been generated by command completion     * or by the user, we cannot be sure that it is a valid command name.     */    if ( (command = find_command(cmd)) == NULL) {        printf("%s: No such command.\n", cmd);        return -1;    }    ret = command->co_func(argv, i);    free(buf);    return ret;}/* Generator function for command completion, called by the readline library. * It returns a list of commands which match "text", one entry per invocation. * Each entry must be freed by the function which has been setup with * rl_callback_handler_install. The end of the list is marked by returning * NULL. When called for the first time with a new "text", "state" is set to * zero to allow for initialization. */static char *command_generator(char *text, int state){    static int index, len;    char *name;    /* If this is a new word to complete, initialize now. */    if (state == 0) {        index = 0;        len = strlen(text);    }    /* Return the next name which partially matches from the command list. */    while ( (name = commands[index].co_name) != NULL) {        index++;        if (strncmp(name, text, len) == 0)            return strdup(name);    }    return NULL;    /* no names matched */}/* addip address [how] - add ip address where how is the mask/action to pass. * New version using getaddrinfo. */static intcmd_addip(char *argv[], int argc){    struct SCTP *m = adap->m;    char *address;    struct addrinfo hints, *res;    int how, ret;    if (argc < 1) {	printf("addip: expected at least 1 argument\n");	return -1;    }    address = argv[0];    how = argv[1] != NULL ? strtol(argv[1], NULL, 0) : 0;    bzero(&hints, sizeof(hints));    hints.ai_flags = AI_NUMERICHOST; /* disable name resolution */    ret = getaddrinfo(address, NULL, &hints, &res);    if (ret != 0) {	printf("addip: getaddrinfo: %s\n", gai_strerror(ret));	return -1;    }    printf("addip: adding IP address %s, action 0x%x\n", address, how);    ret = sctpADDIPADDRESS(m, res->ai_addr, SCTP_getAddr(), how);    if (ret != 1) {	printf("addip: failed, return value: %d\n", ret);    } else {	printf("addip: success\n");    }    freeaddrinfo(res);    return ret != 1 ? -1 : 0;}/* This may be useful on systems without getaddrinfo() */#if 0static intcmd_addip_old(char *argv[], int argc){    struct sockaddr_in newaddr;    struct sockaddr_in6 newaddr6;    struct sockaddr *addthis;    void *filladdr;    int flag,ret,i,len;    char *addressp,*next;    /* first insert a ',' at the end */    ret = strlen(readBuffer);    readBuffer[ret] = ',';    readBuffer[(ret+1)] = 0;    memset((char *)&newaddr,0,sizeof(newaddr));    addressp = strtok(&readBuffer[6],",");    if(addressp == NULL){      printf("syntax error\n");      printf(">");      fflush(stdout);      return;    }    next = strtok(NULL,":");    if(next == NULL){      printf("syntax error\n");      printf(">");      fflush(stdout);      return;    }    addthis = NULL;    flag = strtol(next,NULL,0);    len = strlen(addressp);    for(i=0;i<len;i++){      if(addressp[i] == '.'){	newaddr.sin_port = 0;	newaddr.sin_family = AF_INET;#ifdef USES_BSD_4_4_SOCKET	newaddr.sin_len =  sizeof(struct sockaddr_in);#endif		addthis = (struct sockaddr *)&newaddr;	filladdr = (void *)&newaddr.sin_addr;      }else if(addressp[i] == ':'){	newaddr6.sin6_port = 0;	newaddr6.sin6_family = AF_INET6;#ifdef USES_BSD_4_4_SOCKET	newaddr6.sin6_len =  sizeof(struct sockaddr_in6);#endif		addthis = (struct sockaddr *)&newaddr6;	filladdr = (void *)&newaddr6.sin6_addr;      }    }    if(addthis == NULL){      printf("Unable to determine type of '%s' no : or .\n",	     addressp);      printf(">");      fflush(stdout);      return;    }    if(inet_pton(addthis->sa_family,addressp,filladdr) != 1){      printf("inet_pton fails to translate '%s'\n",	     addressp);      printf(">");      fflush(stdout);      return;    }    printf("Add IP address %s action=%x\n",addressp,flag);    ret = sctpADDIPADDRESS(m,addthis,SCTP_getAddr(),flag);    printf("Add call returns %d\n",ret);    return 0;}#endif/* assoc - associate with the set destination */static intcmd_assoc(char *argv[], int argc){  struct SCTP *m = adap->m;  if (!(destinationSet && portSet)) {    printf("Please set the destination/port before\n");    return -1;  }  if (m == NULL) {    printf("sorry m is NULL?\n");    return -1;  }  printf("Init to address\n");  SCTPPrintAnAddress(SCTP_getAddr());  sctpASSOCIATE(m,SCTP_getAddr(),0);  return 0;}/* bulk size stream count - send a bulk of messages */static intcmd_bulk(char *argv[], int argc){    struct SCTP *m = adap->m;    int ret;    if (argc < 3) {	printf("bulk: expected 3 arguments\n");	return -1;    }    bulkBufSize = argv[0] != NULL ? strtol(argv[0], NULL, 0) : 0;    bulkStream  = argv[1] != NULL ? strtol(argv[1], NULL, 0) : 0;    bulkCount   = argv[2] != NULL ? strtol(argv[2], NULL, 0) : 0;    if(bulkInProgress){	printf("bulk: sorry bulk already in progress\n");	return -1;    }    if(bulkBufSize > SCTP_MAX_READBUFFER){	printf("bulk: size %d is to large, overriding to largest I can"	       "handle %d\n", bulkBufSize, SCTP_MAX_READBUFFER);	bulkBufSize = SCTP_MAX_READBUFFER;    }else if (bulkBufSize <= 0) {	printf("bulk: size must be positive\n");	return -1;    }    if (bulkCount <= 0) {	printf("bulk: count must be positive\n");	return -1;    }    /* prepare ping buffer */    /* ask for the time */    if(bulkPingMode == 0){	strcpy(pingBuffer,"time");	ret = sctpSEND(m,bulkStream,pingBuffer,5,SCTP_getAddr(),sendOptions,payload,0);	strncpy(pingBuffer,"bulk",4);    }    bulkInProgress = 1;    checkBulkTranfer(m,NULL);    if(bulkCount == 0){	printf("bulk: bulk message are now queued\n");    }else{	printf("bulk: bulk transfer now in progress\n");    }    return 0;}/* bulkseen - display count of bulk packets seen (time resets) */static intcmd_bulkseen(char *argv[], int argc){    printf("bulk seen is %d\n",bulkSeen);    return 0;}/* chgcookielife val - change the current assoc cookieLife */static intcmd_chgcookielife(char *argv[], int argc){    struct SCTP *m = adap->m;    int val;    if (argc < 1) {	printf("chgcookielife: expected 1 argument\n");	return -1;    }    val = argv[0] != NULL ? strtol(argv[0], NULL, 0) : 0;    if(val == 0){	printf("sorry can't set cookie life to 0\n");    }else{	int old;	old = sctpCHANGE_COOKIELIFE(m,SCTP_getAddr(),val);	if(old > 0){	    printf("I set cookie life to %d it was %d\n",val,old);	}else{	    printf("Could not set cookielife, have you a asoc up yet?\n");	}    }    return 0;}/* clearpegs - clear the peg counts */static intcmd_clearpegs(char *argv[], int argc){    struct SCTP *m = adap->m;    sctpCLEARPEGS(m, SCTP_getAddr());    return 0;}/* continual num - set continuous init to num times */static intcmd_continual(char *argv[], int argc){    int num,y;    if (argc < 1) {	printf("continual: expected 1 argument\n");	return -1;    }    num = argv[0] != NULL ? strtol(argv[0], NULL, 0) : 0;    y = SCTP_setContinualInit(num);    printf("continual INIT set to %d\n",y);    return 0;}/* defretryi num - set a new association failure threshold for initing */static intcmd_defretryi(char *argv[], int argc){    struct SCTP *m = adap->m;    int num;    if (argc < 1) {	printf("defretryi: expected 1 argument\n");	return -1;    }    num = argv[0] != NULL ? strtol(argv[0], NULL, 0) : 0;    sctpSetRetryCount(m, SCTP_MAXATTEMPT_INIT , num);    return 0;}/* defretrys num - set a new association failure threshold for sending */static intcmd_defretrys(char *argv[], int argc){    struct SCTP *m = adap->m;    int num;    if (argc < 1) {	printf("defretrys: expected 1 argument\n");	return -1;    }    num = argv[0] != NULL ? strtol(argv[0], NULL, 0) : 0;    sctpSetRetryCount(m, SCTP_MAXATTEMPT_SEND, num);    return 0;}/* defrwnd num - set the default rwnd of the SCTP */static intcmd_defrwnd(char *argv[], int argc){    struct SCTP *m = adap->m;    int num;    if (argc < 1) {	printf("defrwnd: expected 1 argument\n");	return -1;    }    num = argv[0] != NULL ? strtol(argv[0], NULL, 0) : 0;    sctpSetRwindowSize(m,num);    return 0;}/* delip address [how] - delete ip address where how is the mask/action to pass */static intcmd_delip(char *argv[], int argc){    struct SCTP *m = adap->m;    char *address;    struct addrinfo hints, *res;    int how, ret;    if (argc < 1) {	printf("delip: expected at least 1 argument\n");	return -1;    }    address = argv[0];    how = argv[1] != NULL ? strtol(argv[1], NULL, 0) : 0;    bzero(&hints, sizeof(hints));    hints.ai_flags = AI_NUMERICHOST; /* disable name resolution */    ret = getaddrinfo(address, NULL, &hints, &res);    if (ret != 0) {	printf("delip: getaddrinfo: %s\n", gai_strerror(ret));	return -1;    }    printf("delip: deleting IP address %s, action 0x%x\n", address, how);    ret = sctpDELIPADDRESS(m, res->ai_addr, SCTP_getAddr(), how);    if (ret != 1) {	printf("delip: failed, return value: %d\n", ret);    } else {	printf("delip: success\n");    }    freeaddrinfo(res);    return ret != 1 ? -1 : 0;}/* disablev6 1/0 - Disable V6 */static intcmd_disablev6(char *argv[], int argc){    struct SCTP *m = adap->m;    int bool, old;    if (argc != 1) {	printf("disablev6: expected 1 argument\n");	return -1;    }    bool = argv[0] != NULL ? strtol(argv[0], NULL, 0) : 0;    if (bool != 0 && bool != 1) {	printf("disablev6: expected 0 or 1\n");	return -1;    }    old = sctpSETV6DISABLE(m, bool);    printf("Disable v6 set to %d it was at %d\n", bool, old);    return 0;}/* doheartbeat - preform a on demand HB */static intcmd_doheartbeat(char *argv[], int argc){    struct SCTP *m = adap->m;    int ret;    ret = sctpREQUESTHEARTBEAT(m,SCTP_getAddr());    printf("Request returns %d\n",ret);    return 0;}/* getcurcookielife - display current assoc cookieLife */static intcmd_getcurcookielife(char *argv[], int argc){    struct SCTP *m = adap->m;    printf("Current cookie life is %d seconds\n",	   sctpGET_CURCOOKIELIFE(m,SCTP_getAddr()));    return 0;}/* getdefcookielife - display default cookie life */static intcmd_getdefcookielife(char *argv[], int argc){    struct SCTP *m = adap->m;    printf("Default cookie life is %d seconds\n",	   sctpGET_DEFCOOKIELIFE(m));    return 0;}/* getfsids [prntlimit] - print prntlimit fsid entries */static intcmd_getfsids(char *argv[], int argc){    struct SCTP *m = adap->m;    int *fp1, *fp2, *fp3, *fp4, *fp5;    int prntlimit,i;    prntlimit = argv[0] != NULL ? strtol(argv[0], NULL, 0) : 0;    if (prntlimit <= 0 || prntlimit > MAX_FSID) {	prntlimit = MAX_FSID;    }    fp1 = sctpGETFSID(m,SCTP_getAddr(),0);    fp2 = sctpGETFSID(m,SCTP_getAddr(),1);    fp3 = sctpGETFSID(m,SCTP_getAddr(),2);    fp4 = sctpGETFSID(m,SCTP_getAddr(),3);    fp5 = sctpGETFSID(m,SCTP_getAddr(),4);    if((fp1 != NULL) ||       (fp2 != NULL) ||       (fp3 != NULL) ||       (fp4 != NULL) ||       (fp5 != NULL)){	printf("totalflt:peerrwnd:cwnd    :numseeni:gate\n");	for(i=0;i<prntlimit;i++){	    printf("%8.8d:%8.8d:%8.8d:%8.8d:%8.8d\n",		   fp1[i],		   fp2[i],		   fp3[i],		   fp4[i],		   fp5[i]);	}    }else{	printf("Sorry, a null came back\n");	return -1;    }    return 0;}/* gethbdelay - get the hb delay */static intcmd_gethbdelay(char *argv[], int argc){    struct SCTP *m = adap->m;    printf("HB delay is %d plus RTT\n",	   sctpGETHEARTBEATDELAY(m,SCTP_getAddr()));    return 0;}/* getpegs - retrieve the peg counts */static intcmd_getpegs(char *argv[], int argc){    struct SCTP *m = adap->m;    int i;    unsigned int *x;    x = sctpGETPEGS(m, SCTP_getAddr());    if(x != NULL){      for(i=0;i<SCTP_NUMBER_OF_PEGS;i++){	printf("Peg[%s] = %d\n",namelist[i],x[i]);      }    }    return 0;}/* getprimary - tells which net number is primary */static intcmd_getprimary(char *argv[], int argc){    struct SCTP *m = adap->m;    printf("The primary address is %d\n",sctpGETPRIMARY(m,SCTP_getAddr()));    return 0;}/* getrtt - Return the RTO of the current default address of the assoc */static intcmd_getrtt(char *argv[], int argc){    struct SCTP *m = adap->m;    printf("RTT of TO is %d\n",sctpGETRTTREPORT(m,SCTP_getAddr()));    return 0;}/* heart on/off - Turn HB on or off to the destination */static intcmd_heart(char *argv[], int argc){    struct SCTP *m = adap->m;    char *bool;    if (argc != 1) {	printf("heart: expected 1 argument\n");	return -1;    }    bool = argv[0];    if (strcmp(bool, "on") == 0) {	sctpSETHB(m,SCTP_getAddr(),1);    } else if (strcmp(bool, "off") == 0) {	sctpSETHB(m,SCTP_getAddr(),0);    } else {	printf("heart: expected on or off\n");	return -1;    }    return 0;}/* heartdelay time - Add number of seconds + RTO to hb interval */static intcmd_heartdelay(char *argv[], int argc){    struct SCTP *m = adap->m;    int newdelay;    newdelay = argv[0] != NULL ? strtol(argv[0], NULL, 0) : 0;    sctpCHANGEHEARTBEAT(m,SCTP_getAddr(),newdelay);    return 0;}/* help [cmd] - display help for cmd, or for all the commands if no cmd specified */static intcmd_help(char *argv[], int argc){    int i, printed;    char *cmdname;    struct command *cmd;    printed = 0;    cmdname = argv[0];    if (cmdname != NULL) {	if ( (cmd = find_command(cmdname)) != NULL) {	    printf("%s\n", cmd->co_desc);	} else {	    printf("help: no match for `%s'. Commands are:", cmdname);	    for (i = 0; commands[i].co_name != NULL; i++) {		printf("%s", printed % 3 == 0 ? "\n" : "");		printf("%-20.20s", commands[i].co_name);		printed++;	    }	    printf("\n");	}    } else {	for (i = 0; commands[i].co_name != NULL; i++) {	    printf("%s\n", commands[i].co_desc);	}    }    return 0;}/* hulkstart filename - start the hulk hogan process */static intcmd_hulkstart(char *argv[], int argc){    struct SCTP *m = adap->m;    char *filename;    if (argc < 1) {	printf("hulkstart: Gak, no file name\n");	return -1;    }    filename = argv[0];    /* XXX [MM] symlink attack */    hulkfile = fopen(filename, "w+");    if(hulkfile != NULL){      printf("hulk scheduler begun\n");      dist_TimerStart(dist,		      SCTPdataTimerTicks, 		      0,period,(void *)NULL,(void *)m);    }else{      printf("Can't open file err:%d for file '%s'\n",	     errno,filename);      return -1;    }    return 0;}/* hulkstop - stop the hulk hogan process */static intcmd_hulkstop(char *argv[], int argc){    struct SCTP *m = adap->m;    curSeq = 0;    if(hulkfile != NULL)      fclose(hulkfile);    hulkfile = NULL;    dist_TimerStop(dist,		   SCTPdataTimerTicks, 		      (void *)NULL,(void *)m);    return 0;}/* initmultping - init contexts for a fast test */static intcmd_initmultping(char *argv[], int argc){    struct SCTP *m = adap->m;    initPingPongTable(sctpGETNUMOUTSTREAMS(m,SCTP_getAddr()));    printf("%d ping pong contexts are defined \n", pingPongsDefined);    printf("Type startmultping to proceed\n");    return 0;}/* inqueue - report inqueue counts */static intcmd_inqueue(char *argv[], int argc){    struct SCTP *m = adap->m;    printf("Outbound queue count to dest = %d\n",	   sctpHOWMANYINQUEUE(m,SCTP_getAddr()));    printf("Inbound queue count = %d\n",sctpHOWMANYINBOUND(m));    return 0;}/* multping size stream count blockafter sec * - add a ping pong context and block after <blockafter> instances for *   <sec> seconds */static intcmd_multping(char *argv[], int argc){    int  i;    int myPingCount, myPingStream, myBlockAfter, myBlockDuring;    if (argc != 5) {	printf("multping: expected 5 arguments\n");	return -1;    }    pingBufSize   = strtol(argv[0], NULL, 0);    myPingStream  = strtol(argv[1], NULL, 0);    myPingCount   = strtol(argv[2], NULL, 0);    myBlockAfter  = strtol(argv[3], NULL, 0);    myBlockDuring = strtol(argv[4], NULL, 0);      if(pingBufSize <= 0 || pingBufSize > SCTP_MAX_READBUFFER){	printf("size %d out of range, setting to largest I can handle %d\n",	       pingBufSize,SCTP_MAX_READBUFFER);	pingBufSize = SCTP_MAX_READBUFFER;    }    if(myPingStream < 0 || myPingStream > (MAX_PING_PONG_CONTEXTS - 1)){	printf("stream %d out of range, setting to largest I can handle %d\n",	       myPingStream, MAX_PING_PONG_CONTEXTS - 1);	myPingStream = MAX_PING_PONG_CONTEXTS - 1;    }    if(myPingCount <= 0){	printf("Invalid ping pong count\n");	return -1;    }    if(myBlockAfter <= 0){	printf("Invalid block after\n");	return -1;    }    if(myBlockDuring <= 0){	printf("Invalid block during\n");	return -1;    }    for(i=0;i<MAX_PING_PONG_CONTEXTS;i++){	if(pingPongTable[i].stream == -1){	    pingPongTable[i].stream = myPingStream;	    pingPongTable[i].counter = 0;	    pingPongTable[i].nbRequests = myPingCount;	    pingPongTable[i].blockAfter = myBlockAfter;	    pingPongTable[i].blockDuring = myBlockDuring;	    pingPongTable[i].blockTime  = 0;	    break;	}    }    pingPongsDefined++;    printf("%d ping pong contexts are defined\n", pingPongsDefined);    printf("Type startmultping to proceed\n");    return 0;}/* netstats - return all network stats */static intcmd_netstats(char *argv[], int argc){    struct SCTP *m = adap->m;    int num,i;    struct SCTP_nets *np;    num = sctpHOWMANYNETS(m,SCTP_getAddr());    printf("There are %d networks for the destination peersRwnd:%d\n",	   num,sctpRWND(m,SCTP_getAddr()));    for(i=0;i<num;i++){	np = sctpGETNET(m, SCTP_getAddr(), i);	if(np != NULL){	    printf("Net[%d] errorCount:%d address: ",		   i,		   np->errorCount);	    SCTPPrintAnAddress(np->ina);	    printf("lastsa:%d lastsv:%d RTO:%d\n",		   np->lastsa,		   np->lastsv,		   np->RTO);	    printf("cwd:%d pba:%d rtoPend:%d ssthresh:%d flight:%d\n",		   np->cwnd,		   np->partial_bytes_acked,		   np->rtoPending,		   np->ssthresh,		   np->flightSize);	    printf("MTU:%d failThresh:%d state:%x\n",		   np->MTU,		   np->failureThreshold,		   np->intfRotationState);	}    }    return 0;}/* ping size stream count - play ping pong */static intcmd_ping(char *argv[], int argc){    struct SCTP *m = adap->m;    if(pingPongCount){	printf("Sorry ping-pong already in progress\n");	return -1;    }    if (argc != 3) {	printf("ping: expected 3 arguments\n");	return -1;    }    pingBufSize   = strtol(argv[0], NULL, 0);    pingStream    = strtol(argv[1], NULL, 0);    pingPongCount = strtol(argv[2], NULL, 0);    if(pingBufSize > SCTP_MAX_READBUFFER){	printf("%d is to large, override to largest I can handle %d\n",	       pingBufSize,SCTP_MAX_READBUFFER);	pingBufSize = SCTP_MAX_READBUFFER;    }    /* XXX no check for pingStream */    if(pingPongCount <= 0){	printf("count must be positive\n");	return -1;    }    printf("Starting PING size:%d stream:%d\n",pingBufSize,pingStream);    doPingPong(m);    return 0;}/* quit - quit the program */static intcmd_quit(char *argv[], int argc){    dist_setDone(dist);    return 0;}static intcmd_printrftpstat(char *argv[], int argc){  printf("Stream 1 read %d\n",str1read);  printf("Stream 2 read %d\n",str2read);  str1read = str2read = 0;  return 0;}/* rftp filename strm1 strm2 blocksz [n] - round-trip ftp */static intcmd_rftp(char *argv[], int argc){    struct SCTP *m = adap->m;    char cbuf[255];    char *file_in;    if((pingPongCount>0) || bulkInProgress){	printf("Sorry bulk or ping in progress, you must wait for completion"	       "before sending\n");	return -1;    }    if (argc < 4) {	printf("rftp needs at least 4 parameters, see help\n");	return -1;    }    file_in = argv[0];    rftp_in1 = fopen(file_in, "r");    if(rftp_in1 == NULL){      printf("Can't open file for strm1 err:%d for file '%s'\n", errno,file_in);      return -1;    }    rftp_in2 = fopen(file_in, "r");    if(rftp_in2 == NULL){      printf("Can't open file for strm2 err:%d for file '%s'\n", errno,file_in);      return -1;    }        rftp_strm1 = atoi(argv[1]);    rftp_strm2 = atoi(argv[2]);    rftp_bsz = atoi(argv[3]);    if(argc == 5)       rftp_rt = atoi(argv[4]);    else       rftp_rt = 0; /* unreliable for u-streams */    sprintf(cbuf,"%s.strm%d.out",file_in,rftp_strm1);    rftp_out1 = fopen(cbuf, "w+");    if(rftp_out1 == NULL){      printf("Can't open file err:%d for file '%s'\n", errno, cbuf);      return -1;    }    sprintf(cbuf,"%s.strm%d.out",file_in,rftp_strm2);    rftp_out2 = fopen(cbuf, "w+");    if(rftp_out2 == NULL){      printf("Can't open file err:%d for file '%s'\n", errno, cbuf);      return -1;    }    /*=====*/    printf("rftp started over streams %d and %d....\n", rftp_strm1, rftp_strm2);    rftp_ending1 = rftp_ending2 = 0;    str1Flow = str2Flow=0;    sendRftpTransfer((void *)m, NULL);    return 0;}/* routes - Dump the routing table */static intcmd_routes(char *argv[], int argc){    if(ra != NULL)      printRoutingTable(ra);    else      printf("Sorry, routing adaptor not setup\n");    return 0;}/* rwnd - get rwnds */static intcmd_rwnd(char *argv[], int argc){    struct SCTP *m = adap->m;    int rwnd,myrwnd;    myrwnd = sctpGET_MY_RWND(m,SCTP_getAddr());    rwnd = sctpGET_PEERS_RWND(m,SCTP_getAddr());    printf("My rwnd:%d peers rwnd:%d\n", myrwnd,rwnd);    return 0;}/* send string [n] - send string to a peer if a peer is set */static intcmd_send(char *argv[], int argc){    struct SCTP *m = adap->m;    int ret, r_cnt = -1;    if (argc < 1) {	printf("send: expected at least 1 argument\n");	return -1;    }    if (!(destinationSet && portSet)) {	printf("sorry first set a destination before sending\n");	return -1;    }    if((pingPongCount>0) || bulkInProgress){	printf("Sorry bulk or ping in progress, you must wait for completion"	       "before sending\n");	return -1;    }    if(argc == 2)       r_cnt = atoi(argv[1]);    ret = sctpSEND(m, defStream, argv[0], strlen(argv[0]), SCTP_getAddr(),		   sendOptions, payload, r_cnt);    printf("Returned %d from the send (retran count = %d)\n",ret, r_cnt);    return 0;}/* sendloop [num] - send test script loopback request of num size */static intcmd_sendloop(char *argv[], int argc){    struct SCTP *m = adap->m;    int x,ret;    x = argv[0] != NULL ? strtol(argv[0], NULL, 0) : 0;    if(x <= 0){      printf("num was 0? defaulting to 64\n");      x = 64;    }    ret = sendLoopRequest(m,x);    printf("Sent loop returned %d\n",ret);    return 0;}/* sendloopend [num] - send test script loopback request of num size and terminate */static intcmd_sendloopend(char *argv[], int argc){    struct SCTP *m = adap->m;    int x;    x = argv[0] != NULL ? strtol(argv[0], NULL, 0) : 0;    if(x <= 0){      printf("num was 0? defaulting to 64\n");      x = 64;    }    printf("Send loop request returns:%d\n",sendLoopRequest(m,x));    sctpTERMINATE(m,SCTP_getAddr());    printf("Sent loop and terminate queued\n");    return 0;}/* sendreltlv num - send a rel-tlv of num bytes of data */static intcmd_sendreltlv(char *argv[], int argc){    struct SCTP *m = adap->m;    int sz,ret;    char *xxx;    struct sctpParamDesc *TLVout;    struct SCTP_association *asoc;    struct sockaddr *add;    if (argc != 1) {	printf("sendreltlv: expected 1 argument\n");	return -1;    }    /* This is actually a violation, we are calling a module that we     * really should not.. but this is so we can do     * a test by dumpping inqueue anything we want for a REL-REQ.     */    add = SCTP_getAddr();    asoc = SCTPfindAssociation(m, (struct sockaddr *)add, &sz);    if(asoc == NULL){	printf("sorry can't find the association\n");	return -1;    }    /* sz = strtol(&readBuffer[11],NULL,0); */    sz = strtol(argv[0], NULL, 0);    if (sz <= 0) {	printf("sendreltlv: num must be positive\n");	return -1;    }    sz += sizeof(struct sctpParamDesc);    xxx = calloc(1,sz);    if (xxx == NULL) {	printf("sendreltlv: sorry malloc failed.. queue fails\n");	return -1;    } else {	u_short val,len,i;	char buf[10];	TLVout = (struct sctpParamDesc *)xxx;	printf("TLV value:");	fflush(stdout);	fgets(buf,sizeof(buf),stdin);      	val = (u_short)strtol(buf,NULL,0);	len = sz;	TLVout->paramType = htons(val);	TLVout->paramLength = htons(len);	for(i=0,len=sizeof(struct sctpParamDesc);len<sz;len++,i++){	    printf("Value for byte %d (0-255)",i);	    fflush(stdout);	    fgets(buf,sizeof(buf),stdin);	    val = strtol(buf,NULL,0);	    if(val > 255){		printf("Error input:%d to big, replacing with 255\n",val);		xxx[len] = 255;	    }else{		xxx[len] = val;	    }	}	printf("Delayed send (y, n, e, def=n):");	fflush(stdout);	fgets(buf,sizeof(buf),stdin);      	if(buf[0] == 'y'){	    ret = SCTPqueueARelReq(m,asoc,TLVout,1);	}else{	    struct sctpParamDesc *TLVout2;		    TLVout2 = NULL;	    if(buf[0] == 'e'){			xxx = calloc(1,sz);		if(xxx != NULL){		    memcpy(xxx,(char *)TLVout,sz);		}		TLVout2 = (struct sctpParamDesc *)xxx;	    }	    ret = SCTPqueueARelReq(m,asoc,TLVout,0);	    /* echo out a copy again to queue */	    if(TLVout2 != NULL){		ret = SCTPqueueARelReq(m,asoc,TLVout2,0);	    }	}	printf("Queue of REL-REQ returns %d\n",ret);	if(ret < 0){	    free(xxx);	}    }    return 0;}/* setbulkmode ascii/binary - set bulk transfer mode */static intcmd_setbulkmode(char *argv[], int argc){    if (argc != 1) {	printf("setbulkmode: expected 1 argument\n");	return -1;    }    switch (argv[0][0]) {    case 'a':	bulkPingMode = 0;	printf("bulk/ping transfer set to ascii mode\n");	break;    case 'b':	bulkPingMode = 1;	printf("bulk/ping transfer set to binary mode\n");	break;    default:	printf("setbulkmode: expected ascii/binary\n");	return -1;    }    return 0;}/* setdefcookielife num - set default cookie life */static intcmd_setdefcookielife(char *argv[], int argc){    struct SCTP *m = adap->m;    int cl, old;    if (argc != 1) {	printf("setdefcookielife: expected 1 argument\n");	return -1;    }    cl = strtol(argv[0], NULL, 0);    if(cl <= 0){      printf("error: cookie life must be positive\n");      return -1;    }else{      old = sctpSET_DEFCOOKIELIFE(m,cl);      printf("Default cookie life set to %d (was %d)\n", cl, old);    }    return 0;}/* setdefstream num - set the default stream to */static intcmd_setdefstream(char *argv[], int argc){    if (argc != 1) {	printf("setdefstream: expected 1 argument\n");	return -1;    }    /* XXX add validity check on stream number */    defStream = strtol(argv[0], NULL, 0);    return 0;}/* seterr num - set the association send error thresh */static intcmd_seterr(char *argv[], int argc){    struct SCTP *m = adap->m;    int et;    if (argc != 1) {	printf("seterr: expected 1 argument\n");	return -1;    }    et = strtol(argv[0], NULL, 0);    /* XXX add validity check on et */    sctpSET_ASOC_ERR_THRESH(m,SCTP_getAddr(),et);    return 0;}/* sethost host|X.Y.Z.A - set the destination host IP address */static intcmd_sethost(char *argv[], int argc){    struct in_addr in;    if (inet_pton(AF_INET, argv[0], &in)) {	SCTP_setIPaddr(in.s_addr);    }else{	printf("can't set IPv4: incorrect address format\n");	return -1;    }    destinationSet++;    printf("To Set ");    SCTPPrintAnAddress(SCTP_getAddr());    return 0;}/* sethost6 host|xx:xx:xx...:xx - set the destination host IPv6 address */static intcmd_sethost6(char *argv[], int argc){    struct in6_addr in6;    if(inet_pton(AF_INET6, argv[0], &in6)){	SCTP_setIPaddr6((u_char *)&in6);    }else{	printf("can't set IPv6: incorrect address format\n");	return -1;    }    destinationSet++;    printf("To Set ");    SCTPPrintAnAddress(SCTP_getAddr());    return 0;}/* setneterr net val - set the association network error thresh */static intcmd_setneterr(char *argv[], int argc){    struct SCTP *m = adap->m;    int net, val;    if (argc != 2) {	printf("setneterr: expected 2 arguments\n");	return -1;    }    net = strtol(argv[0], NULL, 0);    val = strtol(argv[1], NULL, 0);    if (net <= 0 || net >= sctpHOWMANYNETS(m,SCTP_getAddr())) {	printf("setneterr: net out of range\n");	return -1;    }    if (val < 1) {	printf("setneterr: val out of range\n");	return -1;    }    printf("Setting net:%d failure threshold to %d\n",	   net,val);    sctpSET_NET_ERR_THRESH(m,SCTP_getAddr(),net,val);    return 0;}/* setopts val - set options to specified value */static intcmd_setopts(char *argv[], int argc){    struct SCTP *m = adap->m;    if (argc != 1) {	printf("setopts: expected 1 argument\n");	return -1;    }    /* XXX add input validation */    sendOptions = strtol(argv[0], NULL, 0);    sctpSetSendOptions(m,sendOptions);    return 0;}/* setpay payloadt - set the payload type */static intcmd_setpay(char *argv[], int argc){    if (argc != 1) {	printf("setpay: expected 1 argument\n");	return -1;    }    /* XXX add input validation */    payload = strtol(argv[0], NULL, 0);    printf("payloadtype set to %d\n",payload);    return 0;}/* setport port - set the destination SCTP port number */static intcmd_setport(char *argv[], int argc){  unsigned short pt;  pt = (unsigned short)strtol(argv[0],NULL,0);  SCTP_setport(htons(pt));   printf("Port set to %d\n",ntohs(SCTP_getport()));  portSet++;  return 0;}/* setprimary - set current ip address to the primary address */static intcmd_setprimary(char *argv[], int argc){    struct SCTP *m = adap->m;    sctpSETPRIMARY(m,SCTP_getAddr());    printf("Primary address set to ");    SCTPPrintAnAddress(SCTP_getAddr());    return 0;}/* setremprimary address - set remote's primary address */static intcmd_setremprimary(char *argv[], int argc){    struct SCTP *m = adap->m;    char *address;    struct addrinfo hints, *res;    int ret;    if (argc != 1) {	printf("setremprimary: expected 1 argument\n");	return -1;    }    address = argv[0];    bzero(&hints, sizeof(hints));    hints.ai_flags = AI_NUMERICHOST; /* disable name resolution */    ret = getaddrinfo(address, NULL, &hints, &res);    if (ret != 0) {	printf("setremprimary: getaddrinfo: %s\n", gai_strerror(ret));	return -1;    }    printf("setremprimary: setting remote primary %s\n", address);    ret = sctpREMOTESETPRIMARY(m, res->ai_addr, SCTP_getAddr(), 0);    if (ret != 0) {	printf("setremprimary: failed, return value: %d\n", ret);    } else {	printf("setremprimary: success\n");    }    freeaddrinfo(res);    return ret != 0 ? -1 : 0;}/* setscope num - Set the IPv6 scope id */static intcmd_setscope(char *argv[], int argc){    u_int scop;    if (argc != 1) {	printf("setscope: expected 1 argument\n");	return -1;    }    scop = (u_int)strtol(argv[0],NULL,0);    /* XXX add input validation */    SCTP_setIPv6scope(scop);    printf("Set scope id of %d address\n",scop);    SCTPPrintAnAddress(SCTP_getAddr());    return 0;}/* setstreams numpreopenstrms - set the number of streams I request */static intcmd_setstreams(char *argv[], int argc){    struct SCTP *m = adap->m;    int preOpenStrm;    if (argc != 1) {	printf("setstreams: expected 1 argument\n");	return -1;    }    preOpenStrm = strtol(argv[0],NULL,0);    /* XXX add input validation */    sctpSetOutStream(m, preOpenStrm);    return 0;}/* mark unrel stream ranges  */static intcmd_markustrms(char *argv[], int argc){    struct SCTP *m = adap->m;    int i;    if (argc != 1) {	printf("markustrms: expected 1 argument\n");	return -1;    }    if(sctpMarkUnrelStreams(m, argv[0]) < 0)      printf("parser error, marking may be incomplete\n");    printf("Unreliable streams now set to:\n");    for(i=0; i<MAX_UNRELSTREAM_SETS*2; i+=2) {      if(m->unrelStreamSets[i] <0) break; /* reached the end of used */      printf("   %d-%d\n", m->unrelStreamSets[i], m->unrelStreamSets[i+1]);    }      return 0;}/* startmultping - start the defined ping pong contexts */static intcmd_startmultping(char *argv[], int argc){    struct SCTP *m = adap->m;    int i;    time_t x;    struct tm *timeptr;    if(pingPongsDefined <= 0){	printf("No ping pong contexts defined\n");    }else{	/* prepare ping buffer */	pingBufSize = 500;	strncpy(pingBuffer,"ping", 4);	for(i = 4;i<pingBufSize;i++) {	    pingBuffer[i] = 'A' + (i%26);	}	for(i = 0;i< MAX_PING_PONG_CONTEXTS;i++){	    if((pingPongTable[i].stream != -1) &&	       (pingPongTable[i].started == 0)){		sctpSEND(m,pingPongTable[i].stream,pingBuffer,pingBufSize,			 SCTP_getAddr(),sendOptions,payload,0);      		pingPongTable[i].started = 1;		x = time(NULL);		timeptr = localtime(&x);		printf("Starting on stream %d at %s",pingPongTable[i].stream,		       asctime(timeptr));	    }	}    }    return 0;}/* tella host - confess what translateIPAddress returns * XXX IPv4 only */static intcmd_tella(char *argv[], int argc){    u_long x;    if (argc != 1) {	printf("tella: expected 1 argument\n");	return -1;    }    x = ntohl(translateIPAddress(argv[0]));    printf("Address is %d.%d.%d.%d\n",	   (int)((x>>24) & 0x000000ff),	   (int)((x>>16) & 0x000000ff),	   (int)((x>>8) & 0x000000ff),	   (int)(x & 0x000000ff)	   );    return 0;}/* term - terminate the set destination association (graceful shutdown) */static intcmd_term(char *argv[], int argc){    struct SCTP *m = adap->m;    if(m != NULL)      sctpTERMINATE(m,SCTP_getAddr());    else      printf("sorry m is NULL?\n");    return 0;}/* whereto - tell where the default sends */static intcmd_whereto(char *argv[], int argc){    struct sockaddr *to;    printf("Currently sending to:");    to = SCTP_getAddr();    SCTPPrintAnAddress(to);    return 0;}