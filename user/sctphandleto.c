/* SCTP reference Implementation Copyright (C) 2001 Cisco And MotorolaThis file is part of the SCTP reference ImplementationVersion:4.0.5$Header: /home/sourceTree/src/sctp/user/sctphandleto.c,v 1.27 2001/07/24 11:52:39 randall Exp $The SCTP reference implementation  is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published bythe Free Software Foundation; either version 2, or (at your option)any later version.the SCTP reference implementation  is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of                ************************MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See theGNU Library General Public License for more details.You should have received a copy of the GNU Library General Public Licensealong with GNU CC; see the file COPYING.  If not, write tothe Free Software Foundation, 59 Temple Place - Suite 330,Boston, MA 02111-1307, USA.  Please send any bug reports or fixes you make to one of the following emailaddresses:rrs@cisco.comkmorneau@cisco.comqxie1@email.mot.comAny bugs reported given to us we will try to fix... any fixes shared willbe incorperated into the next SCTP release.There are still LOTS of bugs in this code... I always run on the motto"it is a wonder any code ever works :)"*/#include <sctp.h>#include <sctputil.h>#include <sctpsenders.h>#include <sctpinbound.h>#include <sctpmtu.h>voidmarkAllForResendToNet(struct SCTP *m,		      struct SCTP_association *asoc,		      int whichLan){  /* This routine will mark all pending datagrams   * to whichLan has needing resend. This is   * called when a T-O happens on a destination.   */  struct SCTP_transmitOnQueue *tmit;  SCTPdebugPrint(m,"Marking all to retransmit cnt:%d\n",		 asoc->numberToRetran);  asoc->totalFlight -= asoc->nets[whichLan].flightSize;  asoc->nets[whichLan].flightSize = 0;  for(tmit=asoc->sendqueue;tmit != NULL;tmit=tmit->next){    if((tmit->sent >= SCTP_DATAGRAM_SENT) &&       (tmit->whichNet == whichLan) &&        (tmit->sent < SCTP_DATAGRAM_ACKED)){      tmit->sent = SCTP_DATAGRAM_RESEND;      /* turn off fast-retransmit flag */      tmit->doingFastRetransmit = 0;      /* add back to the peers rwnd, since we must       * retransmit it.       */      if(compare_with_wrap(tmit->TSN_seq,asoc->t3timeoutHighestMarked,MAX_TSN)){	/* TSN_seq is larger than t3timeoutHighestMarked so update */	asoc->t3timeoutHighestMarked = tmit->TSN_seq;      }      asoc->numberToRetran++;      asoc->peersRwnd += (tmit->sizeOfTmit - sizeof(struct sctpUnifiedDatagram));      tmit->sent_rcv_Time.tv_sec = tmit->sent_rcv_Time.tv_nsec = 0;    }else if(tmit->sent == SCTP_DATAGRAM_UNSENT){      break;    }  }  SCTPdebugPrint(m,"Marking all to retransmit completes cnt:%d\n",		 asoc->numberToRetran);  asoc->nets[whichLan].rtoPending = 0;}voidSCTPhandlePathMtuRaise(struct SCTP *m,		       struct SCTP_association *asoc,		       struct SCTP_TimerInfo *info){  /* here we will possibly attempt to raise   * the Path MTU.   */  /* mark us to idle */  int i;  u_long nextMtu;  info->running = SCTP_TIMER_IDLE;  /* restart the timer in any case */  SCTPdebugPrint(m,"Path MTU timer!!!\n");  timerWork(m,asoc,SCTP_TIMER_START,SctpTimerTypePathMtuRaise,0);#ifdef DO_NOT_RAISE_ABOVE_DEFAULT  if(asoc->smallestMTU >= SCTP_DEFAULT_MAXSEGMENT)    /* nothing to do */    return;#endif  nextMtu = sctpGetNextMTU(m,asoc->smallestMTU);  /* fix the smallest one up */  if(nextMtu <= asoc->smallestMTU){    /* nothing to do now */    return;  }  SCTPdebugPrint(m,"Raising Path MTU from %d to-> %d\n",		 asoc->smallestMTU,nextMtu);  asoc->smallestMTU = nextMtu;  /* now adjust all networks to be at min this value */  for(i=0;i<asoc->numnets;i++){    if(asoc->nets[i].MTU < nextMtu){      SCTPdebugPrint(m,"Raising Path MTU net[%d] from %d to-> %d\n",		     i,asoc->nets[i].MTU,nextMtu);      asoc->nets[i].MTU = nextMtu;    }  }}void SCTPhandleInitTimerUp(struct SCTP *m,			   struct SCTP_association *asoc,			   struct SCTP_TimerInfo *info){  /* ok we are attempting to init the    * association and have a t-o.   */  /* we really only know one destination at   * this point since until he inits   * back I do not know about any   * remote multi-homing.. but count   * it anyway.    */  unsigned char to[SCTP_ADDRMAX];  SCTPdebugPrint(m,"Init timer is up\n");  asoc->overallErrorCount++;  asoc->nets[asoc->lastNetSentTo].errorCount++;  asoc->initsectim <<= 1;  asoc->initusectim <<= 1;  if(asoc->initusectim > 1000000){    asoc->initusectim -= 1000000;    asoc->initsectim++;  }  if(asoc->initsectim > SCTP_RTO_UPPER_BOUND_SEC){    asoc->initsectim = SCTP_RTO_UPPER_BOUND_SEC;  }  if(asoc->overallErrorCount > asoc->maxInitTimes){    /* ok nothgin we can do, must dump     * association and tell     * upper layer.     */    SCTPmakeIntoSock(to,asoc,0);    info->running = SCTP_TIMER_IDLE;    SCTPreportAllOutboundLost(m,asoc);    SCTPupperLayerNotification(m,asoc,SCTP_NOTIFY_ASSOC_DOWN,			       (int)to);    SCTPfreeAssociation(m,asoc);    return;  }  SCTPsendInitiate(m,asoc);  info->running = SCTP_TIMER_IDLE;   timerWork(m,asoc,SCTP_TIMER_START,SctpTimerTypeInit,0);}void SCTPhandleRecvTimerUp(struct SCTP *m,			   struct SCTP_association *asoc,			   struct SCTP_TimerInfo *info){  /* This is quite simple. All we need to   * do is fire up the Sack sending routine   * and set the timer back to idle.   */  SCTPdebugPrint(m,"Recv timer is up\n");  asoc->pegs[SCTP_RECV_TIMER]++;    SCTPsendSackFlag(m,asoc);  info->running = SCTP_TIMER_IDLE;  asoc->needToAck = 0;}int SCTPthresholdManagement(struct SCTP *m,			    struct SCTP_association *asoc,			    struct SCTP_nets *netp,			    int whichLan,			    struct SCTP_TimerInfo *info){  /* returns 1 if association lost   * otherwise returns 0 and may   * report to upper layer    */  unsigned char to[SCTP_ADDRMAX];  if(asoc->numnets > 1){    if((netp->errorCount > netp->failureThreshold) &&       ((netp->intfRotationState&SCTP_ADDR_NOT_REACHABLE) != SCTP_ADDR_NOT_REACHABLE)){      /* I just lost a network now there is       * less to send to.       */      SCTPdebugPrint(m,"Lost lan %d\n",whichLan);      SCTPmakeIntoSock(to,asoc,whichLan);      netp->intfRotationState &= ~SCTP_ADDR_REACHABLE;      netp->intfRotationState |= SCTP_ADDR_NOT_REACHABLE;      SCTPupperLayerNotification(m,asoc,SCTP_NOTIFY_INTF_DOWN,				 (int)to);    }  }  if(asoc->overallErrorCount > asoc->maxSendTimes){    /* ok nothgin we can do, must dump     * association and tell     * upper layer.     */    SCTPdebugPrint(m,"Overall err's %d > max:%d\n",		   asoc->overallErrorCount,asoc->maxSendTimes);    SCTPmakeIntoSock(to,asoc,0);    info->running = SCTP_TIMER_IDLE;    SCTPreportAllOutboundLost(m,asoc);    SCTPdebugPrint(m,"Now notify down asoc\n");    SCTPupperLayerNotification(m,asoc,SCTP_NOTIFY_ASSOC_DOWN,			       (int)to);    SCTPdebugPrint(m,"Now free asoc:%x\n",(u_int)asoc);    SCTPfreeAssociation(m,asoc);    SCTPdebugPrint(m,"we are out of here\n");    return(1);  }  return(0);}void SCTPhandleSendTimerUp(struct SCTP *m,			   struct SCTP_association *asoc,			   struct SCTP_TimerInfo *info){  struct SCTP_transmitOnQueue *tmit;  int tot,whichLan;  /* Find the first datagram sent but   * un-ack'd on the specified destination. This is the guy that the   * timer was set running on. All subsequen sends will not start the timer.   */  SCTPdebugPrint(m,"Send timer is up number:%d\n",info->countOf);  asoc->pegs[SCTP_TMIT_TIMER]++;    if((asoc->sendqueue == NULL) && (asoc->outqueue == NULL)){    /* error timer should not have been running */    asoc->outQueueCount = 0;    info->running = SCTP_TIMER_IDLE;    return;  }  if(asoc->sendqueue == NULL){    info->running = SCTP_TIMER_IDLE;    SCTPsendAnyWeCan(m,asoc,1);    return;  }  tmit = asoc->sendqueue;  /* figure out which destination address */  if(info->countOf == 0){    whichLan = SCTP_MAX_NET_TIMERS;  }else{    whichLan = info->countOf - SCTP_MAX_NET_TIMERS;  }  while(tmit->whichNet != whichLan){    tmit = tmit->next;    if(tmit == NULL){      /* stray timer should not happen */      SCTPdebugPrint(m,"TIME FLUX --- SOFTWARE ERROR, HELP!!\n");      return;    }  }    /* increment error counts and call theshold mangement */  asoc->overallErrorCount++;  asoc->nets[whichLan].errorCount++;  if(SCTPthresholdManagement(m,asoc,&asoc->nets[whichLan],whichLan,info)){    return;  }   /* Now lets see if there are any sendable within    * the window.   */  SCTPdebugPrint(m,"Ok lets do a send/resend pass\n");  info->running = SCTP_TIMER_IDLE;  /* mark the lowest too */  tmit->sent = SCTP_DATAGRAM_RESEND;  tot = tmit->sizeOfTmit;  /* now we must mark the rest up to one MTU */  markAllForResendToNet(m,asoc,whichLan);  asoc->nets[whichLan].ssthresh = asoc->nets[whichLan].cwnd >> 1;  if(asoc->nets[whichLan].ssthresh < (int)(asoc->nets[whichLan].MTU << 1)){    asoc->nets[whichLan].ssthresh = asoc->nets[whichLan].MTU << 1;  }  asoc->nets[whichLan].cwnd = asoc->nets[whichLan].MTU;  /* Backoff the timer exponentially.   */  asoc->nets[whichLan].RTO <<= 1;  if(asoc->nets[whichLan].RTO > SCTP_RTO_UPPER_BOUND){    asoc->nets[whichLan].RTO =  SCTP_RTO_UPPER_BOUND;  }  /* Ok now retran one DG */  /* the send anything we can */  if(SCTPsendRetransmits(m,asoc) <= 0){    /* this probably means we are doing unreliable send */    tot = SCTPsendAnyWeCan(m,asoc,1);    if(tot == 0) return; /* nothing sent, no need to worry about timer */  }  /* This code figures out if the retransmit actually sent   * any to the destination address that timed out. Since   * SCTPsendRetransmits() does not start a timer (it is   * usually called from elsewhere.. we hope) we must carefully   * assess if the timed out address has datagrams pending to   * it now. If so we start the timer.   */  tmit = asoc->sendqueue;  tot = 0;  while(tmit != NULL){    if(tmit->whichNet == whichLan){      tot++;      break;    }    tmit = tmit->next;  }  if(tot){    timerWork(m,asoc,SCTP_TIMER_START,SctpTimerTypeSend,whichLan);  }}void SCTPhandleShutdownTimerUp(struct SCTP *m,			       struct SCTP_association *asoc,			       struct SCTP_TimerInfo *info){  unsigned char to[SCTP_ADDRMAX];  SCTPdebugPrint(m,"Shutdown timer is up\n");  /*   * if assoc no longer exists   */  info->running = SCTP_TIMER_IDLE;  if(asoc != NULL){    /* must retransmit my shutdown message */    SCTPsendAShutdown(m,asoc,1);    asoc->overallErrorCount++;    if(asoc->overallErrorCount > asoc->maxInitTimes){      SCTPmakeIntoSock(to,asoc,0);      info->running = SCTP_TIMER_IDLE;      SCTPreportAllOutboundLost(m,asoc);      SCTPupperLayerNotification(m,asoc,SCTP_NOTIFY_ASSOC_DOWN,				 (int)to);      SCTPfreeAssociation(m,asoc);      return;    }    timerWork(m,asoc,SCTP_TIMER_START,SctpTimerTypeShutdown,0);  }}void SCTPhandleShutdownAckTimerUp(struct SCTP *m,				  struct SCTP_association *asoc,				  struct SCTP_TimerInfo *info){  unsigned char to[SCTP_ADDRMAX];  SCTPdebugPrint(m,"ShutdownAck timer is up\n");  /*   * if assoc no longer exists   */  info->running = SCTP_TIMER_IDLE;  if(asoc != NULL){    /* must retransmit my shutdown-ACK message */    int whichLan;    asoc->overallErrorCount++;    if(asoc->overallErrorCount > asoc->maxInitTimes){      SCTPmakeIntoSock(to,asoc,0);      info->running = SCTP_TIMER_IDLE;      SCTPreportAllOutboundLost(m,asoc);      SCTPupperLayerNotification(m,asoc,SCTP_NOTIFY_ASSOC_DOWN,				 (int)to);      SCTPfreeAssociation(m,asoc);        return;    }    whichLan = SCTPselectNextLan(m,asoc);    SCTPmakeIntoSock(to,asoc,whichLan);    SCTPsendShutdownAck(m,asoc,(struct sockaddr *)to,SCTP_SHUTDOWN_ACK,0,NULL);    timerWork(m,asoc,SCTP_TIMER_START,SctpTimerTypeShutdownAck,0);  }}voidSCTPdecayCwndThresholds(struct SCTP *m,			struct SCTP_association *asoc){  /* do a gradual decay of the cwnd of a idle path */  if(asoc->nets[asoc->lastHBOn].cwnd > (int)(asoc->nets[asoc->lastHBOn].MTU * 2)){    /* half it */    asoc->nets[asoc->lastHBOn].cwnd >>= 1;    /* now validate it has not gone to low */    if(asoc->nets[asoc->lastHBOn].cwnd < (int)(asoc->nets[asoc->lastHBOn].MTU*2)){      asoc->nets[asoc->lastHBOn].cwnd = (asoc->nets[asoc->lastHBOn].MTU*2);    }  }}void SCTPhandleHeartBeatTimerUp(struct SCTP *m,				struct SCTP_association *asoc,				struct SCTP_TimerInfo *info){  /* Here we have the HB timer has expired.   * we must check if the last destination I HB'd on   * got back a resp. If so then Just HB   * again, if not count against last lan and   * take appropriate action.   * we also use this opportunity to decay the congestion   * window parameter of the idle path   * This routine only puts out one HB at a time and has   * merged the hb error count and the normal send error   * count. It could be enhanced to HB to multiple destinations   * but I would not un-do the integration of the HB failure   * and send failures.   */  asoc->pegs[SCTP_HB_TIMER]++;    /* We must handle 3 seperate cases here     A. The case that a hb was sent and NO response,        this we treat like a t-o on send.     B. The case where we sent it and got a response,        but need to do a decay of the cwnd.     C. The case where we did NOT send it since it was        active... and NO one was idle.  */  if((asoc->gotLastHB == 0) && (asoc->reallySentHB)){    /* This is CASE A */    asoc->overallErrorCount++;    asoc->nets[asoc->lastHBOn].errorCount++;    /* now check out the threshold's */    if(SCTPthresholdManagement(m,asoc,&asoc->nets[asoc->lastHBOn],			       asoc->lastHBOn,info)){      /* non-zero return means we lost the assoc */      return;    }    /* now we must mark the rest up to one MTU */    markAllForResendToNet(m,asoc,asoc->lastHBOn);    /* Do normal time-out type handling of ssthresh */    asoc->nets[asoc->lastHBOn].ssthresh = asoc->nets[asoc->lastHBOn].cwnd >> 1;    if(asoc->nets[asoc->lastHBOn].ssthresh < (int)(asoc->nets[asoc->lastHBOn].MTU << 1)){      asoc->nets[asoc->lastHBOn].ssthresh = asoc->nets[asoc->lastHBOn].MTU << 1;    }    /* clamp to 1 MTU allowed out */    asoc->nets[asoc->lastHBOn].cwnd = asoc->nets[asoc->lastHBOn].MTU;    /* Backoff the timer exponentially.     */    asoc->nets[asoc->lastHBOn].RTO <<= 1;    if(asoc->nets[asoc->lastHBOn].RTO > SCTP_RTO_UPPER_BOUND){      asoc->nets[asoc->lastHBOn].RTO =  SCTP_RTO_UPPER_BOUND;    }  }else if(asoc->reallySentHB){    /* This is CASE B */    SCTPdebugPrint(m,"GOT HB RESPONSE\n");    SCTPdebugPrint(m,"now decay the idle path congestion window\n");    SCTPdebugPrint(m,"before adjustment:- cwnd:%d partial_bytes_acked:%d ssthresh:%d\n",		   asoc->nets[asoc->lastHBOn].cwnd,		   asoc->nets[asoc->lastHBOn].partial_bytes_acked,		   asoc->nets[asoc->lastHBOn].ssthresh		   );        SCTPdecayCwndThresholds(m,asoc);    SCTPdebugPrint(m,"after adjustment:- cwnd:%d partial_bytes_acked:%d ssthresh:%d\n",		   asoc->nets[asoc->lastHBOn].cwnd,		   asoc->nets[asoc->lastHBOn].partial_bytes_acked,		   asoc->nets[asoc->lastHBOn].ssthresh);  }else{    /* Case C, decay cwnd and also check thresholds */    SCTPdecayCwndThresholds(m,asoc);    /* We will count a error in send over and over has a     * lost destination.     */    if(SCTPthresholdManagement(m,asoc,&asoc->nets[asoc->lastHBOn],			       asoc->lastHBOn,info)){      /* non-zero return means we lost the assoc */      return;    }  }  SCTPdebugPrint(m,"Call the send HB req mod\n");  /* We fall out of the if/else if() to here for CASE C and   * just send the next HB    */  if(SCTPSendHBReq(m,asoc,-1) > 0){    asoc->lastHBOn = asoc->lastNetSentTo;    asoc->gotLastHB = 0;    asoc->reallySentHB = 1;     asoc->pegs[SCTP_HB_SENT]++;  }else{    /* send failed, since all interfaces are     * active. Set it up that it suceeded, and the     * send module se the reallySent flag to false.     * This will cause us to hit CASE C above next     * time around.     */    asoc->gotLastHB = 1;    asoc->reallySentHB = 0;  }  info->running = SCTP_TIMER_IDLE;  timerWork(m,asoc,SCTP_TIMER_START,SctpTimerTypeHeartbeat,asoc->lastHBOn);  }void SCTPhandleCookieTimerUp(struct SCTP *m,			     struct SCTP_association *asoc,			     struct SCTP_TimerInfo *info){  asoc->overallErrorCount++;  info->running = SCTP_TIMER_IDLE;  /* don't worry about the multi-homing, this could   * be enhanced to do so since now we know   * about all destinations    */  asoc->initsectim <<= 1;  asoc->initusectim <<= 1;  if(asoc->initusectim > 1000000){    asoc->initusectim -= 1000000;    asoc->initsectim++;  }  if(asoc->initsectim > SCTP_RTO_UPPER_BOUND_SEC){    asoc->initsectim = SCTP_RTO_UPPER_BOUND_SEC;  }  if(asoc->overallErrorCount > asoc->maxInitTimes){    unsigned char to[SCTP_ADDRMAX];    SCTPmakeIntoSock(to,asoc,0);      SCTPreportAllOutboundLost(m,asoc);    SCTPupperLayerNotification(m,asoc,SCTP_NOTIFY_ASSOC_DOWN,			       (int)to);    SCTPfreeAssociation(m,asoc);      return;  }  /* this will resend only the cookie */  SCTPsendRetransmits(m,asoc);  timerWork(m,asoc,SCTP_TIMER_START,SctpTimerTypeCookie,0);  }voidSCTPhandleRelReqTimerUp(struct SCTP *m,			struct SCTP_association *asoc,			struct SCTP_TimerInfo *info){  int whichLan,ret;  info->running = SCTP_TIMER_IDLE;  if(asoc->relReqSent){    /* if we really sent something out and did not get     * a response we must do threshold managment     * bumping retran counts as well.     */    whichLan = asoc->relReqLastSentTo;    asoc->overallErrorCount++;    asoc->nets[whichLan].errorCount++;    if(SCTPthresholdManagement(m,asoc,&asoc->nets[whichLan],whichLan,info)){      return;    }    asoc->nets[whichLan].RTO <<= 1;    if(asoc->nets[whichLan].RTO > SCTP_RTO_UPPER_BOUND){      asoc->nets[whichLan].RTO =  SCTP_RTO_UPPER_BOUND;    }    ret = SCTPsendRelReqOut(m,asoc,1);  }else{    /* Here we just re-attempt to formulate the     * outbound message. The send last time failed     * so we go ahead and try again.     */    ret = SCTPsendRelReqOut(m,asoc,0);  }  if(ret > -2){    timerWork(m,asoc,	      SCTP_TIMER_START,SctpTimerTypeRelReq,	      asoc->lastNetSentTo);  }}