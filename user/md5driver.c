/* SCTP reference Implementation Copyright (C) 2001 Cisco And MotorolaThis file is part of the SCTP reference ImplementationVersion:4.0.5$Header: /home/sourceTree/src/sctp/user/md5driver.c,v 1.15 2001/07/24 11:52:39 randall Exp $The SCTP reference implementation  is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published bythe Free Software Foundation; either version 2, or (at your option)any later version.the SCTP reference implementation  is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of                ************************MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See theGNU Library General Public License for more details.You should have received a copy of the GNU Library General Public Licensealong with GNU CC; see the file COPYING.  If not, write tothe Free Software Foundation, 59 Temple Place - Suite 330,Boston, MA 02111-1307, USA.  Please send any bug reports or fixes you make to one of the following emailaddresses:rrs@cisco.comkmorneau@cisco.comqxie1@email.mot.comAny bugs reported given to us we will try to fix... any fixes shared willbe incorperated into the next SCTP release.There are still LOTS of bugs in this code... I always run on the motto"it is a wonder any code ever works :)"*/#include <time.h>#include <string.h>#include <strings.h>#include <stdio.h>#include <stdlib.h>#include <unistd.h>#include <sys/types.h>#include <netinet/in_systm.h>#include <netinet/in.h>#include <netinet/ip.h>#include <netdb.h>#include <arpa/inet.h>#include <sys/ioctl.h>#include <sys/stat.h>#include <stdarg.h>#include <signal.h>#include <fcntl.h>#include <sys/param.h>#ifdef __Lynx__#include <socket.h>#include <sockio.h>#else#include <sys/socket.h>#if ! ( defined(LINUX) || defined(TRU64) || defined(AIX))#include <sys/sockio.h>#endif#endif#ifdef LINUX #include <stropts.h>#endif#include <net/if.h>#include <errno.h>#include <sctpConstants.h>#include <sctpStructs.h>#include <sctpHeader.h>#include <sctputil.h>#ifdef USE_MD5#include "md5global.h"#include "md5.h"#else#include "sla1.h"#endif/* SCTP Main driver.   passing a two pointers and two lengths,   returning a digest pointer filled. The md5 code   was taken directly from the RFC (2104) so to understand it   you may want to go look at the RFC referenced in the   SCTP spec. We did modify this code to either user OUR   implementation of SLA1 or the MD5 that comes from its   RFC. SLA1 may have IPR issues so you need to check in   to this if you wish to use it... Or at least that is   what the FIP-180.1 web page says. */void sctpMd5Digest(struct SCTP *m,		   char *key,int key_len,		   char *text,int text_len,		   unsigned char *digest){  unsigned long *p;#ifdef SOLARIS  unsigned long printarray[20];#endif#ifdef USE_MD5  MD5_CTX context;#else  struct SLA_1_Context context;#endif  unsigned char k_ipad[65];    /* inner padding -				* key XORd with ipad				*/  unsigned char k_opad[65];    /* outer padding -				* key XORd with opad				*/  unsigned char tk[20];  int i;  /* if key is longer than 64 bytes reset it to key=MD5(key) */  SCTPdebugPrint(m, "BEGIN: sctpMd5Digest \n");  SCTPdebugPrint(m,"Will encode %d octets in the secret key, and %d in data\n",		 key_len,text_len);  if (key_len > 64) {#ifdef USE_MD5    MD5_CTX      tctx;    MD5Init(&tctx);    MD5Update(&tctx, key, key_len);    MD5Final(tk, &tctx);    key = tk;    key_len = 16;#else    struct SLA_1_Context tctx;    SLA1_Init(&tctx);    SLA1_Process(&tctx, key, key_len);    SLA1_Final(&tctx,tk);    key = tk;    key_len = 20;#endif  }  /*   * the HMAC_MD5 transform looks like:   *   * MD5(K XOR opad, MD5(K XOR ipad, text))   *   * where K is an n byte key   * ipad is the byte 0x36 repeated 64 times   * opad is the byte 0x5c repeated 64 times   * and text is the data being protected   */  /* start out by storing key in pads */  bzero( k_ipad, sizeof k_ipad);  bzero( k_opad, sizeof k_opad);  bcopy( key, k_ipad, key_len);  bcopy( key, k_opad, key_len);  /* XOR key with ipad and opad values */  for (i=0; i<64; i++) {    k_ipad[i] ^= 0x36;    k_opad[i] ^= 0x5c;  }  /*   * perform inner MD5   */#ifdef USE_MD5  MD5Init(&context);                   /* init context for 1st					* pass */  MD5Update(&context, k_ipad, 64);      /* start with inner pad */  MD5Update(&context, text, text_len);  /* then text of datagram */  MD5Final(digest, &context);          /* finish up 1st pass */#else  SLA1_Init(&context);                     /* init context for 1st					    * pass 					    */  SLA1_Process(&context, k_ipad, 64);      /* start with inner pad */  SLA1_Process(&context, text, text_len);  /* then text of datagram */  SLA1_Final(&context,digest);             /* finish up 1st pass */#endif  /*   * perform outer MD5   */#ifdef USE_MD5  MD5Init(&context);                   /* init context for 2nd					* pass */  MD5Update(&context, k_opad, 64);     /* start with outer pad */  MD5Update(&context, digest, 16);     /* then results of 1st					* hash 					*/  MD5Final(digest, &context);          /* finish up 2nd pass */#else  SLA1_Init(&context);                   /* init context for 2nd					  * pass 					  */  SLA1_Process(&context, k_opad, 64);     /* start with outer pad */  SLA1_Process(&context, digest, 20);     /* then results of 1st					   * hash 					   */  SLA1_Final(&context, digest);          /* finish up 2nd pass */#endif/* Don't know if this will work but we will * give it a go, there may be other alignment * problems as well. */#ifdef SOLARIS#ifdef USE_MD5  memcpy((char *)printarray,digest,16);#else  memcpy((char *)printarray,digest,20);#endif  p = printarray;#else  p = (unsigned long *)digest;#endif#ifdef USE_MD5  SCTPdebugPrint(m,		 "signed has 0x%8.8x.0x%8.8x.0x%8.8x.0x%8.8x\n",		 ntohl(p[0]),ntohl(p[1]),ntohl(p[2]),ntohl(p[3]));#else  SCTPdebugPrint(m,		 "signed has 0x%8.8x.0x%8.8x.0x%8.8x.0x%8.8x.0x%8.8x\n",		 ntohl(p[0]),ntohl(p[1]),ntohl(p[2]),ntohl(p[3]),ntohl(p[4]));#endif  SCTPdebugPrint(m, "END: sctpMd5Digest \n");}