/* SCTP reference Implementation Copyright (C) 2001 Cisco And MotorolaThis file is part of the SCTP reference ImplementationVersion:4.0.5$Header: /home/sourceTree/src/sctp/user/sctp.h,v 1.53 2001/07/24 11:52:39 randall Exp $The SCTP reference implementation  is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published bythe Free Software Foundation; either version 2, or (at your option)any later version.the SCTP reference implementation  is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of                ************************MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See theGNU Library General Public License for more details.You should have received a copy of the GNU Library General Public Licensealong with GNU CC; see the file COPYING.  If not, write tothe Free Software Foundation, 59 Temple Place - Suite 330,Boston, MA 02111-1307, USA.  Please send any bug reports or fixes you make to one of the following emailaddresses:rrs@cisco.comkmorneau@cisco.comqxie1@email.mot.comAny bugs reported given to us we will try to fix... any fixes shared willbe incorperated into the next SCTP release.There are still LOTS of bugs in this code... I always run on the motto"it is a wonder any code ever works :)"*/#ifndef __sctp_h__#define __sctp_h__/* un-comment this line if you DON'T have IPv6 *//*#define DOES_NOT_HAVE_IPV6 1*/#include <stdio.h>#include <stdlib.h>#include <unistd.h>#include <sys/types.h>#include <netinet/in_systm.h>#include <netinet/in.h>#include <netinet/ip.h>#include <arpa/inet.h>#include <sys/ioctl.h>#include <sys/stat.h>#include <stdarg.h>#include <signal.h>#include <fcntl.h>#include <sys/param.h>#include <netdb.h>#ifndef DOES_NOT_HAVE_IPV6#include <netinet/ip6.h>#include <netinet/icmp6.h>#endif#ifdef __Lynx__#include <socket.h>#include <sockio.h>#else#include <sys/socket.h>#if ! ( defined(LINUX) || defined(TRU64) || defined(AIX))#include <sys/sockio.h>#endif#endif#include <time.h>#include <string.h>#if (defined (LINUX) || defined(TRU64))#include <stropts.h>#endif#include <net/if.h>#if ! (defined (LINUX))#include <net/if_dl.h>#endif#include <errno.h>#include <dlist.h>#include <HashedTbl.h>#include <sctpConstants.h>#include <sctpHeader.h>#include <sctpStructs.h>/* Uncoment this and one like it in sctp.h to get * all sorts of debug and kill performance (what little * there is in this impl)  */ /*#ifndef DEBUG_ON*//*#define DEBUG_ON 1*//*#endif*/#ifndef IPV6_VERSION_MASK#define IPV6_VERSION_MASK 0xf0#endif#ifndef IPV6_VERSION#define IPV6_VERSION 0x60#endif/* in Linux we get this from netinet/in.h but I * no longer have a sun to play with so I really * don't know if sun supports this, I will add * this just in case. */#ifndef IN_MULTICAST#define IN_MULTICAST(a) ((((uint32_t) (a)) & 0xf0000000) == 0xe0000000)#endifextern struct SCTPbaseStruct *ms;#ifdef	__cplusplusextern "C" {#endif  /* if port is set to 0 then we grab any port (IP_ANY)   * otherwise we grab the port specified and will   * return NULL if we cannot bind it.. Also NULL   * return if there is no memory.   */  /****************************************************/  /* SCTP Primitives and Notifcations (see section 9) */  /****************************************************/struct SCTP *sctpINITIALIZE(void (*tmr)(struct SCTP *,void *,int,int,int),	       void (*changeEventMask)(int,int),	       void (*notification)(int,char*,int),	       void (*gettime)(struct timespec *),	       unsigned short port);intsctpASSOCIATE(struct SCTP *, struct sockaddr *, int options);intsctpTERMINATE(struct SCTP *m, struct sockaddr *s);intsctpABORT(struct SCTP *m); /* diff from section 9 slightly */intsctpSEND(struct SCTP *m,	 int streamNo,	 char *data, 	 int size, 	 struct sockaddr *to,	 int options,	 int payloadtype,	 int numRetrans);intsctpGETPRIMARY(struct SCTP *m, struct sockaddr *path); intsctpSETPRIMARY(struct SCTP *m, struct sockaddr *path);int /* return -1 if error, otherwise the size of date received */sctpRECEIVE(struct SCTP *m, 	    char *buffer, 	    int buffer_size, 	    int *strmNum, 	    int *seqNum, 	    struct sockaddr *,	    struct sockaddr *,	    int *payloadtype,	    u_int *tsn);void * sctpSTATUS(struct SCTP *, struct sockaddr *); /* Not implemented, you						  * can use sctpGETNET						  * to get each net's						  * info.						  */voidsctpCHANGEHEARTBEAT(struct SCTP *, 		    struct sockaddr *, 		    int );int sctpGETHEARTBEATDELAY(struct SCTP *m,		      struct sockaddr *to);int sctpREQUESTHEARTBEAT(struct SCTP *,		     struct sockaddr *);int sctpGETRTTREPORT(struct SCTP *,		 struct sockaddr *);/* Set Protocol Parameters primitive is partially implemented as  * the following functions  */intsctpSetOutStream(struct SCTP *m, int value);intsctpMarkUnrelStreams(struct SCTP *m, char *ms);intsctpSetSendOptions(struct SCTP *m, int value);intsctpSetRetryCount(struct SCTP *m, int type, int retryCount);intsctpGetRetryCount(struct SCTP *m, int type);intsctpSetRwindowSize(struct SCTP *m,int sz);/* most SCTP-to-ULP notifications are implemented in this * reference implementation has callbacks that do * a printf. If you want something more fill it in :-) *//* the following are some internal functions specific to this * implementation */voidsctptimerExpires(struct SCTP *,void *);int *getSCTPfileDescriptor(struct SCTP *,int *eventMask, int *numfds);       intsctpfdEvent(struct SCTP *,int event,int fd);intsendToStream0(struct SCTP *m, 	      char *data, 	      int size, 	      struct sockaddr *to, 	      int options,int payload,int retrans);/* set hb state if on is true hb happens else no hb  on * specified address. */voidsctpSETHB(struct SCTP *m, struct sockaddr *s, int on);/* how many dg's yet in queue? */intsctpHOWMANYINQUEUE(struct SCTP *m,struct sockaddr *s);/* how many in my inbound queue not read yet */intsctpHOWMANYINBOUND(struct SCTP *m);/* get the peg counts */u_int *sctpGETPEGS(struct SCTP *m, struct sockaddr *s);/* clear all peg counts */voidsctpCLEARPEGS(struct SCTP *m, struct sockaddr *s);/*  returns the number of networks the peer has */intsctpHOWMANYNETS(struct SCTP *m, struct sockaddr *s);/* returns the net struct for the indx number */struct SCTP_nets *sctpGETNET(struct SCTP *m, struct sockaddr *s, int idx);/* returns the rwnd size */intsctpRWND(struct SCTP *m, struct sockaddr *s);voidsctpSET_ASOC_ERR_THRESH(struct SCTP *m, struct sockaddr *s, int val);voidsctpSET_NET_ERR_THRESH(struct SCTP *m, struct sockaddr *s, int idx, int val);intsctpGET_PEERS_RWND(struct SCTP *m, struct sockaddr *s);intsctpGET_MY_RWND(struct SCTP *m, struct sockaddr *s);intsctpGET_CURCOOKIELIFE(struct SCTP *m, struct sockaddr *s);intsctpCHANGE_COOKIELIFE(struct SCTP *m, struct sockaddr *s, int val);intsctpABORT2(struct SCTP *m, struct sockaddr *s);voidsctpSETFAILURETHRESHOLD( struct SCTP *m, struct sockaddr *s, int num);int sctpGETNUMOUTSTREAMS(struct SCTP *m,struct sockaddr *to);int sctpGETNUMINSTREAMS(struct SCTP *m,struct sockaddr *to);int *sctpGETFSID(struct SCTP *m,struct sockaddr *to,int which);#define SCTP_ACTION_UPDATE_ALL_ASSOC      0x00000001#define SCTP_ACTION_UPDATE_ENDPOINT       0x00000002#define SCTP_ACTION_UPDATE_ONLY_ASSOC     0x00000004#define SCTP_ACTION_QUEUE_REQUEST_ONLY	  0x00000008intsctpEXECUTEAllAddDel(struct SCTP *m);intsctpEXECUTEAddDel(struct SCTP *m,		  struct sockaddr *to_ip);intsctpADDIPADDRESS(struct SCTP *m, 		   /* SCTP endpoint */		 struct sockaddr *mynewaddress, /* Address to add - must exist */		 struct sockaddr *to_ip,	   /* Association address */		 int action			   /* action to take */		 );intsctpDELIPADDRESS(struct SCTP *m, 		   /* SCTP endpoint */		 struct sockaddr *addresstodel, /* Address to delete - must exist */		 struct sockaddr *to_ip,	   /* Association address */		 int action			   /* action to take */		 );intsctpREMOTESETPRIMARYALL(struct SCTP *m,			struct sockaddr *myaddress,			int action);intsctpREMOTESETPRIMARY(struct SCTP *m,		     struct sockaddr *myaddress,		     struct sockaddr *to,		     int action		     );intsctpSETV6DISABLE(struct SCTP *m,		 int val);intsctpSET_DEFCOOKIELIFE(struct SCTP *m,         int val);intsctpGET_DEFCOOKIELIFE(struct SCTP *m);voidsctpPrintMappings(struct SCTP *m,struct sockaddr *to,char *file);#ifdef	__cplusplus}#endif#endif