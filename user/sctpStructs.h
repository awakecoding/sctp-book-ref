/* SCTP reference Implementation Copyright (C) 2001 Cisco And MotorolaThis file is part of the SCTP reference ImplementationVersion:4.0.5$Header: /home/sourceTree/src/sctp/user/sctpStructs.h,v 1.35 2001/07/24 11:52:39 randall Exp $The SCTP reference implementation  is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published bythe Free Software Foundation; either version 2, or (at your option)any later version.the SCTP reference implementation  is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of                ************************MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See theGNU Library General Public License for more details.You should have received a copy of the GNU Library General Public Licensealong with GNU CC; see the file COPYING.  If not, write tothe Free Software Foundation, 59 Temple Place - Suite 330,Boston, MA 02111-1307, USA.  Please send any bug reports or fixes you make to one of the following emailaddresses:rrs@cisco.comkmorneau@cisco.comqxie1@email.mot.comAny bugs reported given to us we will try to fix... any fixes shared willbe incorperated into the next SCTP release.There are still LOTS of bugs in this code... I always run on the motto"it is a wonder any code ever works :)"*/#include <dlist.h>#include <HashedTbl.h>#ifndef __sctpStructs_h__#define __sctpStructs_h__#ifdef	__cplusplusextern "C" {#endifstruct SCTP_RelReqKey{  u_int key;  struct sctpParamDesc *reply;}; struct SCTP_transmitOnQueue{  struct SCTP_transmitOnQueue *next;  struct SCTP_transmitOnQueue *prev;  int streamSeq; /* the stream sequence number of this transmit */  long TSN_seq;  /* the TSN of this transmit */  int streamNumber; /* the stream number of this guy */  int sent;      /* the send status */  struct SCTP_association *asoc; /* which asoc this belongs to */  int whichNet;  /* the destination address we last sent to */  int sizeOfTmit; /* size of payload */  int sndCount;   /* number of times I sent */  struct timespec sent_rcv_Time; /* filled in if RTT being calculated */  char *data; /* pointer to data chunk */  /* when it hits main sctp in queue this is who   * sent it.   */  unsigned char from[SCTP_ADDRMAX];  unsigned char to[SCTP_ADDRMAX];  int sendOptions; /* options applied to send */  int payloadtype;  int ipv6_flow;  int toAddr; /* address sent to */  u_char tos;  u_char rcvFlags; /* flags pulled from data chunk on inbound */  u_char doingFastRetransmit;  int numOfRetrans; /* how many retrans left (for unreliable data only) */};struct SCTP_TimerInfo{  int timerType; /* type of timer */  int running;  /* state of the timer */  int countOf;	/* index timer number for send count (yeilds the dest addr */  void *timerinfo; /* pointer to the association */};/* this struct contains info * that is used to track inbound  * stream data and help with ordering. */struct SCTP_stream_in{  struct SCTP_transmitOnQueue *inqueue; /* list waiting to be distributed */  u_short lastSequenceDelivered; /* used for re-order */  u_short reliable; /* if set, means this stream is reliable */};/* This struct is used * to track the traffic on outbound * streams */struct SCTP_stream_out{  u_short nextSequenceSent; /* next one I expect to send out */  u_short reliable; /* if set, means this stream is reliable */};/* This is the information we track on * each interface that we know about from * the distant end. */struct SCTP_nets{  /* Ip address and port */  struct sockaddr *ina;  /* error stats on destination */  unsigned short errorCount;  /* smoothed average things for RTT and RTO itself */  int lastsa;  int lastsv;  int RTO;  /* Congestion stats per destination */  int cwnd; /* actual cwnd */  int partial_bytes_acked; /* in CA tracks when to increment a MTU */  int rtoPending; /* tracks if a segment is marked for RTO update */  int ssthresh;  /* mtu discovered so far */  int MTU;	  /* last time in seconds I sent to it */  struct timespec lastSentTime;  /* flight size variables and such, sorry Vern, I could   * not avoid this if I wanted performance :>   */  int flightSize;  /* tracking variables to avoid the aloc/free in   * sack processing   */  int netAck;  int netAck2;  /* if this guy is ok or not ... status */  unsigned short intfRotationState;  /* number of transmit failures to down this guy */  unsigned short failureThreshold;};/* Here we have information about * each individual association that  * we track. We probably in production would * be more dynamic. But for ease of implementation * we will have a fixed array that we hunt for in * a linear fashion.  */struct SCTP_association{  struct SCTP_association *next;  struct SCTP_association *prev;  /* association state */  int state;  /* time when we entered state */  struct timespec timeEnteringState;  /* the cookie life I award for any cookie */  int cookieLife;  /* Here in lies Maddness, I now must add the   * source addresses of this association for the   * add/delete function. This has a side effect that   * I must now be able to do source address selection (SAS),   * a path unto maddness. We will put some intelligence   * in this but anytime I know there is a imbalance I   * will have to do selection, el-yucko. We do invoke   * a couple of rules for the add/delete thing:   *  - You can only add an address if the address   *    exists in the stack. In other words you must do   *    a ifconfig newnic newip (or) ifconfig oldnic newaddr   *    before you can do the actual add.   *  - You can do a delete of an address at anytime, However   *    if/when you do this, if this creates an imbalance   *    we begin source address selection and polling for   *    when we will actually lose the address... which   *    of course may never happen.   */  int supportsDynamicAddress;  int supportsDynamicSetPrim;  int numberOfNets;  int numberOfNetsAlloced;  struct sockaddr **localNets;  struct sockaddr_in *maskList;	/* used as part of SAS */  u_short locScope,siteScope;	/* scope values for IPv6 */  u_short ipv4Scope;		/* scope for private addresses */  u_short lastAddrSourced;	/* only used if SAS happens */  u_short listConsistent;	/* if set we are in sync to 				 * endpoint list.				 */  /* status of our local address */  char *addrStats;  /* count of nets and array */   int totalFlight;  int numnets;  struct SCTP_nets *nets;  /* Total error count on   * this association cleared anytime   * I get something.   */  int overallErrorCount;  /* Index of last nets[x] I have    * sent on   */  int lastNetSentTo;  /* Index of last nets[x] I have   * recieved on.   */  int lastNetRcvdFrom;  /* Time specifed has default RTO   */  int sendsectim;  int sendusectim;  /* Default init time.   *    */  int initsectim;  int initusectim;  /* Recieve timers  usually 200ms */  int t2recvinUsec;  /* how many preopen streams we have */  int preOpenStreams;  /* various verification tag information */  u_int curTag;	/* The tag to be used. if assoc is			 * re-initited by remote end, and			 * I have unlocked this will be			 * regenrated to a new random value.			 */  u_int hisTag;	/* The peers last tag */  /* my maximum number of retrans of INIT and SEND */  /* copied from SCTP but should be individually setable */  u_long maxInitTimes;  u_long maxSendTimes;  /* window state information and smallest MTU   * that I use to bound segmentation   */  long peersRwnd;  long myRwnd;  /* debug stuff */  unsigned int fsp1[MAX_FSID];  unsigned int fsp2[MAX_FSID];  unsigned int fsp3[MAX_FSID];  unsigned int fsp4[MAX_FSID];  unsigned int fsp5[MAX_FSID];  unsigned int fsidx;  u_long smallestMTU;  /* primary destination to use (index into nets array), defaults to 0 */  int primary_destination;  /* my rwnd copied from sctp struct */  int maxWindow;  /* The next TSN that I will use in sending and the   * initial seq number I started at.   */  u_long sendingSeq;  u_long initSeqNumber;  /* Special hook for Fast retransmit, allows us to track   * the highest TSN that is NEW in this SACK if    * gap ack blocks are present.   */  u_long thisSackHighestGap;  /* The highest consecutive TSN that has been acked */  /* by peer on my sends */  u_long lastAckedSeq;  /* We use this value to know if FR's are allowed, i.e.   * did the cum-ack pass this point or equal it so    * FR's are now allowed.   */  u_long t3timeoutHighestMarked;  /* The Advanced Peer Ack Point, as required by the U-SCTP */  /* (A1 in Section 4.2) */  u_long advancedPeerAckPoint;  /* The highest consequetive TSN at the bottom   * of the mapping array (for his sends).   */  u_long mappingArrayHighestTSN;  /* used to track highest TSN we have received out-of-order */  u_long highestTSNinside;  /* The mapping array is used to track out of order   * sequences above lastAckedSeq. 0 indicates packet missing   * 1 indicates packet rec'd. We slide it up every time we   * raise lastAckedSeq and 0 trailing locactions out.    * If I get a TSN above the array mappingArraySz, I   * discard the datagram and let retransmit happen.   */  int mappingArraySz;  char *mappingArray;  /* Do I need to send a ack?    * When needToAck is above 1 we do!   */  int needToAck;  int numberUnsent;  int numberToRetran;  /* mode of the association:   * currently only two things get   * put in this flag   * SCTP_MY_ADDRESS_ONLY - which attempts to override the primary_destination   *                        with the address specified   * SCTP_DO_CRC16 - which turns on/off CRC16 on outbound dg's.   */  int sendMode;  /* a array of timers for the association */  struct SCTP_TimerInfo tmr[SCTP_NUMBER_TIMERS];  /* all outbound datagrams queue into   * this list and are marked to sent after   * transmission and then removed when acknowledged.   * Choice of stream seq comes from respective   * SCTP_stream_out structure.   */  struct SCTP_transmitOnQueue *sendqueue;  struct SCTP_transmitOnQueue *sendqueuetail;  struct SCTP_transmitOnQueue *outqueue;  struct SCTP_transmitOnQueue *tailoutq;  int outQueueCount;  /* re-assembly queue for fragmented chunks */  struct SCTP_transmitOnQueue *reasmqueue;  /* Heart Beat things */  int lastHBOn;  int gotLastHB;  int reallySentHB;  int heartBeatDelay;  /* things are placed here when data   * is ready to receive.   */  /* stream 0 gets queued into this guy's */  struct SCTP_stream_out outbound;  struct SCTP_stream_in inbound;  /* all other streams are in here after being   * opened.   */  int streamincnt;  struct SCTP_stream_in  *strmin;  int streamoutcnt;  struct SCTP_stream_out *strmout;  /* if a cookie is attached to the association here   * it needs to be sent.   */  char *cookie;  char *opErr;  int opErrSiz;  /* ok, here is the rel-req stuff */  u_short peerCanDoRelReq; /* set to 1 if peer can do it */  u_short relReqSent;	   /* lock flag 0 is ok to send, 1 (or higher, it duals as a count) is awaiting a REL-ACK */  u_int relReqSeqOut;	   /* Next Seq I am sending out, inits at init-tsn */  u_int relReqSeqIn;	   /* Last received REL-REQ from peer, starts at peers tsn-1 */  u_int relReqLastSentTo;  /* destination address number last sent to (REL-REQ) */  struct SCTP_TimerInfo relReqTmr;	/* The timer for rel-req's */  dlist_t *queueOfRelReq;  /* we queue here any TLV's that need to be sent while REL-REQ is outstanding */  HashedTbl *pendingChunks;  struct sctpRelChunkDesc *lastSentRelReq;	/* we hold the last REL-REQ until a ack arrives */  struct sctpRelChunkDesc *lastSentRelAck; /* we save the last ACK we sent so we can resend it */  /* Being that we have no bag to collect stale cookies, and   * that we really would not want to anyway.. we will count   * them in this counter. We of course feed them to the   * pigeons right away (I have always thought of pigeons   * as flying rats).   */  int staleCookieCount;  int ECN_Allowed;  u_long lastEcho_TSN;  u_long lastCWR_TSN;  char *ECN_echo;  char *CWR;  int numduptsns;  int dupTsns[SCTP_MAX_DUP_TSNS];  u_int pegs[SCTP_NUMBER_OF_PEGS];  char restrictAddresses;  char firstAckUp;  /* flag to signal a fast retransmit has completed */  char fastRetransmitCompletes;  /* max burst after fast retransmit comletes */  char maxBurst;  char tos;  /* DNS name if passed */  char DNSname[(MAXHOSTNAMELEN+1)];};/* Here we have all the relevant * information for each SCTP entity * created. This includes its filedescriptor * and other goodies we need when working * with a individual sctp. */struct SCTP{  /* a flag representing the last addr I sent to the deamon on */  short lastDeamon;  short	usingTheDeamon;	/* flag to tell me I use the deamon vs			 * FreeBSD socket of SCTP type.			 */  /* List of associations, this is the head   * of a doubly linked list. We keep this   * for ease of walking through the entire   * list when looking at every associations   * (like the add/del ip addr). We would use   * the library class but then we would not   * be able to easily remove a entry from   * the table, since we always have the   * association, but you would need to search   * through the list if the prev/next pointer    * were tracked in seperate data structures.   */  struct SCTP_association *assoc;  /* The hash of all the associations. This   * holds a mix of IPv4 and IPv6 addresses. The   * same TCB may appear multiple times it this   * table, keyed by each of its IP addresses.   */  HashedTbl *allAssoc;  /* secret key stuff used with state cookie */  int currentSecretNumber;  int lastSecretNumber;  int timeOfSecretChange; /* time() form */  unsigned long secretKey[SCTP_HOW_MANY_SECRETS][SCTP_NUMBER_OF_SECRETS];  int sizeOfACookie;  struct SCTP_TimerInfo cookieTime;  /* port number of process */  u_short port;  /* total number of dg's inqueued to be picked up i.e read */  int numberInbound;  /* all ready to be read TSN's go in this queue */  struct SCTP_transmitOnQueue *inqueue;  struct SCTP_transmitOnQueue *inqueueLast;  /* file descriptor of bound socket */  int fd;  /* debug output */  FILE *debugfd;  int pid;  /* the functions I call with events/for service */  void (*timer)(struct SCTP *,void *,int,int,int);  void (*changeMask)(int,int);  void (*notify)(int,char*,int);  void (*getTime)(struct timespec *);  /* number of networks I have */  int numberOfNets;  int numberOfNetsAlloced;  /* array of my networks and masks for each */  struct sockaddr **localNets;  struct sockaddr_in *maskList;  struct sockaddr_in *broadList;  struct sockaddr *preferedRemPrimary;  int *mtuList;  unsigned int max_mtu;  /* base timeout that every one uses to start    * on first send.    */  int baseTimeoutSecs[SCTP_NUM_TMRS];  int baseTimeoutNSecs[SCTP_NUM_TMRS];  /* various thresholds */  /* Max times I will init at a guy */  u_long maxInitTimes;  /* Max times I will send before we consider someone dead */  u_long maxSendTimes;  /* current window default rwnd  value  for me*/  u_long maxWindow;  /* max size reassembly I will support */  u_long maxMsgSiz;  /* current number of overall outstanding dg's before   * I begin to fail sends instead of queueing.   */  u_long currentOut;  /* number of streams to pre-open on a association */  u_long preOpenStreamCount;  /* which outbound strms are unreliable */  /* defined as sets of <start:end> pairs */  int unrelStreamSets[MAX_UNRELSTREAM_SETS*2];  /* default send mode */  long sendOptionsDef;  /* if so ttl for ip datagrams */  int ttl;  /* if so tos for ip datagrams */  int tos;  /* random number fd */  int fird;  /* Random loss percentage */  int randomLoss;  /* if raw ip out the ip datagram counter */  unsigned short ipcounter;  unsigned short padding;  unsigned int randomCounter;	  unsigned char randomNumbers[SCTP_SIGNATURE_SIZE];  unsigned char randomStore[SCTP_SIGNATURE_SIZE];  char storeAt;  char maxBurst;  char hasV6;  char disableV6;  int defCookieLife;};/* this is the registration/deregistration message */struct deamonRegister{  unsigned char ver_len;  unsigned char tos;  unsigned char msgType;  unsigned char pad;};#ifdef	__cplusplus}#endif#endif