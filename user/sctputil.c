/* SCTP reference Implementation Copyright (C) 2001 Cisco And MotorolaThis file is part of the SCTP reference ImplementationVersion:4.0.5$Header: /home/sourceTree/src/sctp/user/sctputil.c,v 1.81 2001/07/24 11:52:39 randall Exp $The SCTP reference implementation  is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published bythe Free Software Foundation; either version 2, or (at your option)any later version.the SCTP reference implementation  is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of                ************************MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See theGNU Library General Public License for more details.You should have received a copy of the GNU Library General Public Licensealong with GNU CC; see the file COPYING.  If not, write tothe Free Software Foundation, 59 Temple Place - Suite 330,Boston, MA 02111-1307, USA.  Please send any bug reports or fixes you make to one of the following emailaddresses:rrs@cisco.comkmorneau@cisco.comqxie1@email.mot.comAny bugs reported given to us we will try to fix... any fixes shared willbe incorperated into the next SCTP release.There are still LOTS of bugs in this code... I always run on the motto"it is a wonder any code ever works :)"*/#include <sctp.h>#include <sctpinbound.h>#include <md5driver.h>#include <sctpsenders.h>#include <sctpHeader.h>#include <sys/time.h>#include <netdb.h>#include <sctpinitiate.h>#include <dlist.h>#ifdef SOLARIS/* Solaris does not define the MTU macro so we will */#define	ifr_mtu		ifr_ifru.ifru_index	/* mtu			*//* some other solaris items */static int error_num;#define gethostbyname2(name,prot) \        getipnodebyname((const char*)name, prot, 0, &error_num)#endif/* Open a file safely also if we are in a world writable directory like /tmp. * Return a FILE pointer on success, NULL on failure. * * To avoid symlink security tricks, we must check that the file doesn't * exist before opening it. The check must be atomic, so the combination * access() + fopen() is insecure, because a race is possible. * Since the clients of this function want a FILE pointer, we use open() * with proper flags + fdopen(). */FILE *SCTPsafefopen(const char *name){    int fd;    FILE *fp;  if ( (fd = open(name, O_CREAT | O_EXCL | O_RDWR,                  S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)) < 0) {      perror("SCTPsafeFopen: open");      return NULL;  }  if ( (fp = fdopen(fd, "w+")) == NULL) {      perror("SCTPsafeFopen: fdopen");      return NULL;  }  return fp;}#ifdef DEBUG_ONint SCTPvwrite(struct SCTP *m,char *format, va_list ap){  /* if debug is on, this will write out   * the strings reformatting on the way.. to the   * proper file.   */  struct tm *tm;  struct timespec t;#if (defined (LINUX) || defined(TRU64) || defined(AIX) )   struct timeval tv;#endif  if(m->debugfd == NULL){    return(0);  }#if !(defined (LINUX) || defined(TRU64) || defined(AIX) )   clock_gettime(CLOCK_REALTIME,&t);#else  gettimeofday(&tv,NULL);  TIMEVAL_TO_TIMESPEC(&tv,&t);#endif  tm = localtime( (time_t *)&(t.tv_sec) );  if(fprintf(m->debugfd, "refimpl:SCTP:[%d] ",m->pid) < 1)    return(-1);  if(fprintf(m->debugfd, "%d/%d %d:%d:%d.%d - ",	     (tm->tm_mon+1),	     tm->tm_mday,	     tm->tm_hour,	     tm->tm_min,	     tm->tm_sec,	     (int)(t.tv_nsec/1000000)) < 1)    return(-1);  if(vfprintf(m->debugfd, format, ap) < 1)    return(-1);  fflush(m->debugfd);  return(0);}voidSCTPdebugPrint(struct SCTP *m,char *f,...){  /* if debug is on print a string */  if(m->debugfd){    va_list va;    va_start(va,f);    SCTPvwrite(m,f,va);    va_end(va);    return;  }}voidSCTPprintArry(struct SCTP *m,unsigned char *data,int sz){  /* if debug is on hex dump a array */  int i,j,linesOut;  char buff1[64];  char buff2[64];  char *ptr1,*ptr2,*dptrlast,*dptr;  char *hexes = "0123456789ABCDEF";  ptr1 = buff1;  ptr2 = buff2;  dptrlast = dptr = (char *)data;  if(m->debugfd == NULL){    return;  }	  for(i=0,linesOut=0;i<sz;i++){    *ptr1++ = hexes[0x0f&((*dptr)>>4)];    *ptr1++ = hexes[0x0f&(*dptr)];    *ptr1++ = ' ';    if((*dptr >= 040) && (*dptr <= 0176))      *ptr2++ = *dptr;    else      *ptr2++ = '.';    dptr++;    if(((i+1) % 16) == 0){      *ptr1 = 0;      *ptr2 = 0;      fprintf(m->debugfd,"%s %s\n",buff1,buff2);      linesOut++;      ptr1 = buff1;      ptr2 = buff2;      dptrlast = dptr;    }  }  if((linesOut*16) < sz){    char spaces[64];    int dist,sp;    j=(linesOut*16);    dist = ((16 - (i - j)) * 3) + 2;    *ptr1 = 0;    *ptr2 = 0;    for(sp=0;sp<dist;sp++){      spaces[sp] = ' ';    }    spaces[sp] = 0;    fprintf(m->debugfd,"%s %s%s\n",buff1,spaces,buff2);  }  fflush(m->debugfd);}voidSCTPdebugPrintArry(struct SCTP *m,unsigned char *arry,int sz){  /* if debug is on hex dump a array */  if(m->debugfd){    SCTPprintArry(m,arry,sz);    return;  }}voidSCTPdebugPrintAddress(struct SCTP *m, struct sockaddr *a){  char stringToPrint[256];  char *srcaddr,*txt;  u_short prt;  if(a->sa_family == AF_INET){    srcaddr = (char *)&((struct sockaddr_in *)a)->sin_addr;    txt = "IPv4 Address: ";    prt = ntohs(((struct sockaddr_in *)a)->sin_port);  }else if(a->sa_family == AF_INET6){    srcaddr = (char *)&((struct sockaddr_in6 *)a)->sin6_addr;    txt = "IPv6 Address: ";    prt = ntohs(((struct sockaddr_in6 *)a)->sin6_port);  }else{    return;  }  if(inet_ntop(a->sa_family,srcaddr,stringToPrint,sizeof(stringToPrint))){	  if(a->sa_family == AF_INET6){		  SCTPdebugPrint(m,"%s%s:%d scope:%d\n",		      txt,stringToPrint,prt,		      ((struct sockaddr_in6 *)a)->sin6_scope_id);	  }else{		  SCTPdebugPrint(m,"%s%s:%d\n",txt,stringToPrint,prt);	  }  }else{    SCTPdebugPrint(m,"%s unprintable?\n",txt);  }}#elseinline voidSCTPdebugPrint(struct SCTP *m,char *f,...) {} inline voidSCTPdebugPrintArry(struct SCTP *m,unsigned char *arry,int sz) {}inline voidSCTPdebugPrintAddress(struct SCTP *m, struct sockaddr *a){}#endifvoidSCTPPrintAnAddress(struct sockaddr *a){  char stringToPrint[256];  u_short prt;  char *srcaddr,*txt;  if(a->sa_family == AF_INET){    srcaddr = (char *)&((struct sockaddr_in *)a)->sin_addr;    txt = "IPv4 Address: ";    prt = ntohs(((struct sockaddr_in *)a)->sin_port);  }else if(a->sa_family == AF_INET6){    srcaddr = (char *)&((struct sockaddr_in6 *)a)->sin6_addr;    prt = ntohs(((struct sockaddr_in6 *)a)->sin6_port);    txt = "IPv6 Address: ";  }#if ! (defined (LINUX))  else if(a->sa_family == AF_LINK){    int i;    char tbuf[200];    u_char adbuf[200];    struct sockaddr_dl *dl;    dl = (struct sockaddr_dl *)a;    strncpy(tbuf,dl->sdl_data,dl->sdl_nlen);    tbuf[dl->sdl_nlen] = 0;    printf("Intf:%s (len:%d)Interface index:%d type:%x(%d) ll-len:%d ",	   tbuf,	   dl->sdl_nlen,	   dl->sdl_index,	   dl->sdl_type,	   dl->sdl_type,	   dl->sdl_alen	   );    memcpy(adbuf,LLADDR(dl),dl->sdl_alen);    for(i=0;i<dl->sdl_alen;i++){      printf("%2.2x",adbuf[i]);      if(i<(dl->sdl_alen-1))	printf(":");    }    printf("\n");    /*	u_short	sdl_route[16];*/	/* source routing information */    return;  }#endif  else{    return;  }  if(inet_ntop(a->sa_family,srcaddr,stringToPrint,sizeof(stringToPrint))){	  if(a->sa_family == AF_INET6){		  printf("%s%s:%d scope:%d\n",		      txt,stringToPrint,prt,		      ((struct sockaddr_in6 *)a)->sin6_scope_id);	  }else{		  printf("%s%s:%d\n",txt,stringToPrint,prt);	  }  }else{    printf("%s unprintable?\n",txt);  }}#ifdef _WRAP_MEMORY_DEBUGvoid *w_malloc(struct SCTP *m,size_t size){  void *v;  v = malloc(size);  SCTPdebugPrint(m,"Malloc gets %x\n",(u_int)v);  return(v);}void *w_calloc(struct SCTP *m,size_t size,size_t num){  void *v;  v = calloc(size,num);  SCTPdebugPrint(m,"Calloc gets %x\n",(u_int)v);  return(v);}voidw_free(struct SCTP *m,void *fre){  SCTPdebugPrint(m,"Freeing %x\n",(u_int)fre);  free(fre);}#else#define w_malloc(m,s) malloc(s)#define w_calloc(m,s,n) calloc(s,n)#define w_free(m,f) free(f)#endifstruct sctpParamDesc *findAParameter(struct SCTP *m,	       u_short ptype,	       u_char *paramarea,	       int sizeLimit,	       int *deadflag,char **report,int *sizeOfOpErr){  struct sctpParamDesc *fnd,*look;  char *listOut;  int at,nxtSz;  u_short plookat,plen;  at = 0;  fnd = NULL;  listOut = NULL;  look = (struct sctpParamDesc *)paramarea;  *sizeOfOpErr = 0;  SCTPdebugPrint(m,"In findAParameter sizeLimit:%d looking for:%4.4x\n",		 sizeLimit,ptype);  while(at < sizeLimit){    /* is it this one? */    plen = ntohs(look->paramLength);    if((plen < sizeof(struct sctpParamDesc)) || (plen > (sizeLimit-at))){      SCTPdebugPrint(m,"Invalid parameter has a length of %d\n",plen);      *deadflag = 1;      return(NULL);    }    plookat = ntohs(look->paramType);    if(ptype == plookat){      fnd = look;    }    if((plookat == SCTP_ECN_I_CAN_DO_ECN) ||       (plookat == SCTP_HOSTNAME_VIA_DNS) ||        (plookat == SCTP_IPV6_PARAM_TYPE) ||       (plookat == SCTP_RESPONDER_COOKIE) ||       (plookat == SCTP_UNRECOG_PARAM) ||       (plookat == SCTP_COOKIE_PRESERVE) ||       (plookat == SCTP_SETADDRESS_PRIMARY) ||       (plookat == SCTP_HOSTNAME_VIA_DNS) ||        (plookat == SCTP_RESTRICT_ADDR_TO) ||       (plookat == SCTP_UNRELIABLE_STRM)){      /* recognized types don't cause us any problem */      SCTPdebugPrint(m,"Parmeter type %d recognized (len:%d)\n",		     plookat,plen);    }else if((plookat == SCTP_IPV4_PARAM_TYPE) || 	     (plookat == SCTP_IPV6_PARAM_TYPE)){      /* Check for multicast here */      if(plookat == SCTP_IPV4_PARAM_TYPE){	struct sctpV4IpAddress *p;	p = (struct sctpV4IpAddress *)look;	if(IN_MULTICAST(p->ipAddress)){	  SCTPdebugPrint(m,"GAK, peer sends IPV4 Multi-cast address\n");	  *deadflag = 1;	  return(NULL);	}      }else{	struct sockaddr_in6 in6;	struct sctpV6IpAddress *p6;	p6 = (struct sctpV6IpAddress *)look;	memcpy((char *)&in6.sin6_addr,		p6->ipAddress,	       sizeof(struct in6_addr));	if(IN6_IS_ADDR_MULTICAST(&in6.sin6_addr)){	  SCTPdebugPrint(m,"GAK, peer sends IPV6 Multi-cast address\n");	  *deadflag = 1;	  return(NULL);	}      }    }else{      /* Ok the else is really what we did all       * this for :) we want to do the bit munging       * of the upper bits to see how to treat this.       */      SCTPdebugPrint(m,"Parameter type %4.4x NOT recognized\n",plookat);      if((plookat & 0x8000) == 0x0000){	SCTPdebugPrint(m,"Dead flag set!\n");	*deadflag = 1;      }      if((plookat & 0x4000) == 0x4000){	/* report it flag, build a Op Err segment (if not built)	 * and add on this dude	 */	int len;	SCTPdebugPrint(m,"Asked to report\n");	len = ntohs(look->paramLength);	if(listOut == NULL){	  int aloc;	  aloc = ((((sizeof(struct sctpUnifiedOpError) + len) + 3) >> 2) << 2);	  listOut = w_calloc(m,1,aloc);	  if(listOut != NULL){	    struct sctpUnifiedOpError *list;	    char *x;	    list = (struct sctpUnifiedOpError *)listOut;	    x = (char *)((u_long)list + sizeof(struct sctpUnifiedOpError));	    list->uh.chunkID = SCTP_OPERATION_ERR;	    list->uh.chunkFlg = 0;	    list->uh.chunkLength = htons((sizeof(struct sctpUnifiedOpError) + len));	    list->c.cause = htons(SCTP_OP_ERROR_UNK_PARAM);	    list->c.causeLen = htons(sizeof(struct sctpOpErrorCause) + len);	    SCTPdebugPrint(m,"Copy %d bytes from:\n",len);	    SCTPdebugPrintArry(m,(char *)look,len);	    memcpy(x,look,len);	    if(len % 4){	      /* null out the pad bytes */	      SCTPdebugPrint(m,"Zap end bytes starting at:%d\n",len); 	      memset(&x[len],0,(4-(len % 4)));	    }	    *sizeOfOpErr = aloc;		  }	}else{	  int aloc,newport;	  char *newList;	  newport = ((((sizeof(struct sctpOpErrorCause) + len) + 3) >> 2) << 2);	  aloc = newport + *sizeOfOpErr;	  newList = w_calloc(m,1,aloc);	  if(newList != NULL){	    struct sctpUnifiedOpError *list;	    struct sctpOpErrorCause *clist;	    char *x;	    memcpy(newList,listOut,*sizeOfOpErr);	    w_free(m,listOut);	    listOut = newList;	    list = (struct sctpUnifiedOpError *)listOut;	    clist = (struct sctpOpErrorCause *)(&listOut[*sizeOfOpErr]);	    x = (char *)((u_long)clist + sizeof(struct sctpOpErrorCause));	    list->uh.chunkLength = htons(*sizeOfOpErr + sizeof(struct sctpOpErrorCause) + len);	    clist->cause = htons(SCTP_OP_ERROR_UNK_PARAM);	    clist->causeLen = htons(sizeof(struct sctpOpErrorCause) + len);	    memcpy(x,look,len);	    if(len % 4){	      /* null out the pad bytes */	      memset(&x[len],0,(4 - (len%4)));	    }	    *sizeOfOpErr += newport;	  }	}      }    }    if(*deadflag){      SCTPdebugPrint(m,"Operational Error halts processing\n");      SCTPdebugPrintArry(m,listOut,*sizeOfOpErr);      *report = listOut;      return(NULL);    }    /* next size rounded to 32 bit boundary please */    nxtSz = (((plen+3) >> 2) << 2);    SCTPdebugPrint(m,"nxtSz is 0x%x??\n",(u_int)nxtSz);    if((nxtSz < 0) || (nxtSz > 0xffff)){      /* something is wrong */      SCTPdebugPrint(m,"Corrupt parameter seen nxtSz is 0x%x??\n",(u_int)nxtSz);      at = sizeLimit;    }else{      at += nxtSz;    }    SCTPdebugPrint(m,"now at %d\n",at);    look = (struct sctpParamDesc *)&paramarea[at];  }  if(*sizeOfOpErr){    *report = listOut;    SCTPdebugPrint(m,"Operational Error goes back to caller\n");    SCTPdebugPrintArry(m,listOut,*sizeOfOpErr);  }  return(fnd);}voidSCTPinitNetStruct(struct SCTP *m,		  struct SCTP_association *asoc,		  struct SCTP_nets *netp,		  struct sockaddr *from){  if(from->sa_family == AF_INET){    struct sockaddr_in *a,*f;    netp->ina = (struct sockaddr *)w_calloc(m,1,sizeof(struct sockaddr_in));    if(netp->ina == NULL)      /* Gak... we are dead */      return;    memset((char *)netp->ina,0,sizeof(struct sockaddr_in));    f = (struct sockaddr_in *)from;    a = (struct sockaddr_in *)netp->ina;#ifdef USES_BSD_4_4_SOCKET    a->sin_len = sizeof(struct sockaddr_in);#endif    a->sin_family = AF_INET;    a->sin_port = f->sin_port;    a->sin_addr = f->sin_addr;  }else{    struct sockaddr_in6 *a6,*f6;    netp->ina = (struct sockaddr *)w_calloc(m,1,sizeof(struct sockaddr_in6));    if(netp->ina == NULL)      /* Gak... we are dead */      return;    memset((char *)netp->ina,0,sizeof(struct sockaddr_in6));        f6 = (struct sockaddr_in6 *)from;    a6 = (struct sockaddr_in6 *)netp->ina;#ifdef USES_BSD_4_4_SOCKET    a6->sin6_len = sizeof(struct sockaddr_in6);#endif    a6->sin6_port = f6->sin6_port;    a6->sin6_family = AF_INET6;    a6->sin6_addr = f6->sin6_addr;    SCTPdebugPrint(m,"Init a address v6 with scope:%d\n",	f6->sin6_scope_id);    if(IN6_IS_ADDR_LINKLOCAL(&a6->sin6_addr)){	    SCTPdebugPrint(m,"Copy scope\n");	    a6->sin6_scope_id = f6->sin6_scope_id;    }      }  netp->errorCount = 0;  netp->lastsa = 0;  netp->lastsv = 0;  netp->RTO = 0;  netp->flightSize = 0;  netp->netAck = netp->netAck2 = 0;  netp->cwnd = asoc->smallestMTU * 2;  netp->partial_bytes_acked = 0;  netp->rtoPending = 0;  netp->MTU = asoc->smallestMTU;  netp->ssthresh = asoc->peersRwnd;  netp->lastSentTime.tv_sec = 0;  netp->lastSentTime.tv_nsec = 0;  netp->failureThreshold = asoc->maxSendTimes / 2;  netp->intfRotationState = SCTP_ADDR_REACHABLE;}intSCTPmakeAnyDNSQuery(struct SCTP *m,		    struct SCTP_association *asoc){  /* This is WILL block, which should mess things   * up nicely if I get to busy, so I really don't   * care for this... but I am not going to dig through   * the DNS lib to figure out how to make it non-blocking   * and add state etc.etc.etc ... in the kernel this will   * become even harder ... bad news for you if you   * have to port it :-(   */  struct hostent *hst;  struct SCTP_nets *nets,*onets;  char *addrAt;  int fnd,sawFrom;  int stop,i,oldnumnets,start;  int sizKey;	  int rret;  sawFrom = fnd = 0;  /* first count the IPv4 addresses */  hst = gethostbyname2(asoc->DNSname,AF_INET);  if((hst != NULL) && (hst->h_length > 0)){    SCTPdebugPrint(m,"Found some AF_INET addresses for name\n");    stop = 0;    i = 0;    while(!stop){      addrAt = hst->h_addr_list[i];      if(addrAt == NULL){	stop = 1;	continue;      }      if((asoc->nets[0].ina->sa_family == AF_INET) &&	 (sawFrom == 0)){	char *test;	test = (char *)&((struct sockaddr_in *)(asoc->nets[0].ina))->sin_addr;	if(memcmp(test,addrAt,sizeof(struct in_addr)) == 0){	  sawFrom = 1;	}      }      fnd++;      i++;    }  }  /* Now, can we get any IPv6 addresses? */  hst = gethostbyname2(asoc->DNSname,AF_INET6);  if((hst != NULL) && (hst->h_length > 0)){    SCTPdebugPrint(m,"Found some AF_INET6 addresses for name\n");    stop = 0;    i = 0;    while(!stop){      addrAt = hst->h_addr_list[i];      if(addrAt == NULL){	stop = 1;	continue;      }      if((asoc->nets[0].ina->sa_family == AF_INET6) &&	 (sawFrom == 0)){	char *test;	test = (char *)&((struct sockaddr_in6 *)(asoc->nets[0].ina))->sin6_addr;	if(memcmp(test,addrAt,sizeof(struct in6_addr)) == 0){	  sawFrom = 1;	}      }      fnd++;      i++;    }  }  if(fnd == 0){    /* no addresses found */    return(-1);  }  /* Allocate enough for the found nets */  SCTPdebugPrint(m,"Found a total of %d addresses for name:%s\n",fnd,asoc->DNSname);  oldnumnets = asoc->numnets;  onets = asoc->nets;  if(sawFrom){    nets = w_calloc(m,fnd,(sizeof(struct SCTP_nets)));    asoc->numnets = fnd;  }else{    /* you can't escape getting the from address too */    SCTPdebugPrint(m,"Hmm, DNS name did NOT include the from address, adding\n");    nets = w_calloc(m,(fnd+1),(sizeof(struct SCTP_nets)));    asoc->numnets = fnd + 1;  }  if(nets == NULL){    asoc->numnets = oldnumnets;    return(-1);  }  if(sawFrom == 0){    /* Glom in the first address from the old array */    memcpy((char *)&nets[0],(char *)&asoc->nets[0],sizeof(struct SCTP_nets));    /* We just stole the sockaddr pointer */    asoc->nets[0].ina = NULL;    start = 1;  }else{    start = 0;  }  /* Commit to the new list, we first   * delete all the addresses and things   */  for(i=0;i<oldnumnets;i++){    if(onets[i].ina != NULL){      struct SCTP_association *lasoc;      /* we will also remove any hash too,       * this really should not find a       * match but we will be careful here.       */      if(onets[i].ina->sa_family == AF_INET)	sizKey = sizeof(struct sockaddr_in);      else if(onets[i].ina->sa_family == AF_INET6)	sizKey = sizeof(struct sockaddr_in6);      else	sizKey = 0;      if(sizKey){	lasoc = (struct SCTP_association *)HashedTbl_remove(m->allAssoc,							    (void *)onets[i].ina,							    sizKey,(void **)NULL);	if(lasoc != NULL){	  SCTPdebugPrint(m,"Found a key during DNS update?\n");	}      }      w_free(m,onets[i].ina);    }  }  w_free(m,onets);  /* then set in the new list */  asoc->nets = nets;  /* Now back through the DNS lookups to populate addresses in ina */  if(hst != NULL){    /* re-use the AF_INET6 addresses I already have */    struct sockaddr_in6 xx6;    SCTPdebugPrint(m,"Found some AF_INET6 addresses for name\n");    stop = 0;    i = 0;    memset(&xx6,0,sizeof(xx6));    xx6.sin6_port = m->port;    xx6.sin6_family = AF_INET6;#ifdef USES_BSD_4_4_SOCKET    xx6.sin6_len = sizeof(struct sockaddr_in6);#endif    while(!stop){      addrAt = hst->h_addr_list[i];      if(addrAt == NULL){	stop = 1;	continue;      }      memcpy(xx6.sin6_addr.s6_addr,addrAt,sizeof(struct in6_addr));      SCTPdebugPrint(m,"Adding IPv6 Address from DNS\n");      SCTPdebugPrintAddress(m,(struct sockaddr *)&xx6);      SCTPinitNetStruct(m,asoc,&asoc->nets[start],(struct sockaddr *)&xx6);      start++;      i++;    }  }  /* Now go get the AF_INET names */  hst = gethostbyname2(asoc->DNSname,AF_INET);  if((hst != NULL) && (hst->h_length > 0)){    struct sockaddr_in xx;    SCTPdebugPrint(m,"Found some AF_INET addresses for name\n");    memset(&xx,0,sizeof(xx));    xx.sin_port = m->port;    xx.sin_family = AF_INET;#ifdef USES_BSD_4_4_SOCKET    xx.sin_len = sizeof(struct sockaddr_in);#endif    i = 0;    stop = 0;    while(!stop){      addrAt = hst->h_addr_list[i];      if(addrAt == NULL){	stop = 1;	continue;      }      memcpy((char *)&xx.sin_addr,addrAt,sizeof(struct in_addr));      SCTPdebugPrint(m,"Adding IPv4 Address from DNS\n");      SCTPdebugPrintAddress(m,(struct sockaddr *)&xx);      SCTPinitNetStruct(m,asoc,&asoc->nets[start],(struct sockaddr *)&xx);      start++;      i++;    }  }  /* Now that all addresses and structures are   * properly populated lets go ahead and   * load the hash table with the addresses.   */  for(i=0;i<asoc->numnets;i++){    if(asoc->nets[i].ina->sa_family == AF_INET)      sizKey = sizeof(struct sockaddr_in);    else if(asoc->nets[i].ina->sa_family == AF_INET6)      sizKey = sizeof(struct sockaddr_in6);    else      sizKey = 0;    if(sizKey){      rret = HashedTbl_enter(m->allAssoc,			     (void *)asoc->nets[i].ina,			     (void *)asoc,sizKey);      if(rret != LIB_STATUS_GOOD){	SCTPdebugPrint(m,"Warning, possible DNS keyed corrupt association\n");      }    }  }  return(0);}int  SCTPselectNextLan(struct SCTP *m,		       struct SCTP_association *asoc){  int i, indx, fnd, cnt;  /* For the given association, select the next destination address    * to send on, based on the current reachability of each path   */  SCTPdebugPrint(m, "BEGIN: SCTPselectNextLan \n");  SCTPdebugPrint(m,"finding next lan to use out of %d last used %d\n",		 asoc->numnets,asoc->lastNetSentTo);  cnt = fnd = 0;  indx = asoc->lastNetSentTo+1; /* start from the last used */  if(indx >= asoc->numnets)     indx = 0;  for(i=0; i<asoc->numnets; i++) {    SCTPdebugPrint(m,"look at %d\n",indx);    if((asoc->nets[indx].intfRotationState&SCTP_ADDR_NOT_REACHABLE) ==        SCTP_ADDR_NOT_REACHABLE){      /* Skip known bad lans */      SCTPdebugPrint(m,"Can't select this one, it's unreachable\n");      indx++;      cnt++;      if(indx >= asoc->numnets) 	indx = 0;      if(cnt > asoc->numnets){	/* endless loop prevention */	break;      }      continue;    }    fnd=1;    break;  }  SCTPdebugPrint(m,"Last:%d fnd:%d i:%d\n",		 asoc->lastNetSentTo,fnd,indx);  if(!fnd){    /* can't find anything.. just     * give the last one given     */    SCTPdebugPrint(m, "BEGIN: SCTPselectNextLan \n");    return(asoc->lastNetSentTo);  }  /* we found someone.. return it */  SCTPdebugPrint(m, "END: SCTPselectNextLan \n");  return(indx);}voidSCTPupperLayerNotification(struct SCTP *m,			   struct SCTP_association *asoc,			   int eventToNotify,			   int asocAddress){  /* this is the upper layer notification modual.   * it handles notification of the upper layer of   * any change int a assocation.   */  SCTPdebugPrint(m, "BEGIN: SCTPupperLayerNotification \n");  switch(eventToNotify){  case SCTP_NOTIFY_HB_RESP:    (*m->notify)(eventToNotify,(char *)asocAddress,		 sizeof(struct sctpHBsender));    break;  case SCTP_NOTIFY_ASSOC_UP:    /* association is up */	    (*m->notify)(eventToNotify,(char *)asocAddress,sizeof(struct sockaddr_in));    break;  case SCTP_NOTIFY_ASSOC_DOWN:    /* association is down */    (*m->notify)(eventToNotify,(char *)asocAddress,sizeof(struct sockaddr_in));    break;  case SCTP_NOTIFY_ASSOC_RESTART:    (*m->notify)(eventToNotify,(char *)asocAddress,sizeof(struct sockaddr_in));    break;  case SCTP_NOTIFY_INTF_DOWN:    /* interface on a association is down     * and out of consideration for selection.     */    (*m->notify)(eventToNotify,(char *)asocAddress,sizeof(struct sockaddr_in));    break;  case SCTP_NOTIFY_INTF_UP:   /* interface on a association is up    * and now back in consideration for selection.    */    (*m->notify)(eventToNotify,(char *)asocAddress,sizeof(struct sockaddr_in));    break;  case SCTP_NOTIFY_DG_FAIL:    /* The given datagram cannot be delivered     * to the peer, this will probably be followed     * by a SCTP_NOTFIY_ASSOC_DOWN.     */    printf("Datagram cannot be delivered info:%x\n",      (u_int)asocAddress);    break;  case SCTP_NOTIFY_STREAM_OPENED_OK:    (*m->notify)(eventToNotify,(char *)asocAddress,sizeof(int));    break;  case SCTP_NOTIFY_PEER_OPENED_STR:    break;  case SCTP_NOTIFY_ASSOC_ABORTED:    (*m->notify)(eventToNotify,(char *)asocAddress,sizeof(struct sockaddr_in));    break;  default:    printf("Software error unknown notify event %d\n",	   eventToNotify);    break;  }}voidSCTPmakeIntoSock(unsigned char *ptr,		 struct SCTP_association *asoc,		 int net){  /* convert a network index into the correct socket address type */  if(net > asoc->numnets)    /* paranoid */    return;  if(asoc->nets[net].ina->sa_family == AF_INET){    struct sockaddr_in *to,*lto;    memset(ptr,0,sizeof(struct sockaddr_in));    to = (struct sockaddr_in *)ptr;    lto = (struct sockaddr_in *)asoc->nets[net].ina;    to->sin_addr.s_addr = lto->sin_addr.s_addr;    to->sin_port = lto->sin_port;    to->sin_family = AF_INET;#ifdef USES_BSD_4_4_SOCKET    to->sin_len = sizeof(struct sockaddr_in);#endif  }else if(asoc->nets[net].ina->sa_family == AF_INET6){    struct sockaddr_in6 *to6,*lto6;    memset(ptr,0,sizeof(struct sockaddr_in6));    lto6 = (struct sockaddr_in6 *)asoc->nets[net].ina;    to6 = (struct sockaddr_in6 *)ptr;    to6->sin6_port = lto6->sin6_port;    to6->sin6_family = AF_INET6;    to6->sin6_addr = lto6->sin6_addr;    to6->sin6_scope_id = lto6->sin6_scope_id;#ifdef USES_BSD_4_4_SOCKET    to6->sin6_len = sizeof(struct sockaddr_in6);#endif  }}voidSCTPmakeIntoLocalSock(unsigned char *ptr,		      struct SCTP_association *asoc,		      int net){  /* convert a local network address into the correct format */  if(asoc->localNets[net]->sa_family == AF_INET){    struct sockaddr_in *to,*lto;    memset(ptr,0,sizeof(struct sockaddr_in));    to = (struct sockaddr_in *)ptr;    lto = (struct sockaddr_in *)asoc->localNets[net];    to->sin_addr.s_addr = lto->sin_addr.s_addr;    to->sin_port = lto->sin_port;    to->sin_family = AF_INET;#ifdef USES_BSD_4_4_SOCKET    to->sin_len = sizeof(struct sockaddr_in);#endif  }else if(asoc->localNets[net]->sa_family == AF_INET6){    struct sockaddr_in6 *to6,*lto6;    memset(ptr,0,sizeof(struct sockaddr_in6));    lto6 = (struct sockaddr_in6 *)asoc->localNets[net];    to6 = (struct sockaddr_in6 *)ptr;    to6->sin6_port = lto6->sin6_port;    to6->sin6_family = AF_INET6;    to6->sin6_addr = lto6->sin6_addr;    to6->sin6_scope_id = lto6->sin6_scope_id;#ifdef USES_BSD_4_4_SOCKET    to6->sin6_len = sizeof(struct sockaddr_in6);#endif  }}voidSCTPfillRandomStore(struct SCTP *m){  /* Here we use the MD5/SHA-1 to hash with   * our good randomNumbers and our counter.   * The result becomes our good random numbers and   * we then setup to give these out.   */   m->storeAt = 0;   sctpMd5Digest(m,                 (char *)m->randomNumbers,sizeof(m->randomNumbers),                 (char *)&m->randomCounter,sizeof(m->randomCounter),                 (char *)m->randomStore);   m->randomCounter++;}u_long SCTPselectATag(struct SCTP *m){  /* A real implementation must use random selection process to   * get a tag between 0x1 - 0xffffffff (refer to RFC1750)   * This is simplified for illustration purpose.   */  u_long x,*xp;  unsigned char *p;  if(m->fird == -1){    SCTPdebugPrint(m,"Warning, unsecure no random device\n");    do { x = (u_long)mrand48(); } while( x==0 );  }else{	  if((m->storeAt+sizeof(u_long)) > SCTP_SIGNATURE_SIZE){		  /* Refill the random store */		  SCTPfillRandomStore(m);	  }	  p = &m->randomStore[(int)m->storeAt];	  xp = (u_long *)p;	  x = *xp;	  if(x == 0){    	    x++;	  }	  m->storeAt+= sizeof(u_long);  }  SCTPdebugPrint(m,"Random number %x choosen\n",(u_int)x);  return(x);}u_long SCTPselectInitialTSN(struct SCTP *m){  /* A true implementation should use random selection process to   * get the initial stream sequence number, using RFC1750 as   * a good guideline.   * Here we simply use rand() for illustration purpose.   */#ifdef goodstuff  u_long x,*xp;  unsigned char *p;  if(m->fird == -1){    SCTPdebugPrint(m,"Warning, unsecure no random device\n");    x = (u_long)mrand48();  }else{	  if((m->storeAt+sizeof(u_long)) > SCTP_SIGNATURE_SIZE){		  /* Refill the random store */		  SCTPfillRandomStore(m);	  }	  p = &m->randomStore[(int)m->storeAt];	  xp = (u_long *)p;	  x = *xp;	  m->storeAt+= sizeof(u_long);  }  SCTPdebugPrint(m,"Random number %x choosen\n",(u_int)x);  return(x);#endif  return(1);}voidSCTPinitAAssociation(struct SCTP *m,struct SCTP_association *asoc,		     struct sockaddr *to,int locScope,int siteScope,		     int ipv4Scope){  int i,at;  /* Up front select what scoping to apply on   * addresses I tell my peer   */  asoc->locScope = locScope;  asoc->siteScope = siteScope;  asoc->ipv4Scope = ipv4Scope;  /* init all variables to a known value.*/  asoc->lastHBOn = 0;  asoc->gotLastHB = 0;  asoc->reallySentHB = 0;  asoc->totalFlight = 0;  asoc->numnets = 0;  asoc->primary_destination = 0;  asoc->nets = NULL;  asoc->overallErrorCount = 0;  asoc->lastNetSentTo = 0;  asoc->outQueueCount = 0;  asoc->streamincnt = 0;  asoc->streamoutcnt = 0;  /* init the ECN stuff */  asoc->ECN_Allowed = 0;  asoc->lastEcho_TSN = 0;  asoc->lastCWR_TSN = 0;  asoc->tos = m->tos;  asoc->ECN_echo = NULL;  asoc->CWR = NULL;  asoc->numduptsns = 0;  asoc->restrictAddresses = 0;  asoc->firstAckUp = 1;  asoc->fastRetransmitCompletes = 0;  asoc->maxBurst = m->maxBurst;  /* init the pegs */  for(i=0;i<SCTP_NUMBER_OF_PEGS;i++){    asoc->pegs[i] = 0;  }  for(i=0;i<MAX_FSID;i++){    asoc->fsp1[i] = 0;    asoc->fsp2[i] = 0;    asoc->fsp3[i] = 0;    asoc->fsp4[i] = 0;    asoc->fsp5[i] = 0;  }  asoc->fsidx = 0;  asoc->heartBeatDelay = m->baseTimeoutSecs[SCTP_TIMER_HEARTBEAT];  asoc->cookie = NULL;  asoc->opErr = NULL;  asoc->opErrSiz = 0;  asoc->numberUnsent = 0;  asoc->numberToRetran = 0;  asoc->staleCookieCount = 0;  asoc->cookieLife = m->defCookieLife;  memset(asoc->DNSname,0,sizeof(asoc->DNSname));  asoc->lastNetRcvdFrom = 0;  asoc->sendsectim = m->baseTimeoutSecs[SCTP_TIMER_SEND];  asoc->sendusectim = m->baseTimeoutNSecs[SCTP_TIMER_SEND];  asoc->initsectim = m->baseTimeoutSecs[SCTP_TIMER_INIT];  asoc->initusectim = m->baseTimeoutNSecs[SCTP_TIMER_INIT];  asoc->t2recvinUsec = (			(m->baseTimeoutSecs[SCTP_TIMER_RECV]*1000000) +			(m->baseTimeoutNSecs[SCTP_TIMER_RECV]/1000));  asoc->preOpenStreams = m->preOpenStreamCount;  asoc->curTag = SCTPselectATag(m);  asoc->relReqSeqOut = asoc->initSeqNumber = asoc->sendingSeq = SCTPselectInitialTSN(m);  asoc->t3timeoutHighestMarked = asoc->relReqSeqOut;  asoc->relReqSeqIn = 0;  asoc->relReqSent = 0;  asoc->peerCanDoRelReq = 1;	/* we are optimistic here and hope he can :) */  asoc->relReqLastSentTo = 0;  asoc->queueOfRelReq = dlist_create();  asoc->pendingChunks = HashedTbl_create("pending chunks", 25);  asoc->lastSentRelReq = NULL;  asoc->lastSentRelAck = NULL;  asoc->relReqTmr.timerType = SctpTimerTypeNone;  asoc->relReqTmr.timerinfo = (void *)asoc;  asoc->relReqTmr.running = SCTP_TIMER_IDLE;  asoc->relReqTmr.countOf = 0;  asoc->lastCWR_TSN = asoc->initSeqNumber - 1;  asoc->lastAckedSeq = asoc->initSeqNumber - 1;  SCTPdebugPrint(m,"Selecting the Init seq %x\n",asoc->sendingSeq);  asoc->hisTag = 0;  asoc->maxInitTimes = m->maxInitTimes;  asoc->maxSendTimes = m->maxSendTimes;  asoc->maxWindow = m->maxWindow;  asoc->needToAck = 0;  asoc->myRwnd = m->maxWindow; /* copy in the amount of buffers I want */  asoc->peersRwnd = m->maxWindow; /* use my own max window until I learn */  SCTPdebugPrint(m,"Setting max seg in smallest MTU %d\n",		 SCTP_DEFAULT_MAXSEGMENT);  asoc->smallestMTU = SCTP_DEFAULT_MAXSEGMENT;  /* Now setup the local addresses, copied from the m structure */  asoc->lastAddrSourced = 0;  /* Gee, look ma more stuff to change when we support IPv6 .. yucko */  asoc->localNets = (struct sockaddr **)w_calloc(m,m->numberOfNets,sizeof(struct sockaddr *));  asoc->maskList = (struct sockaddr_in *)w_calloc(m,m->numberOfNets,sizeof(struct sockaddr));  for(i=0;i<m->numberOfNets;i++){    asoc->localNets[i] = NULL;  }  asoc->addrStats = w_calloc(m,m->numberOfNetsAlloced,sizeof(char));  for(i=0;i<m->numberOfNetsAlloced;i++){    asoc->addrStats[i] = 0;  }  asoc->numberOfNetsAlloced = m->numberOfNets;  asoc->numberOfNets = 0;    for(i=0,at=0;i<m->numberOfNets;i++){    struct sockaddr_in *ain,*min;    struct sockaddr_in6 *ain6,*min6;    if(m->localNets[i]->sa_family == AF_INET){      /* we copy all V4 addresses */      min = (struct sockaddr_in *)m->localNets[i];      if((asoc->ipv4Scope == 0) && (IN4_ISPRIVATE_ADDRESS(&min->sin_addr))){	SCTPdebugPrint(m,"Skipping a private address for assoc aloc\n");	continue;      }      asoc->localNets[at] = w_calloc(m,1,sizeof(struct sockaddr_in));      ain = (struct sockaddr_in *)asoc->localNets[at];      memset((char *)ain,0,sizeof(struct sockaddr_in));      ain->sin_family = AF_INET;      ain->sin_port = m->port;      ain->sin_addr = min->sin_addr;      asoc->addrStats[at] = SCTP_ADDR_REACHABLE;#ifdef USES_BSD_4_4_SOCKET      ain->sin_len = sizeof(struct sockaddr_in);#endif      memcpy((char *)&asoc->maskList[at],(char *)&m->maskList[i],sizeof(struct sockaddr_in));      at++;    }else if(m->localNets[i]->sa_family == AF_INET6){      /* we must look carefully here */      min6 = (struct sockaddr_in6 *)m->localNets[i];      SCTPdebugPrint(m,"See if IPv6 address %d can be used with scope:%d/%d\n",		     i,asoc->locScope,asoc->siteScope);      if((asoc->locScope == 0 ) && (IN6_IS_ADDR_LINKLOCAL(&min6->sin6_addr))){	/* skip this address since it is link local and	 * we do not allow link local on this 	 * association.	 */	SCTPdebugPrint(m,"No link local not allowed\n");	continue;      }      if((asoc->siteScope == 0) && (IN6_IS_ADDR_SITELOCAL(&min6->sin6_addr))){	/* skip this address since it is site local and	 * we do not allow site local on this	 * association.	 */	SCTPdebugPrint(m,"No site local not allowed\n");	continue;      }      /* Ok it is within scope to add */      SCTPdebugPrint(m,"Yep, placing address at %d\n",at);      asoc->localNets[at] = w_calloc(m,1,sizeof(struct sockaddr_in6));      ain6 = (struct sockaddr_in6 *)asoc->localNets[at];      memset((char *)ain6,0,sizeof(struct sockaddr_in6));      ain6->sin6_family = AF_INET6;      ain6->sin6_port = m->port;      ain6->sin6_addr = min6->sin6_addr;      if(m->disableV6 == 0){	asoc->addrStats[at] = SCTP_ADDR_REACHABLE;      }else{	asoc->addrStats[at] = SCTP_ADDR_NOT_IN_ASSOC;      }#ifdef USES_BSD_4_4_SOCKET      ain6->sin6_len = sizeof(struct sockaddr_in6);#endif      ain6->sin6_scope_id = min6->sin6_scope_id;      SCTPdebugPrint(m,"Setting in at %d:\n",at);      SCTPdebugPrintArry(m,(char *)&ain6->sin6_addr,sizeof(ain6->sin6_addr));      at++;          }  }  asoc->numberOfNets = at;  SCTPdebugPrint(m,"local addresses number %d with %d alloced\n",		 asoc->numberOfNets,		 asoc->numberOfNetsAlloced);  asoc->listConsistent = 1;  /* we put a positive foot forward */  asoc->supportsDynamicAddress = 1;  asoc->supportsDynamicSetPrim = 1;  asoc->mappingArray = NULL;  asoc->mappingArraySz = 0;  asoc->highestTSNinside = asoc->mappingArrayHighestTSN = 0;  for(i=0;i<SCTP_NUMBER_TIMERS;i++){    asoc->tmr[i].timerType = SctpTimerTypeNone;    asoc->tmr[i].timerinfo = (void *)asoc;    asoc->tmr[i].running = SCTP_TIMER_IDLE;    asoc->tmr[i].countOf = i;  }  /* copy in parents defaults */  asoc->sendMode = m->sendOptionsDef;    asoc->outqueue = NULL;  asoc->tailoutq = NULL;    asoc->sendqueue = NULL;  asoc->sendqueuetail = NULL;  /* stream 0 gets queued into this guy's */  asoc->outbound.nextSequenceSent = 0;  asoc->outbound.reliable = SCTP_STRM_RELIABLE;  asoc->inbound.lastSequenceDelivered = 0xffff;  asoc->inbound.inqueue = NULL;  asoc->inbound.reliable = SCTP_STRM_RELIABLE;  /* all other streams are in here after being   * opened.   */  asoc->strmin = NULL;  asoc->strmout = NULL;}voidSCTPupdateACookie(struct SCTP *m,		  struct SCTP_association *asoc,		  struct sctpUnifiedInit *msg,		  struct sockaddr *from){  struct sctpParamDesc *p;  struct sctpChunkDesc *t;  int at,max,fnd,csize;  u_short plen;  u_long calc;  /* this routine will pull out a cookie from the   * INIT-ACK and place it into the association    * structure in a form of a cookie chunk. The   * sendtoall (or resend for that matter) will pick   * this up and send it with the first datagram.   */  asoc->cookie = NULL;  at = sizeof(struct sctpUnifiedInit)-(sizeof(struct sctpParamDesc));  max = (ntohs(msg->uh.chunkLength) - sizeof(struct sctpChunkDesc));  p = (struct sctpParamDesc *)((u_long)msg + (sizeof(struct sctpUnifiedInit)));  fnd = 0;  /* count the number of param's and nets that are ipv4 */  while(at < max){    /* hunt for the cookie */    plen = ntohs(p->paramLength);    if((plen < sizeof(struct sctpParamDesc)) || (plen > (max-at))){      /* bad param */      fnd=0;      break;    }    SCTPdebugPrint(m,"At point 0x%x parameter is 0x%x \n",		   (u_int)p,(u_int)ntohs(p->paramType));    if(ntohs(p->paramType) == SCTP_RESPONDER_COOKIE){      SCTPdebugPrint(m,"Found the cookie!!\n");      fnd = 1;      break;    }    /* calc next and put on 4 octet boundary */    calc = (u_long)p + plen + 3;    calc >>= 2;    calc <<= 2;    SCTPdebugPrint(m,"At:%d calc:%x\n",at,calc);    at += (calc - (u_long)p);    SCTPdebugPrint(m,"At:%d added calc:%d max:%d\n",at,(calc - (u_long)p),max);    p = (struct sctpParamDesc *)calc;  }  if(!fnd){    /* no cookie so generate a dummy one */    SCTPdebugPrint(m,"Help no cookie found!!\n");    return;  }else{    /* we have a cookie pull it and make it     * into a chunk     */    csize = ntohs(p->paramLength) + 3;    /* round up to even boundary */    csize >>= 2;    csize <<= 2;    SCTPdebugPrint(m,"Cookie size is %d\n",csize);  }  asoc->cookie = w_calloc(m,1,csize);  if(asoc->cookie == NULL){    SCTPdebugPrint(m,    		   "Problem, out of memory for cookie this will fail the asoc\n");    return;  }  t = (struct sctpChunkDesc *)asoc->cookie;  if(csize > sizeof(struct sctpChunkDesc)){    /* if there is a cookie copy it in */    SCTPdebugPrint(m,"Copy cookie\n");    memcpy(asoc->cookie,(char *)p,csize);  }  SCTPdebugPrint(m,"Converting to Chunk\n");  t->chunkID = SCTP_COOKIE;  t->chunkLength = p->paramLength;  t->chunkFlg = 0;}char *SCTPupdateAllAddresses(struct SCTP *m,		       struct SCTP_association *asoc,		       struct sctpUnifiedInit *m1,		       struct sockaddr *from,		       int *deadflag,		       int *sizeOfOpErr,		       struct sctpParamDesc **prefPrim){  /* takes the association and picks apart the inits structure   * updating all ip address /ports into the association struct   */  int i;  struct sctpV4IpAddress *point;  struct sctpV6IpAddress *point6;  struct sctpParamDesc *paramPoint,*tPoint;  struct SCTP_association *lasoc;  struct sockaddr_in sin;  struct sockaddr_in6 sin6;  int rret,dnsNameSeen;  char *listOut;  int paramCnt,at,max,nets;  u_long point1,point2;  u_short parat,plen;  int sawFrom;  listOut = NULL;  *deadflag = 0;  *sizeOfOpErr = 0;  nets = paramCnt = 0;  sawFrom = 0;  dnsNameSeen = 0;  i = 0;  /* init the generic addresses used with the INIT routine */  memset(&sin,0,sizeof(sin));  memset(&sin6,0,sizeof(sin6));  sin.sin_family = AF_INET;  sin6.sin6_family = AF_INET6;#ifdef USES_BSD_4_4_SOCKET  sin6.sin6_len = sizeof(struct sockaddr_in6);  sin.sin_len = sizeof(struct sockaddr_in);#endif  sin.sin_port = ((struct sockaddr_in *)from)->sin_port;  /* We cheat here since the port is in the same place */  sin6.sin6_port = ((struct sockaddr_in *)from)->sin_port;  SCTPdebugPrint(m,"**************************UPDATE ALL ADDRESSES**************\n");  /* take out the ECN size built into the struct */  at = sizeof(struct sctpUnifiedInit);  max = ntohs(m1->uh.chunkLength);  paramPoint = (struct sctpParamDesc *)((u_long)m1 + at);  SCTPdebugPrint(m,		 "paramPoint set to address %x m1 at %x\n",(u_long)paramPoint,		 (u_long)m1);  /* count the number of param's and nets that are ipv4 */  while(at < max){    paramCnt++;    SCTPdebugPrint(m,		   "paramType is at %x->(%x) paramLen is at %x->(%d) max:%d at:%d\n",		   (u_long)&paramPoint->paramType,		   ntohs(paramPoint->paramType),		   (u_long)&paramPoint->paramLength,		   ntohs(paramPoint->paramLength),		   max,at);    SCTPdebugPrintArry(m,(char *)paramPoint,8);    plen = ntohs(paramPoint->paramLength);    if((plen < sizeof(struct sctpParamDesc)) || (plen > (max-at))){      SCTPdebugPrint(m,"Invalid parameter has a length of %d\n",plen);      *deadflag = 1;      return(NULL);    }    parat = ntohs(paramPoint->paramType);    if(parat == SCTP_IPV4_PARAM_TYPE){      nets++;      SCTPdebugPrint(m,"IPV4 address nets now %d\n");      point = (struct sctpV4IpAddress *)paramPoint;      if(from->sa_family == AF_INET){	struct sockaddr_in *frmm;	frmm = (struct sockaddr_in *)from;	if(point->ipAddress == frmm->sin_addr.s_addr){	  /* The from address is listed */	  SCTPdebugPrint(m,"Saw the from address\n");	  sawFrom = 1;	}      }    }else if(parat == SCTP_ECN_I_CAN_DO_ECN){      SCTPdebugPrint(m,"Peer is ECN capable, turning ECN on!\n");      asoc->ECN_Allowed = 1;    }else if(parat == SCTP_HOSTNAME_VIA_DNS){      SCTPdebugPrint(m,"DNS found\n");      nets++;      dnsNameSeen = 1;    }else if((parat == SCTP_IPV6_PARAM_TYPE) && (!m->disableV6)){      /* its a IPv6 address */      int thisisit;      SCTPdebugPrint(m,"IPv6 network address\n");      point6 = (struct sctpV6IpAddress *)paramPoint;      thisisit = 0;      if(from->sa_family == AF_INET6){	struct sockaddr_in6 *frmm6;	int cmpval;	frmm6 = (struct sockaddr_in6 *)from;	SCTPdebugPrint(m,"Compare to from address the following\n");	SCTPdebugPrintArry(m,(char *)&frmm6->sin6_addr,			   sizeof(frmm6->sin6_addr));	SCTPdebugPrint(m,"To:\n");	SCTPdebugPrintArry(m,point6->ipAddress,			   sizeof(frmm6->sin6_addr));	cmpval = memcmp(point6->ipAddress,			(char *)&frmm6->sin6_addr,			sizeof(frmm6->sin6_addr));	if(cmpval == 0){	  /* The from address is listed */	  SCTPdebugPrint(m,"Saw the from address\n");	  thisisit = 1;	  sawFrom = 1;	}      }      memcpy(&sin6.sin6_addr,	  point6->ipAddress,	  sizeof(struct in6_addr));      if(IN6_IS_ADDR_LINKLOCAL(&sin6.sin6_addr) &&	      (thisisit==1)){	      /* Accept the link local if it is the from */	SCTPdebugPrint(m,"Accepting this address\n");	nets++;      }else if(IN6_IS_ADDR_LINKLOCAL(&sin6.sin6_addr)){	SCTPdebugPrint(m,"Skip a link local address\n");      }else{	SCTPdebugPrint(m,"Accepting this address\n");	nets++;      }    }else if((parat == SCTP_IPV6_PARAM_TYPE) && (m->disableV6)){      /* IPv6 is turned off.. discard it */      ;    }else if(parat == SCTP_RESPONDER_COOKIE){      /* ignore the cookie here, we will use it       * later        */      ;    }else if(parat == SCTP_SETADDRESS_PRIMARY){      /* save this off for the caller */      if(prefPrim != NULL)	*prefPrim = paramPoint;    }else if(parat == SCTP_UNRECOG_PARAM){      /* I ignore this for now, we probably should       * hook in processing of options here when       * doing the u-sctp and sctp-flow and sctp-addip       * extensions       */      SCTPdebugPrint(m,"Peer did not recognize this parameter\n");      SCTPdebugPrintArry(m,(char *)paramPoint,ntohs(paramPoint->paramLength));    }else if(parat == SCTP_COOKIE_PRESERVE){      /* Processed elsewhere so we ignore it       * here (if we see it again).       */      ;    }else if(parat == SCTP_UNRELIABLE_STRM){      /* ignore, will be process else where */    }else if(parat == SCTP_RESTRICT_ADDR_TO){      /* we only do IPv4 addresses and hostnames        * we will ignore this parameter for now       */      ;    }else{      /* Ok the else is really what we did all       * this for :) we want to do the bit munging       * of the upper bits to see how to treat this.       */      SCTPdebugPrint(m,"Parameter type %4.4x NOT recognized\n",parat);      if((parat & 0x8000) == 0x0000){	SCTPdebugPrint(m,"Dead flag set!\n");	*deadflag = 1;      }      if(parat & 0x4000){	/* report it flag, build a Op Err segment (if not built)	 * and add on this dude	 */	int len;	len = ntohs(paramPoint->paramLength);	if(listOut == NULL){	  int aloc;	  aloc = ((((sizeof(struct sctpUnifiedOpError) + len) + 3) >> 2) << 2);	  listOut = w_calloc(m,1,aloc);	  if(listOut != NULL){	    struct sctpUnifiedOpError *list;	    char *x;	    list = (struct sctpUnifiedOpError *)listOut;	    x = (char *)((u_long)list + sizeof(struct sctpUnifiedOpError));	    list->uh.chunkID = SCTP_OPERATION_ERR;	    list->uh.chunkFlg = 0;	    list->uh.chunkLength = htons((sizeof(struct sctpUnifiedOpError) + len));	    list->c.cause = htons(SCTP_OP_ERROR_UNK_PARAM);	    list->c.causeLen = htons(sizeof(struct sctpOpErrorCause) + len);	    memcpy(x,paramPoint,len);	    if(len % 4){	      /* null out the pad bytes */	      memset(&x[len],0,(4-(len%4)));	    }	    *sizeOfOpErr = aloc;    	  }	}else{	  int aloc,newport;	  char *newList;	  newport = ((((sizeof(struct sctpOpErrorCause) + len) + 3) >> 2) << 2);	  aloc = newport + *sizeOfOpErr;	  newList = w_calloc(m,1,aloc);	  if(newList != NULL){	    struct sctpUnifiedOpError *list;	    struct sctpOpErrorCause *clist;	    char *x;	    memcpy(newList,listOut,*sizeOfOpErr);	    w_free(m,listOut);	    listOut = newList;	    list = (struct sctpUnifiedOpError *)listOut;	    clist = (struct sctpOpErrorCause *)(&listOut[*sizeOfOpErr]);	    x = (char *)((u_long)clist + sizeof(struct sctpOpErrorCause));	    list->uh.chunkLength = htons(*sizeOfOpErr + sizeof(struct sctpOpErrorCause) + len);	    clist->cause = htons(SCTP_OP_ERROR_UNK_PARAM);	    clist->causeLen = htons(sizeof(struct sctpOpErrorCause) + len);	    memcpy(x,paramPoint,len);	    if(len % 4){	      /* null out the pad bytes */	      memset(&x[len],0,(4-(len%4)));	    }	    *sizeOfOpErr += newport;	  }	}      }      if(*deadflag){	return(listOut);      }    }    point1 = (u_long)paramPoint;    tPoint = (struct sctpParamDesc *)((u_long)paramPoint + plen);    paramPoint = (struct sctpParamDesc *)((((u_long)tPoint + 3) >> 2) << 2);    point2 = (u_long)paramPoint;    at += (point2-point1);  }      SCTPdebugPrint(m,"There are %d parameters in the init and %d addresses\n",		 paramCnt,nets);  SCTPdebugPrint(m,"The message starts at address %x\n",(u_int)m1);  if(nets == 0){    /* special case for only one network. */    if((asoc->nets != NULL) && (asoc->numnets == 1)){      SCTPdebugPrint(m,"Using allocated and setup network structure\n");    }else{      /* free up any old memory and       * allocate a array of 1, then       * set it up.       */      if(asoc->nets != NULL){	for(i=0;i<asoc->numnets;i++){	  /* remove from table */	  struct SCTP_association *lasoc;	  int sizeKey;	  if(asoc->nets[i].ina->sa_family == AF_INET){	    sizeKey = sizeof(struct sockaddr_in);	  }else if(asoc->nets[i].ina->sa_family == AF_INET6){	    sizeKey = sizeof(struct sockaddr_in6);	  }else{	    w_free(m,asoc->nets[i].ina);	    continue;	  }	  lasoc = (struct SCTP_association *)HashedTbl_lookup(m->allAssoc,							      (void *)asoc->nets[i].ina,							      sizeKey,(void **)NULL);	  if(lasoc != asoc){	    SCTPdebugPrint(m,"Strange, addresses leads to other assoc\n");	    w_free(m,asoc->nets[i].ina);	    continue;	  }	  lasoc = (struct SCTP_association *)HashedTbl_remove(m->allAssoc,							      (void *)asoc->nets[i].ina,							      sizeKey,(void **)NULL);	  w_free(m,asoc->nets[i].ina);	  asoc->nets[i].ina = NULL;	}	w_free(m,asoc->nets);      }      asoc->numnets = 1;      asoc->nets = w_calloc(m,1,sizeof(struct SCTP_nets));      if(asoc->nets == NULL){	printf("Out of memory we are heading for a fall!!\n");	return(NULL);      }      SCTPinitNetStruct(m,asoc,&asoc->nets[0],from);      rret = HashedTbl_enter(m->allAssoc,(void *)asoc->nets[i].ina,(void *)asoc,			     sizeof(struct sockaddr_in));      if(rret != LIB_STATUS_GOOD){	SCTPdebugPrint(m,"Error entering in hash table %d\n",rret);	*deadflag = -1;	return(listOut);      }    }  }else{    /* ok we have nets to allocate and go through     */    SCTPdebugPrint(m,"Ok we have %d\n",nets);      if(sawFrom == 0){      /* need a extra one for the from address */      nets++;      SCTPdebugPrint(m,"We did NOT see from increase to ****** %d\n",nets);    }    if(asoc->nets != NULL){      SCTPdebugPrint(m,"Removing %d networks\n",asoc->numnets);      for(i=0;i<asoc->numnets;i++){         if(asoc->nets[i].ina != NULL){	   /* remove from table */	   struct SCTP_association *lasoc;	   int sizeKey;	   if(asoc->nets[i].ina->sa_family == AF_INET){		   sizeKey = sizeof(struct sockaddr_in);	   }else if(asoc->nets[i].ina->sa_family == AF_INET6){		   sizeKey = sizeof(struct sockaddr_in6);	   }else{		   w_free(m,asoc->nets[i].ina);		   continue;	   }	   lasoc = (struct SCTP_association *)HashedTbl_lookup(m->allAssoc,	       (void *)asoc->nets[i].ina,	       sizeKey,(void **)NULL);	   if(lasoc != asoc){		   SCTPdebugPrint(m,"Strange, addresses leads to other assoc\n");		   w_free(m,asoc->nets[i].ina);		   continue;	   }           SCTPdebugPrint(m,"Removing hash of index %d\n",i);	   SCTPdebugPrintAddress(m,asoc->nets[i].ina);	   lasoc = (struct SCTP_association *)HashedTbl_remove(m->allAssoc,	       (void *)asoc->nets[i].ina,	       sizeKey,(void **)NULL);	   w_free(m,asoc->nets[i].ina);	 }      }      w_free(m,asoc->nets);    }    i = 0;        asoc->nets = w_calloc(m,nets,sizeof(struct SCTP_nets));    if(asoc->nets == NULL){      printf("Out of memory we are heading for a fall!!\n");      return(NULL);    }    asoc->numnets = nets;    if(sawFrom == 0){      int keysz;      SCTPdebugPrint(m,"Ok, we NEED to enter the from again since we just blew it away\n");      SCTPinitNetStruct(m,asoc,&asoc->nets[0],from);      if(from->sa_family == AF_INET)	      keysz = sizeof(struct sockaddr_in);      else	      keysz = sizeof(struct sockaddr_in6);            SCTPdebugPrint(m,"Address to enter entered\n");      SCTPdebugPrintArry(m,(char *)asoc->nets[i].ina,keysz);      rret = HashedTbl_enter(m->allAssoc,(void *)asoc->nets[i].ina,(void *)asoc,			     keysz);      if(rret != LIB_STATUS_GOOD){	SCTPdebugPrint(m,"Error entering in hash table %d\n",rret);	*deadflag = -1;	return(listOut);      }      i++;      SCTPdebugPrint(m,"Ok, index now at %d hash enter ret:%d \n",i,rret);    }    /* init all structs. */    SCTPdebugPrint(m,"Init the net structs for %d nets i is at %d\n",asoc->numnets,i);    /* now go through it all and pull out     * the ip addresses      */    /* take out the ECN size built into the struct */    at = sizeof(struct sctpUnifiedInit);    max = ntohs(m1->uh.chunkLength);    paramPoint = (struct sctpParamDesc *)((u_long)m1 + at);    /* No matter the from was stuck in the association     * by the caller at INIT or at cookie unpack.     */    /* count the number of param's and nets that are ipv4 */    while(at < max){      /****************************/      /* should have the ability  */      /* to handle IPV6 too here  */      /****************************/      SCTPdebugPrint(m,"In parse addresses at:%d max:%d\n",at,max);      if(ntohs(paramPoint->paramType) == SCTP_IPV4_PARAM_TYPE){	if(dnsNameSeen == 0){	  SCTPdebugPrint(m,"Installing IPv4 address\n");	  point = (struct sctpV4IpAddress *)((u_long)paramPoint);	  /* now do a special look to see if this guy is out there	   * and does not point here, with a hash table 	   * this could not happen...	   */	  sin.sin_addr.s_addr = point->ipAddress;	  asoc->nets[i].intfRotationState = SCTP_ADDR_REACHABLE;      	  SCTPinitNetStruct(m,asoc,&asoc->nets[i],(struct sockaddr *)&sin);	  lasoc = (struct SCTP_association *)HashedTbl_lookup(m->allAssoc,							      (void *)asoc->nets[i].ina,							      sizeof(struct sockaddr_in),							      (void **)NULL);	  if(lasoc == NULL){	    SCTPdebugPrint(m,"Enter IPv4 address into hash table\n");	    SCTPdebugPrintArry(m,(char *)asoc->nets[i].ina,sizeof(struct sockaddr_in));	    rret = HashedTbl_enter(m->allAssoc,(void *)asoc->nets[i].ina,(void *)asoc,				   sizeof(struct sockaddr_in));	    if(rret != LIB_STATUS_GOOD){	      SCTPdebugPrint(m,"Error entering in hash table %d\n",rret);	      *deadflag = -1;	      return(listOut);	    }	  }else if(lasoc != asoc){	    SCTPdebugPrint(m,"True duplicate association\n");	    *deadflag = -1;	    return(listOut);	  }else{	    SCTPdebugPrint(m,"Already in association no need to add\n");	  }	}	i++;      }else if(ntohs(paramPoint->paramType) == SCTP_HOSTNAME_VIA_DNS){	/* pull DNS name out and save it */	int len;	struct sctpDNSName *dnsn;	SCTPdebugPrint(m,"DNS name now stops all other addresses\n");	len = ntohs(paramPoint->paramLength);	dnsn = (struct sctpDNSName *)paramPoint;	if(len <= MAXHOSTNAMELEN){	  strcpy(asoc->DNSname,dnsn->name);	}else{	  strncpy(asoc->DNSname,dnsn->name,MAXHOSTNAMELEN);	  dnsn->name[MAXHOSTNAMELEN] = 0;	}	/* save off the form address and 	 * port so I can find his port number if/when I	 * need it later.	 */	SCTPinitNetStruct(m,asoc,&asoc->nets[0],from);      }else if((ntohs(paramPoint->paramType) == SCTP_IPV6_PARAM_TYPE) &&	       (m->disableV6)){	/* IPv6 is turned off */	;      }else if(ntohs(paramPoint->paramType) == SCTP_IPV6_PARAM_TYPE){        int justSkipIt;	justSkipIt = 0;	if(dnsNameSeen == 0){	  SCTPdebugPrint(m,"Installing IPv6 address\n");	  point6 = (struct sctpV6IpAddress *)((u_long)paramPoint);	  /* now do a special look to see if this guy is out there	   * and does not point here, with a hash table 	   * this could not happen...	   */	  memcpy((char *)&sin6.sin6_addr,		 point6->ipAddress,		 sizeof(struct in6_addr));	  asoc->nets[i].intfRotationState = SCTP_ADDR_REACHABLE;      	  if((sawFrom) && (IN6_IS_ADDR_LINKLOCAL(&sin6.sin6_addr))){		  struct sockaddr_in6 *frmm6;		  frmm6 = (struct sockaddr_in6 *)from;		  		  if(memcmp(point6->ipAddress,(char *)&frmm6->sin6_addr,			sizeof(frmm6->sin6_addr)) == 0){			  sin6.sin6_scope_id = frmm6->sin6_scope_id;		  }else{     	             justSkipIt = 1;  		  }	  }else if(IN6_IS_ADDR_LINKLOCAL(&sin6.sin6_addr)){   	     justSkipIt = 1;  	  }	  if(!justSkipIt){		  SCTPinitNetStruct(m,asoc,&asoc->nets[i],(struct sockaddr *)&sin6);		  lasoc = (struct SCTP_association *)HashedTbl_lookup(m->allAssoc,		      (void *)asoc->nets[i].ina,		      sizeof(struct sockaddr_in6),		      (void **)NULL);		  sin6.sin6_scope_id = 0;		  if(lasoc == NULL){			  SCTPdebugPrint(m,"Enter IPv6 address into hash table\n");			  SCTPdebugPrintArry(m,(char *)asoc->nets[i].ina,			      sizeof(struct sockaddr_in6));			  rret = HashedTbl_enter(m->allAssoc,			      (void *)asoc->nets[i].ina,(void *)asoc,			      sizeof(struct sockaddr_in6));			  if(rret != LIB_STATUS_GOOD){				  SCTPdebugPrint(m,"Failed to enter in hash table %d\n",rret);				  *deadflag = -1;				  return(listOut);			  }		  }else if (lasoc != asoc){			  SCTPdebugPrint(m,"True duplicate\n");			  *deadflag = -1;			  return(listOut);		  }else{			  SCTPdebugPrint(m,"No need to install, already in the association\n");		  }		  i++;	  }	}      }      /* re-calulate to the next guy */      point1 = (u_long)paramPoint;      tPoint = (struct sctpParamDesc *)((u_long)paramPoint + ntohs(paramPoint->paramLength));      paramPoint = (struct sctpParamDesc *)((((u_long)tPoint + 3) >> 2) << 2);            point2 = (u_long)paramPoint;      at += (point2-point1);    }  }  /* at this point when we fall through other data would   * be present at point, if there was implementation   * specific data .. this implementation does not   * have any...   */  SCTPdebugPrint(m,"**************************UPDATE ALL ADDRESSES DONE**************\n");  return(listOut);}voidclearAllTimers(struct SCTP *m,	       struct SCTP_association *asoc){  int iii;  /* all done */  if(asoc == NULL)    return;  /* clear all running timers */  for(iii=0;iii<SCTP_NUMBER_TIMERS;iii++){    if(asoc->tmr[iii].running == SCTP_TIMER_RUNNING){      SCTPdebugPrint(m,"Stopping Timer number %d\n",iii);      (*m->timer)(m,(void *)&asoc->tmr[iii],SCTP_TIMER_STOP,0,0);      asoc->tmr[iii].running = SCTP_TIMER_IDLE;    }  }  if(asoc->relReqTmr.running == SCTP_TIMER_RUNNING){    SCTPdebugPrint(m,"Stopping rel-req timer of asoc\n");    (*m->timer)(m,(void *)&asoc->relReqTmr,SCTP_TIMER_STOP,0,0);    asoc->tmr[iii].running = SCTP_TIMER_IDLE;  }}inttimerWork(struct SCTP *m,	  struct SCTP_association *asoc,int cmd,int type,	  int network){  struct SCTP_TimerInfo *tmr;  int sendsectim;  int sendusectim;  u_long xx;  char *timerName;  static char *timerNames[] = {    "SctpTimerTypeNone",    "SctpTimerTypeSend",    "SctpTimerTypeInit",    "SctpTimerTypeRecv",    "SctpTimerTypeShutdown",    "SctpTimerTypeHeartbeat",    "SctpTimerTypeCookie",    "SctpTimerTypeNewCookie",    "SctpTimerTypePathMtuRaise",    "SctpTimerTypeShutdownAck",    "SctpTimerTypeRelReq",    "SctpUnknownTimerType"  };  if(type <= SctpTimerTypeShutdownAck)    timerName = timerNames[type];  else    timerName = timerNames[10];  sendusectim = 0;  /* routine to start/stop timers */  /* tmr[0] will be our send timer or our init timer */  /* tmr[1] will be the recieve timer */  /* tmr[2] will be cookie timer */  /* tmr[3] Shutdown Timer or shutdown-ack */  /* tmr[4] will be the HeartBeat Timer */  /* tmr[5] will be pathmtu  */  /* tmr[6]-[10] send timer for specific network */  SCTPdebugPrint(m,"asked to %s timer %s:%d\n",		 ((cmd == SCTP_TIMER_START) ? "start" : "stop"),		 timerName,type);  /* setup default timer to RTO or sendtimer default if   * RTO not setup   */  if(asoc->nets[network].RTO){    xx = asoc->nets[network].RTO;    sendsectim = (xx / 1000000);    sendusectim = (xx % 1000000);    if(sendusectim > 1000000){      sendusectim -= 1000000;      sendsectim++;    }  }else{    sendsectim = asoc->sendsectim;    sendusectim = asoc->sendusectim;  }  /* setup based on type of timer */  switch(type){  case SctpTimerTypeRelReq:    tmr = &asoc->relReqTmr;    break;  case SctpTimerTypePathMtuRaise:    /* We take a simple approach and only hold one long     * timer, instead of a 10min/2min we just always make     * attempts 10 minutes apart or more..          */    tmr = &asoc->tmr[5];    sendsectim = m->baseTimeoutSecs[SCTP_TIMER_PMTU];    sendusectim = m->baseTimeoutNSecs[SCTP_TIMER_PMTU];    SCTPdebugPrint(m,"Ok, Starting a p-mtu timer %d.%6.6d\n",		   sendsectim,sendusectim);        if(sendsectim < SCTP_DEF_PMTU_MIN){      sendsectim = SCTP_DEF_PMTU_MIN;    }    break;  case SctpTimerTypeSend:    /* timer 0 */    {      if(network >= SCTP_MAX_NET_TIMERS){	/* make them share 0 */	tmr = &asoc->tmr[0];      }else{	/* 0 - 4 dest wil get timers 5-9 */	tmr = &asoc->tmr[(network + SCTP_MAX_NET_TIMERS)];      }    }    break;  case SctpTimerTypeCookie:    tmr = &asoc->tmr[2];    if(asoc->nets[network].RTO == 0){      /* different default, i.e. the INIT if no RTO set */      sendsectim = asoc->initsectim;      sendusectim = asoc->initusectim;    }    break;  case SctpTimerTypeInit:    /* timer 0 */    /* we use the user specified init time      * in absence of any data.     */    tmr = &asoc->tmr[0];    if(asoc->nets[network].RTO == 0){      /* different default, i.e. the INIT if no RTO set */      sendsectim = asoc->initsectim;      sendusectim = asoc->initusectim;    }    break;  case SctpTimerTypeRecv:    /* timer 1 */    /* we always use the user specifed time     */    tmr = &asoc->tmr[1];    sendsectim = asoc->t2recvinUsec/1000000;    sendusectim = asoc->t2recvinUsec%1000000;    break;  case SctpTimerTypeShutdownAck:    /* timer 9, all otheres are now stopped */    /* this is the same as a shutdown timer */  case SctpTimerTypeShutdown:    /* timer 4, all others stopped */    {      int i;      /* stop all running timers we are out of here */      if(asoc->nets[network].RTO == 0){	/* use shutdown default if no RTO */	sendsectim = m->baseTimeoutSecs[SCTP_TIMER_SHUTDOWN];	sendusectim = m->baseTimeoutNSecs[SCTP_TIMER_SHUTDOWN]/1000;      }      for(i=0;i<SCTP_NUMBER_TIMERS;i++){	if(asoc->tmr[i].running == SCTP_TIMER_RUNNING) {	  (*m->timer)(m,(void *)&asoc->tmr[i],SCTP_TIMER_STOP,0,0);	  asoc->tmr[i].running = SCTP_TIMER_IDLE;	}      }      tmr = &asoc->tmr[3];      SCTPdebugPrint(m,"timers blows in %d.%d\n",		     sendsectim,sendusectim);    }  break;  case SctpTimerTypeHeartbeat:    /* timer 4 */    {      u_long val;      tmr = &asoc->tmr[4];      /* use base heartbeat time for MDTP association */      /* and add to that the RTO. */      /* it might be better to have a HB time per       * association but for this impelemantion       * a global over all is ok       */      sendsectim = asoc->heartBeatDelay;      SCTPdebugPrint(m,"HB delay is %d.%6.6d\n",		     sendsectim,sendusectim);      /* factor in the RTO */      /* Use the RTO time calculated on this net        * Note: I am cheating here and using only       * the collasped value since we HB UserDelay + RTO       * time and send only ONE HB out every time, I want to       * keep the beat going to the next one and NOT use       * any backed off value (this is for multi-homed only)       */      if(asoc->numnets > 1){	xx = asoc->nets[network].lastsa + 4 * asoc->nets[network].lastsv;      }else{	xx = asoc->nets[network].RTO;      }      SCTPdebugPrint(m,"RTO is currently %d or %d.%6.6d\n",		     asoc->nets[network].RTO,		     (asoc->nets[network].RTO / 1000000),		     (asoc->nets[network].RTO % 1000000)		     );      sendsectim += (xx/ 1000000);      sendusectim += (xx % 1000000);      if(sendusectim > 1000000){	sendusectim -= 1000000;	sendsectim++;      }      SCTPdebugPrint(m,"w/RTO its %d.%6.6d\n",		     sendsectim,sendusectim);      /* add a jitter of between 0-2 seconds + cur nsec counter */      val = (u_long)mrand48();      SCTPdebugPrint(m,"Random Jitter is %d i.e. %d.%6.6d\n",		     val,		     (val %3),		     (val % 1000000)		     );      sendsectim += (val % 3);      sendusectim += (val % 1000000);      }  break;  case SctpTimerTypeNone:  default:    printf("invalid call to timerWork type none or ?%d\n",	   type);    return(-1);  }  if(cmd == SCTP_TIMER_START){    SCTPdebugPrint(m,"IN START\n");    if(tmr->running == SCTP_TIMER_RUNNING) {      if(tmr->timerType == type){	/* already running return */	return(0);      }else{	SCTPdebugPrint(m,		       "Soft error wanted a %d timer type and %d is running\n",		       type,tmr->timerType);	return(-1);      }    }else if(tmr->running == SCTP_TIMER_EXPIRED){      SCTPdebugPrint(m,		     "Soft error did not get timer expiration but continuing\n");    }    /* this could be done more efficiently if I carried     * the highest in the assoc and then set it whenever     * a RTT was calculated.. if the new one was     * more....     */    tmr->running = SCTP_TIMER_RUNNING;    tmr->timerType = type;    tmr->timerinfo = (void *)asoc;    SCTPdebugPrint(m,"calling start %d.%6.6d\n",sendsectim,sendusectim);    (*m->timer)(m,(void *)tmr,cmd,sendsectim,sendusectim);    SCTPdebugPrint(m,"back from calling start\n");  }else if(cmd == SCTP_TIMER_STOP){    if((tmr->running == SCTP_TIMER_IDLE) ||       (tmr->running == SCTP_TIMER_EXPIRED)){      /* to late .. it is idle now       * so flag to idle so that if       * we have not yet been called we       * will not get a false t-o       */      tmr->running = SCTP_TIMER_IDLE;    }else{      SCTPdebugPrint(m,"calling stop\n");      (*m->timer)(m,(void *)tmr,cmd,0,0);      tmr->running = SCTP_TIMER_IDLE;      SCTPdebugPrint(m,"back from calling stop\n");    }  }else{    printf("Unknown timer command %d\n",cmd);    return(-1);  }  return(0);}void SCTPreportAllOutboundLost(struct SCTP *m,				struct SCTP_association *asoc){  /* report the un-delivered state of all    * outbound datagrams and stop any   * running send timer.   */  int i;  struct SCTP_transmitOnQueue *tmp,*ntmp;  SCTPdebugPrint(m,"Reporting all outbound lost\n");  /* stop all timers */  for(i=0;i<asoc->numnets;i++){    timerWork(m,asoc,SCTP_TIMER_STOP,SctpTimerTypeSend,i);  }  tmp = asoc->outqueue;  asoc->outqueue = NULL;  while(tmp != NULL){    ntmp = tmp->next;    tmp->next = tmp->prev = NULL;    /* This should be fixed to pass a struct     * with sockaddress and with      * the data... but for now     * we just pass data itself     */    SCTPdebugPrint(m,"Notify for tmit %x tsn:%x sent:%d\n",		   (u_int)tmp,tmp->TSN_seq,tmp->sent);    (*m->notify)(SCTP_NOTIFY_DG_FAIL,tmp->data,tmp->sizeOfTmit);    if(tmp->data != NULL){      SCTPdebugPrint(m,"Report inbound frees data:%x\n",(u_int)tmp->data);      w_free(m,tmp->data);      tmp->data = NULL;    }    SCTPdebugPrint(m,"Report inbound frees struct:%x\n",(u_int)tmp);    w_free(m,tmp);    tmp = ntmp;  }    tmp = asoc->sendqueue;  asoc->sendqueue = NULL;  while(tmp != NULL){    ntmp = tmp->next;    tmp->next = tmp->prev = NULL;    /* This should be fixed to pass a struct     * with sockaddress and with      * the data... but for now     * we just pass data itself     */    SCTPdebugPrint(m,"Notify for tmit %x tsn:%x sent:%d\n",		   (u_int)tmp,tmp->TSN_seq,tmp->sent);    (*m->notify)(SCTP_NOTIFY_DG_FAIL_SENT,tmp->data,tmp->sizeOfTmit);    if(tmp->data != NULL){      SCTPdebugPrint(m,"Report inbound frees data:%x\n",(u_int)tmp->data);      w_free(m,tmp->data);      tmp->data = NULL;    }    SCTPdebugPrint(m,"Report inbound frees struct:%x\n",(u_int)tmp);    w_free(m,tmp);    tmp = ntmp;  }  asoc->sendqueuetail = asoc->tailoutq = NULL;  SCTPdebugPrint(m,"Notifications complete\n");}#ifdef LINUX#define LINUX_PROC_IPV6_FILE "/proc/net/if_inet6"#endifintSCTP_doesAddressExist(struct SCTP *m,		      struct sockaddr *addr,		      struct sockaddr_in *fillMask,		      struct sockaddr_in *fillBroad		      ){#ifdef LINUX  char addrBuffer[256];  char addrBuffer2[64];  FILE *v6list;#endif  struct ifconf cf;  int at;  char buffer[8192];  struct ifreq *ifrequest,*nextif;  struct ifreq local;  int numAlocAddr,ii;  int localfd;  cf.ifc_buf = buffer;  cf.ifc_len = 8192;  at = 0;  SCTPdebugPrint(m,"Ok Called look to see if an address exists\n");  SCTPdebugPrintAddress(m,addr);#ifdef LINUX  if(addr->sa_family == AF_INET){    v6list = fopen(LINUX_PROC_IPV6_FILE,"r");    if(v6list != NULL){      struct sockaddr_in6 sin6;      memset((char *)&sin6,0,sizeof(sin6));            sin6.sin6_family = AF_INET6;      while(fgets(addrBuffer,sizeof(addrBuffer),v6list) != NULL){	/* skip loopback */	if(strncmp(addrBuffer,"00000000000000000000",20) == 0)	  continue;	memset(addrBuffer2,0,sizeof(addrBuffer2));	strncpy(addrBuffer2,addrBuffer,4);	addrBuffer2[4] = ':';	strncpy(&addrBuffer2[5],&addrBuffer[4],4);	addrBuffer2[9] = ':';	strncpy(&addrBuffer2[10],&addrBuffer[8],4);	addrBuffer2[14] = ':';	strncpy(&addrBuffer2[15],&addrBuffer[12],4);	addrBuffer2[19] = ':';	strncpy(&addrBuffer2[20],&addrBuffer[16],4);	addrBuffer2[24] = ':';	strncpy(&addrBuffer2[25],&addrBuffer[20],4);	addrBuffer2[29] = ':';	strncpy(&addrBuffer2[30],&addrBuffer[24],4);	addrBuffer2[34] = ':';	strncpy(&addrBuffer2[35],&addrBuffer[28],4);	if(inet_pton(AF_INET6,addrBuffer2,(void *)&sin6.sin6_addr)){	  if(IN6_ARE_ADDR_EQUAL(&sin6.sin6_addr,				&((struct sockaddr_in6 *)addr)->sin6_addr) == 0){	    fclose(v6list);	    return(1);	  }	}      }      fclose(v6list);    }  }#endif  /* Now gather the master address information */  if(ioctl(m->fd, SIOCGIFCONF, (char *)&cf) == -1){    return(-1);  }  /* Here we must count the acutal number of used struct's since   * we can't just do a calculation   */  numAlocAddr = 0;#ifdef USES_BSD_4_4_SOCKET  for(at=0;at < cf.ifc_len;){    ifrequest = (struct ifreq *)&buffer[at];    at += (ifrequest->ifr_addr.sa_len + sizeof(ifrequest->ifr_name));    numAlocAddr++;  }#else  numAlocAddr = cf.ifc_len / sizeof(struct ifreq);  numAlocAddr++;  ifrequest = cf.ifc_req;#endif  /* Now we go through and pull each one */  SCTPdebugPrint(m,"looking at %d entries in ifconfig\n",numAlocAddr);  at = 0;  /* set to the start, i.e. buffer[0] */  ifrequest = (struct ifreq *)&buffer[at];  for(ii=0;ii<numAlocAddr;ii++,ifrequest=nextif){    /* use the sa_len to calculate where the next one will be */#ifdef USES_BSD_4_4_SOCKET    at += (ifrequest->ifr_addr.sa_len + sizeof(ifrequest->ifr_name));    nextif = (struct ifreq *)&buffer[at];#else    nextif = ifrequest + 1;#endif    if((ifrequest->ifr_addr.sa_family != AF_INET)        &&       (ifrequest->ifr_addr.sa_family != AF_INET6)       ){      /* yes, but wrong family return 0 */      SCTPdebugPrint(m,"Its not AF_INET/AF_INET6\n");      continue;    }    if(addr->sa_family != ifrequest->ifr_addr.sa_family){      SCTPdebugPrint(m,"Not same family %d/%d\n",		     addr->sa_family,		     ifrequest->ifr_addr.sa_family		     );      continue;    }    SCTPdebugPrint(m,"Compare addresses:\n");    SCTPdebugPrintAddress(m,addr);    SCTPdebugPrintAddress(m,&ifrequest->ifr_addr);    if(ifrequest->ifr_addr.sa_family == AF_INET){      if(((struct sockaddr_in *)(&ifrequest->ifr_addr))->sin_addr.s_addr != 	 ((struct sockaddr_in *)addr)->sin_addr.s_addr){	/* It's not our guy */	SCTPdebugPrint(m,"Not our guy\n");	continue;      }    }else if(ifrequest->ifr_addr.sa_family == AF_INET6){      if(IN6_ARE_ADDR_EQUAL(&((struct sockaddr_in6 *)(&ifrequest->ifr_addr))->sin6_addr,			    &((struct sockaddr_in6 *)addr)->sin6_addr) == 0){	/* It's not our guy */	SCTPdebugPrint(m,"Not our guy\n");	continue;      }    }    memset(&local,0,sizeof(local));    memcpy(local.ifr_name,ifrequest->ifr_name,IFNAMSIZ);    if(ioctl(m->fd, SIOCGIFFLAGS, (char *)&local) == -1){      /* can't get the flags, skip this guy */      return(-1);    }    if((local.ifr_flags & IFF_LOOPBACK) == IFF_LOOPBACK){      /* It is a loopback so return no, wrong type i.e. 0 */      SCTPdebugPrint(m,"Its the loopback?\n");      return(0);    }    /* its our guy */    if(addr->sa_family == AF_INET && (fillMask != NULL)){      localfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);      /* Fill in the netmask address if they want it */      memset(&local,0,sizeof(local));      memcpy(local.ifr_name,ifrequest->ifr_name,IFNAMSIZ);      if(ioctl(localfd, SIOCGIFNETMASK, (char *)&local) != -1){	/* copy the address */	memset(fillMask->sin_zero,	       0,sizeof(fillMask->sin_zero));	fillMask->sin_addr.s_addr = ((struct sockaddr_in *)&local.ifr_addr)->sin_addr.s_addr;	/* zero the port */	fillMask->sin_port = 0;	/* zero the zero area */#ifdef USES_BSD_4_4_SOCKET	/* copy the length */	fillMask->sin_len = local.ifr_addr.sa_len;#endif	/* set the family type */	fillMask->sin_family = AF_INET;	memset(fillMask->sin_zero,0,sizeof(fillMask->sin_zero));      }      if(fillBroad != NULL){	/* Fill in the broadcast address if they want it */	memset(&local,0,sizeof(local));	memcpy(local.ifr_name,ifrequest->ifr_name,IFNAMSIZ);	if(ioctl(localfd,SIOCGIFBRDADDR,(char *)&local) != -1){	  /* copy the address */	  memset(fillBroad->sin_zero,		 0,sizeof(fillBroad->sin_zero));	  fillBroad->sin_addr.s_addr = ((struct sockaddr_in *)&local.ifr_addr)->sin_addr.s_addr;	  fillBroad->sin_port = 0;#ifdef USES_BSD_4_4_SOCKET	  /* copy the length */	  fillBroad->sin_len = local.ifr_addr.sa_len;#endif	}      }	            close(localfd);    }else{	    struct sockaddr_in6 *s6;	    s6 = (struct sockaddr_in6 *)addr;	    if(IN6_IS_ADDR_LINKLOCAL(&s6->sin6_addr) &&		*(u_short *)&s6->sin6_addr.s6_addr[2] != 0){		    /* KAME HACK: to pull out embedded link local scope */		    u_short index;		    index = *(u_short *)&s6->sin6_addr.s6_addr[2];		    *(u_short *)&s6->sin6_addr.s6_addr[2] = 0;		    if (s6->sin6_scope_id == 0)			    s6->sin6_scope_id = ntohs(index);	    }    }    return(1);  }  return(0);}intSCTP_gatherAddresses(struct sockaddr ***localNets1,		     struct sockaddr_in **maskList1,		     struct sockaddr_in **broadList1,		     int *numberOfNets1,		     int *numberOfNetsAloc,		     int *max_mtu,		     int **mtuList1,		     int fd1,		     int includeLoopback		     ){#ifdef LINUX  int addedNets;  char addrBuffer[256];  char addrBuffer2[64];  FILE *v6list;#endif  unsigned short intf_flags;  struct ifconf cf;  int at,copSiz,i;  char buffer[8192];  struct sockaddr **localNets;  struct sockaddr_in *maskList;  struct sockaddr_in *broadList;  struct sockaddr *toUse;  int *mtuList,oldnumnet;  int numberOfNets,saveMTU;#ifdef HAS_SIOCGLIFADDR  struct if_laddrreq lifaddr;#endif  struct ifreq local;  struct ifreq *ifrequest,*nextif;  int numAlocAddr,ii;  cf.ifc_buf = buffer;  cf.ifc_len = 8192;  *max_mtu = 0;  at = 0;  /* First copy into local variables things */  localNets = *localNets1;  maskList = *maskList1;  broadList = *broadList1;  if(mtuList1 != NULL)    mtuList = *mtuList1;  else    mtuList = NULL;  /* free up anything that was allocated before, this   * module is designed to be called multiple times   */  oldnumnet = *numberOfNets1;  if(localNets != NULL){    for(i=0;i<oldnumnet;i++){      if(localNets[i] != NULL){	free(localNets[i]);      }    }    free(localNets);    *localNets1 = localNets = NULL;  }  if(maskList != NULL){    free(maskList);    *maskList1 = maskList = NULL;  }  if(broadList != NULL){    free(broadList);    *broadList1 = broadList = NULL;  }  if(mtuList != NULL){    free(mtuList);    *mtuList1 = mtuList = NULL;  }  numberOfNets = 0;  saveMTU = DEFAULT_MTU_CEILING;  /* Now gather the master address information */  if(ioctl(fd1, SIOCGIFCONF, (char *)&cf) == -1){    return(-1);  }  /* Here we must count the acutal number of used struct's since   * we can't just do a calculation   */  numAlocAddr = 0;#ifdef USES_BSD_4_4_SOCKET  for(at=0;at < cf.ifc_len;){    ifrequest = (struct ifreq *)&buffer[at];    at += (ifrequest->ifr_addr.sa_len + sizeof(ifrequest->ifr_name));    if(ifrequest->ifr_addr.sa_len == 0){      /* if the interface has no address then you must       * skip at a minium a sockaddr structure       */      at += sizeof(struct sockaddr);    }    numAlocAddr++;  }#else  numAlocAddr = cf.ifc_len / sizeof(struct ifreq);  numAlocAddr++;  ifrequest = cf.ifc_req;#endif#ifdef LINUX  addedNets = 0;  v6list = fopen(LINUX_PROC_IPV6_FILE,"r");  if(v6list != NULL){    while(fgets(addrBuffer,sizeof(addrBuffer),v6list) != NULL){      addedNets++;    }    fclose(v6list);  }  numAlocAddr += addedNets;  printf("Added %d extra for v6 total now %d\n",addedNets,numAlocAddr);#endif  /* now allocate the appropreate memory */  localNets = calloc(numAlocAddr,sizeof(struct sockaddr *));  if(localNets == NULL){    errno = ENOMEM;    return(-2);  }  for(i=0;i<numAlocAddr;i++){    localNets[i] = NULL;  }  maskList = calloc(numAlocAddr,sizeof(struct sockaddr_in));  if(maskList == NULL){    errno = ENOMEM;    free(localNets);    localNets = NULL;    return(-3);  }  broadList = calloc(numAlocAddr,sizeof(struct sockaddr_in));  if(broadList == NULL){    errno = ENOMEM;    free(localNets);    free(maskList);    localNets = NULL;    maskList = NULL;    return(-1);  }  if(mtuList1 != NULL){    mtuList = calloc(numAlocAddr,sizeof(int));  }  at = 0;  /* Now we go through and pull each one */#ifdef LINUX  v6list = fopen(LINUX_PROC_IPV6_FILE,"r");  if(v6list != NULL){    struct sockaddr_in6 sin6;    memset((char *)&sin6,0,sizeof(sin6));          sin6.sin6_family = AF_INET6;    while(fgets(addrBuffer,sizeof(addrBuffer),v6list) != NULL){      /* skip loopback */      if(strncmp(addrBuffer,"00000000000000000000",20) == 0)	continue;      memset(addrBuffer2,0,sizeof(addrBuffer2));      strncpy(addrBuffer2,addrBuffer,4);      addrBuffer2[4] = ':';      strncpy(&addrBuffer2[5],&addrBuffer[4],4);      addrBuffer2[9] = ':';      strncpy(&addrBuffer2[10],&addrBuffer[8],4);      addrBuffer2[14] = ':';      strncpy(&addrBuffer2[15],&addrBuffer[12],4);      addrBuffer2[19] = ':';      strncpy(&addrBuffer2[20],&addrBuffer[16],4);      addrBuffer2[24] = ':';      strncpy(&addrBuffer2[25],&addrBuffer[20],4);      addrBuffer2[29] = ':';      strncpy(&addrBuffer2[30],&addrBuffer[24],4);      addrBuffer2[34] = ':';      strncpy(&addrBuffer2[35],&addrBuffer[28],4);      if(inet_pton(AF_INET6,addrBuffer2,(void *)&sin6.sin6_addr)){	localNets[numberOfNets] = calloc(1,sizeof(struct sockaddr_in6));	if(localNets[numberOfNets] != NULL){	  memcpy(localNets[numberOfNets],&sin6,sizeof(sin6));	  numberOfNets++;	}      }else{	printf("Could not translate string %s",addrBuffer2);      }    }    fclose(v6list);  }#endif  /* set to the start, i.e. buffer[0] */  ifrequest = (struct ifreq *)&buffer[at];  for(ii=0;ii<numAlocAddr;ii++,ifrequest=nextif){    /* use the sa_len to calculate where the next one will be */#ifdef USES_BSD_4_4_SOCKET    at += (ifrequest->ifr_addr.sa_len + sizeof(ifrequest->ifr_name));    if(ifrequest->ifr_addr.sa_len == 0){      /* if the interface has no address then you must       * skip at a minium a sockaddr structure       */      at += sizeof(struct sockaddr);    }    nextif = (struct ifreq *)&buffer[at];#else    nextif = ifrequest + 1;#endif#ifdef _NO_SIOCGIFMTU_    *max_mtu = DEFAULT_MTU_CEILING;#else    memset(&local,0,sizeof(local));    memcpy(local.ifr_name,ifrequest->ifr_name,IFNAMSIZ);    if(ioctl(fd1, SIOCGIFMTU, (char *)&local) == -1){      /* cant get the flags? */      continue;    }    saveMTU = local.ifr_mtu;#endif    toUse = &ifrequest->ifr_addr;    memset(&local,0,sizeof(local));    memcpy(local.ifr_name,ifrequest->ifr_name,IFNAMSIZ);    if(ioctl(fd1, SIOCGIFFLAGS, (char *)&local) == -1){      /* can't get the flags, skip this guy */      return(-1);    }    /* Ok get the address and save the flags */    intf_flags = local.ifr_flags;    if(includeLoopback == 0){      if((intf_flags & IFF_LOOPBACK) == IFF_LOOPBACK){	/* skip the loopback */	continue;      }    }    if(toUse->sa_family == AF_INET6){      if(IN6_IS_ADDR_LOOPBACK(&((struct sockaddr_in6 *)(toUse))->sin6_addr)){	continue;      }      if(IN6_IS_ADDR_UNSPECIFIED(&((struct sockaddr_in6 *)(toUse))->sin6_addr)){	continue;      }    }    if((toUse->sa_family != AF_INET) &&       (toUse->sa_family != AF_INET6)){      /* nop, must be some other protocol */      continue;    }    if(toUse->sa_family == AF_INET){      if(((struct sockaddr_in *)(toUse))->sin_addr.s_addr == 0){	/* if it does not have a IP address set in, we will skip it */	continue;      }      localNets[numberOfNets] = calloc(1,sizeof(struct sockaddr_in));      copSiz = sizeof(struct sockaddr_in);    }else if(toUse->sa_family == AF_INET6){      if(IN6_IS_ADDR_UNSPECIFIED(&(((struct sockaddr_in6 *)(toUse))->sin6_addr))){	continue;      }      localNets[numberOfNets] = calloc(1,sizeof(struct sockaddr_in6));      copSiz = sizeof(struct sockaddr_in6);    }    /* Now, we may have already gathered this address, if so skip     * it     */    if(*max_mtu < saveMTU){      *max_mtu = saveMTU;    }    if(numberOfNets){      int dup,xxx;      dup = 0;      /* scan for the dup */      for(xxx=0;xxx<numberOfNets;xxx++){	/* family's must match */	if(localNets[xxx]->sa_family != toUse->sa_family)	  continue;	if(localNets[xxx]->sa_family == AF_INET){	  if(((struct sockaddr_in *)(toUse))->sin_addr.s_addr == 	     ((struct sockaddr_in *)localNets[xxx])->sin_addr.s_addr){	    /* set the flag and break, it is a dup */	    dup = 1;	    break;	  }	}else{	  if(IN6_ARE_ADDR_EQUAL(&(((struct sockaddr_in6 *)(toUse))->sin6_addr),				&(((struct sockaddr_in6 *)localNets[xxx])->sin6_addr))){	    /* set the flag and break, it is a dup */	    dup = 1;	    break;	  }	}      }      if(dup){	/* skip the duplicate name/address we already have it*/	free(localNets[numberOfNets]);	localNets[numberOfNets] = NULL;	continue;      }    }    /* copy address */    memcpy(localNets[numberOfNets],(char *)toUse,copSiz);    if(mtuList1 != NULL){      if(mtuList != NULL)	mtuList[numberOfNets] = saveMTU;    }    /* set family */    localNets[numberOfNets]->sa_family = toUse->sa_family;#ifdef USES_BSD_4_4_SOCKET    /* copy the length */    localNets[numberOfNets]->sa_len = toUse->sa_len;#endif    if(localNets[numberOfNets]->sa_family == AF_INET){      int localfd;      localfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);      memset(&local,0,sizeof(local));      memcpy(&local,ifrequest,sizeof(local));      if(ioctl(localfd, SIOCGIFNETMASK, (char *)&local) == -1){	/* no netmask, sigh oh well we keep the address anyway */	numberOfNets++;	close(localfd);	continue;      }      /* copy the address */      memset(maskList[numberOfNets].sin_zero,	     0,sizeof(maskList[numberOfNets].sin_zero));      maskList[numberOfNets].sin_addr.s_addr = ((struct sockaddr_in *)&local.ifr_addr)->sin_addr.s_addr;      /* zero the port */      maskList[numberOfNets].sin_port = 0;      /* zero the zero area */#ifdef USES_BSD_4_4_SOCKET      /* copy the length */      maskList[numberOfNets].sin_len = local.ifr_addr.sa_len;#endif      /* set the family type */      maskList[numberOfNets].sin_family = AF_INET;      /* Get the broadcast address */      memset(&local,0,sizeof(local));      memcpy(local.ifr_name,ifrequest->ifr_name,IFNAMSIZ);      if(ioctl(localfd,SIOCGIFBRDADDR,(char *)&local) == -1){	numberOfNets++;	close(localfd);	continue;      }      close(localfd);      memset(broadList[numberOfNets].sin_zero,	     0,sizeof(broadList[numberOfNets].sin_zero));      broadList[numberOfNets].sin_addr.s_addr = ((struct sockaddr_in *)&local.ifr_addr)->sin_addr.s_addr;      broadList[numberOfNets].sin_port = 0;#ifdef USES_BSD_4_4_SOCKET      /* copy the length */      broadList[numberOfNets].sin_len = local.ifr_addr.sa_len;#endif      /* ok we are done, increment the number of addresses */      numberOfNets++;    }else{      /* AF_INET6 has no mask or broadcast addr,       * at least that we care about       */      struct sockaddr_in6 *s6;      memset(&maskList[numberOfNets],0,sizeof(struct sockaddr_in));      memset(&broadList[numberOfNets],0,sizeof(struct sockaddr_in));      s6 = (struct sockaddr_in6 *)localNets[numberOfNets];      if((IN6_IS_ADDR_LINKLOCAL(&s6->sin6_addr) &&	*(u_short *)&s6->sin6_addr.s6_addr[2] != 0)){	      /* KAME HACK: to pull out embedded link local scope */	    u_short index;	    index = *(u_short *)&s6->sin6_addr.s6_addr[2];	    *(u_short *)&s6->sin6_addr.s6_addr[2] = 0;	    if (s6->sin6_scope_id == 0)	      s6->sin6_scope_id = ntohs(index);      }      numberOfNets++;    }  }  /* copy the new values back in */  *localNets1 = localNets;  *maskList1 = maskList;  *broadList1 = broadList;  *numberOfNets1 = numberOfNets;  *numberOfNetsAloc = numAlocAddr;  if(mtuList1 != NULL){    *mtuList1 = mtuList;  }  return(0);}struct SCTP_association *SCTPfindAssociation(struct SCTP *m, struct sockaddr *addr, int *netNum){  /* look for a allocated association and    * return a pointer to it to the caller.   */  int keySiz;  struct SCTP_association *asoc;  void *keyp;  asoc = (struct SCTP_association *)NULL;  if(addr->sa_family == AF_INET){    struct sockaddr_in *sin;    keySiz = sizeof(struct sockaddr_in);    sin = (struct sockaddr_in *)addr;    memset(sin->sin_zero,0,sizeof(sin->sin_zero));  }else if(addr->sa_family == AF_INET6){    struct sockaddr_in6 *sin6;    keySiz = sizeof(struct sockaddr_in6);    sin6 = (struct sockaddr_in6 *)addr;    sin6->sin6_flowinfo = 0;    if(!IN6_IS_ADDR_LINKLOCAL(&sin6->sin6_addr)){	    sin6->sin6_scope_id = 0;    }  }else{    keySiz = 0;  }  if(keySiz){    SCTPdebugPrint(m,"Looking up address of size %d\n",		   keySiz);    SCTPdebugPrintAddress(m,addr);    SCTPdebugPrintArry(m,(char *)addr,keySiz);    asoc = (struct SCTP_association *)HashedTbl_lookup(m->allAssoc,						       (void *)addr,keySiz,						       &keyp);  }  *netNum = 0;  if(asoc == NULL)    SCTPdebugPrint(m,"Association NOT found\n");  else{    int i;    if(netNum != NULL){      for(i=0;i<asoc->numnets;i++){	if(keyp == (void *)asoc->nets[i].ina){	  SCTPdebugPrint(m,"Association index set to %d\n",i);	  *netNum = i;	}      }    }    SCTPdebugPrint(m,"Association found at %x\n",(u_int)asoc);  }  return(asoc);}struct SCTP_association *findAssociationForAsconf(struct SCTP *m,struct sctpRelChunkDesc *chk,			 struct sockaddr *frm){  struct SCTP_association *asoc;  struct sockaddr *lookup;  struct sockaddr_in sin,*s;  struct sockaddr_in6 sin6,*s6;  int keyLen;  SCTPdebugPrint(m,"Ok, now doing ASCONF special find\n");  if(chk->addressType == (u_char)(SCTP_IPV4_PARAM_TYPE & 0x00ff)){    SCTPdebugPrint(m,"Chunk type is IPv4\n");    memset(&sin,0,sizeof(sin));    s = (struct sockaddr_in *)frm;    sin.sin_port = s->sin_port;    sin.sin_family = AF_INET;#ifdef USES_BSD_4_4_SOCKET    sin.sin_len = sizeof(struct sockaddr_in);#endif    memcpy(&sin.sin_addr,chk->lookupAddress,sizeof(struct in_addr));    lookup = (struct sockaddr *)&sin;    keyLen = sizeof(struct sockaddr_in);  }else if(chk->addressType == (u_char)(SCTP_IPV6_PARAM_TYPE & 0x00ff)){    SCTPdebugPrint(m,"Chunk type is IPv6\n");    memset(&sin6,0,sizeof(sin6));    s6 = (struct sockaddr_in6 *)frm;    sin6.sin6_port = s6->sin6_port;    sin6.sin6_family = AF_INET6;#ifdef USES_BSD_4_4_SOCKET    sin6.sin6_len = sizeof(struct sockaddr_in6);#endif    memcpy(&sin6.sin6_addr,chk->lookupAddress,sizeof(struct in6_addr));        lookup = (struct sockaddr *)&sin6;    keyLen = sizeof(struct sockaddr_in6);  }else{    return(NULL);  }  SCTPdebugPrint(m,"Lookup address (sz:%d),is as follows\n");  SCTPdebugPrintAddress(m,lookup);  asoc = (struct SCTP_association *)HashedTbl_lookup(m->allAssoc,						     (void *)lookup,keyLen,						     NULL);  return(asoc);}intsctpVerifyNoNewAddress(struct SCTP *m,		       struct SCTP_association *asoc,		       struct sctpUnifiedInit *m1,		       struct sockaddr *from		       ){    /* takes the association and picks apart the inits structure   * updating all ip address /ports into the association struct   */  struct SCTP_association *tasoc;  struct sctpV4IpAddress *point;  struct sctpV6IpAddress *point6;  struct sctpParamDesc *paramPoint,*tPoint;  struct sockaddr_in ai;  struct sockaddr_in6 ai6;  int at,max;  int tempy;  u_long point1,point2;  u_short parat,plen;  /* Initialize common struct's used here */  memset(&ai,0,sizeof(ai));  memset(&ai6,0,sizeof(ai6));#ifdef USES_BSD_4_4_SOCKET  ai.sin_len = sizeof(struct sockaddr_in);  ai6.sin6_len = sizeof(struct sockaddr_in6);#endif  ai.sin_family = AF_INET;  ai6.sin6_family = AF_INET6;  ai.sin_port = ((struct sockaddr_in *)from)->sin_port;  ai6.sin6_port = ((struct sockaddr_in6 *)from)->sin6_port;  at = sizeof(struct sctpUnifiedInit);  max = ntohs(m1->uh.chunkLength);  paramPoint = (struct sctpParamDesc *)((u_long)m1 + at);  SCTPdebugPrint(m,		 "paramPoint set to address %x m1 at %x\n",(u_long)paramPoint,		 (u_long)m1);  while(at < max){    plen = ntohs(paramPoint->paramLength);    if((plen < sizeof(struct sctpParamDesc)) || (plen > (max-at))){       return(0);    }    parat = ntohs(paramPoint->paramType);    if(parat == SCTP_IPV4_PARAM_TYPE){      point = (struct sctpV4IpAddress *)paramPoint;      ai.sin_addr.s_addr = point->ipAddress;      tasoc = SCTPfindAssociation(m,(struct sockaddr *)&ai,&tempy);      if(tasoc != asoc){	/* a new address as been added, either	 * it was a different association, or	 * it is new and someone maybe attempting	 * to takeover a existing assoc.	 */	return(1);      }    }else if (parat == SCTP_IPV6_PARAM_TYPE){      point6 = (struct sctpV6IpAddress *)paramPoint;      memcpy((char *)&ai6.sin6_addr,point6->ipAddress,sizeof(struct in6_addr));      tasoc = SCTPfindAssociation(m,(struct sockaddr *)&ai6,&tempy);      if(tasoc != asoc){	/* a new address as been added, either	 * it was a different association, or	 * it is new and someone maybe attempting	 * to takeover a existing assoc.	 */	return(1);      }    }    point1 = (u_long)paramPoint;    tPoint = (struct sctpParamDesc *)((u_long)paramPoint + plen);    paramPoint = (struct sctpParamDesc *)((((u_long)tPoint + 3) >> 2) << 2);    point2 = (u_long)paramPoint;    at += (point2-point1);  }  return(0);}struct SCTP_association *SCTPspecialFindAssociation(struct SCTP *m, struct sctpUnifiedInit *m1,			   struct sockaddr *from){  /* this lookup uses the Init message and looks at all possible   * IP address/ports in it to see if a association exists    */  int paramCnt,type;  struct SCTP_association *asoc;  struct sctpInitiation *msg;  struct sctpV4IpAddress *point;  struct sctpParamDesc *paramPoint,*tPoint;  struct sockaddr_in ai;  struct sockaddr_in6 ai6;  u_short plen;  int kk,at,max,nets;  u_long point1,point2;  asoc = (struct SCTP_association *)NULL;  memset(&ai,0,sizeof(ai));  memset(&ai6,0,sizeof(ai6));#ifdef USES_BSD_4_4_SOCKET  ai.sin_len = sizeof(struct sockaddr_in);  ai6.sin6_len = sizeof(struct sockaddr_in6);#endif  ai.sin_family = AF_INET;  ai6.sin6_family = AF_INET6;  ai.sin_port = ((struct sockaddr_in *)from)->sin_port;  /* cheat here since no matter which type port is in same place */  ai6.sin6_port = ((struct sockaddr_in6 *)from)->sin6_port;    SCTPdebugPrint(m,"In special find of assoc\n");  msg = &m1->initm;  nets = paramCnt = 0;  at = sizeof(struct sctpUnifiedInit);  max = ntohs(m1->uh.chunkLength);  paramPoint = (struct sctpParamDesc *)((u_long)m1 + at);  SCTPdebugPrint(m,"max of size will be %d starting at %x param is %x\n",		 max,(u_int)at,(u_int)paramPoint);  /* look for v4 addresss in param's and see if we can find the association */  while(at < max){    plen = ntohs(paramPoint->paramLength);    if((plen < sizeof(struct sctpParamDesc)) || (plen > (max-at))){      SCTPdebugPrint(m,"Invalid length of parameter!! %d\n",plen);      return(NULL);    }    type = ntohs(paramPoint->paramType);    if(type == SCTP_IPV4_PARAM_TYPE){      SCTPdebugPrint(m,"Found a V4 address\n");      point = (struct sctpV4IpAddress *)((caddr_t)paramPoint);      ai.sin_addr.s_addr = point->ipAddress;      asoc = SCTPfindAssociation(m,(struct sockaddr *)&ai, &kk);      if(asoc != NULL){	/* got him */	SCTPdebugPrint(m,"Found the ADDRESS!\n");	break;      }    }else if(type == SCTP_IPV6_PARAM_TYPE){      struct sctpV6IpAddress *point6;      SCTPdebugPrint(m,"Found a V6 address\n");      point6 = (struct sctpV6IpAddress *)((caddr_t)paramPoint);      memcpy((char *)&ai6.sin6_addr,point6->ipAddress,	     sizeof(struct in6_addr));      asoc = SCTPfindAssociation(m,(struct sockaddr *)&ai6, &kk);      if(asoc != NULL){	/* got him */	SCTPdebugPrint(m,"Found the ADDRESS!\n");	break;      }    }    /*********************************************/    /* Should add support for IPV6 at this point */    /*********************************************/    /* re-calulate to the next guy */    point1 = (u_long)paramPoint;    tPoint = (struct sctpParamDesc *)((u_long)paramPoint + plen);    paramPoint = (struct sctpParamDesc *)((((u_long)tPoint + 3) >> 2) << 2);    point2 = (u_long)paramPoint;    at += (point2-point1);    SCTPdebugPrint(m,"New points tPoint:%x at:%d newParam:%x\n",		   (u_int)tPoint,at,(u_int)paramPoint);  }  /* well we may have seen it or not */  return(asoc);}struct SCTP_association *SCTPalocAssociation(struct SCTP *m,struct sockaddr *to,int locScope,		    int siteScope,int ipv4Scope){  /* Find a free association and allocate it */  struct SCTP_association *asoc,*pasoc;  int keySiz;  asoc = w_calloc(m,1, sizeof(struct SCTP_association));  if(asoc == NULL){    return(asoc);  }  asoc->prev = asoc->next = NULL;  SCTPinitAAssociation(m,asoc,to,locScope,siteScope,ipv4Scope);  asoc->state = SCTP_STATE_INUSE;  asoc->nets = w_calloc(m,1,sizeof(struct SCTP_nets));  if(asoc->nets == NULL){    asoc->state = SCTP_STATE_EMPTY;    asoc->numnets = 0;    w_free(m,asoc);    return((struct SCTP_association *)NULL);  }else{    SCTPinitNetStruct(m,asoc,&asoc->nets[0],to);    asoc->numnets = 1;  }  if(to->sa_family == AF_INET){    keySiz = sizeof(struct sockaddr_in);  }else if(to->sa_family == AF_INET6){    keySiz = sizeof(struct sockaddr_in6);  }else{    SCTPdebugPrint(m,"Huh, unknown protocol, warning unkeyed-association %d\n",		   to->sa_family);    keySiz = 0;  }  if(keySiz){    SCTPdebugPrint(m,"Enter %d bytes for to address in hash table\n",		   keySiz);    SCTPdebugPrintAddress(m,asoc->nets[0].ina);    SCTPdebugPrintArry(m,(char *)asoc->nets[0].ina,keySiz);    HashedTbl_enter(m->allAssoc,(void *)asoc->nets[0].ina,(void *)asoc,keySiz);  }  pasoc = m->assoc;  if(pasoc == NULL){    /* only guy */    m->assoc = asoc;  }else{    /* ok place it in the list */    while(pasoc != NULL){      if(pasoc->next == NULL){	/* ok we are at the end */	pasoc->next = asoc;	asoc->prev = pasoc;	break;      }else{	/* next please */	pasoc = pasoc->next;      }    } /* end while(pasoc != NULL) */  }/* end else */  return(asoc);}intSCTPfreeAssociation(struct SCTP *m, struct SCTP_association *asoc){  int j,keySiz,i;  asoc->state = SCTP_STATE_EMPTY;  clearAllTimers(m,asoc);  /* this code should not run, it should   * be that the freeing caller should   * have called all these sent datagrams   * up to the sending user   */  while(asoc->outqueue != NULL){    struct SCTP_transmitOnQueue *tmp;    tmp = asoc->outqueue;    asoc->outqueue = tmp->next;    if(tmp->data != NULL){      SCTPdebugPrint(m,"free assoc frees O data:%x\n",(u_int)tmp->data);      w_free(m,tmp->data);      tmp->data = NULL;    }    SCTPdebugPrint(m,"free assoc frees O struct:%x\n",(u_int)tmp);    free(tmp);  }  while(asoc->sendqueue != NULL){    struct SCTP_transmitOnQueue *tmp;    tmp = asoc->sendqueue;    asoc->sendqueue = tmp->next;    if(tmp->data != NULL){      SCTPdebugPrint(m,"free assoc frees O data:%x\n",(u_int)tmp->data);      w_free(m,tmp->data);      tmp->data = NULL;    }    SCTPdebugPrint(m,"free assoc frees O struct:%x\n",(u_int)tmp);    free(tmp);  }  asoc->sendqueuetail = asoc->tailoutq = NULL;  /* now we must free up any of the junk   * in the streams awaiting other things   * before ordering.   */  /* first stream 0 */  while(asoc->inbound.inqueue != NULL){    struct SCTP_transmitOnQueue *tmp;    tmp = asoc->inbound.inqueue;    asoc->inbound.inqueue = tmp->next;    if(tmp->data != NULL){      SCTPdebugPrint(m,"free assoc frees I data:%x\n",(u_int)tmp->data);      w_free(m,tmp->data);      tmp->data = NULL;    }    SCTPdebugPrint(m,"free assoc frees I struct:%x\n",(u_int)tmp);    w_free(m,tmp);  }  if(asoc->opErr != NULL){    w_free(m,asoc->opErr);    asoc->opErr = NULL;  }  if(asoc->strmin != NULL){    for(j=0;j<asoc->streamincnt;j++){      while(asoc->strmin[j].inqueue != NULL){	struct SCTP_transmitOnQueue *tmp;	tmp = asoc->strmin[j].inqueue;	asoc->strmin[j].inqueue = tmp->next;	if(tmp->data != NULL){	  w_free(m,tmp->data);	  SCTPdebugPrint(m,"free assoc frees S data:%x\n",(u_int)tmp->data);	  tmp->data = NULL;	}	SCTPdebugPrint(m,"free assoc frees S struct:%x\n",(u_int)tmp);	w_free(m,tmp);      }    }    w_free(m,asoc->strmin);    asoc->strmin = NULL;  }  if(asoc->addrStats != NULL){    w_free(m,asoc->addrStats);  }  if(asoc->localNets != NULL){    for(i=0;i<asoc->numberOfNets;i++){      if(asoc->localNets[i] != NULL)	w_free(m,(char *)asoc->localNets[i]);    }    w_free(m,(char *)asoc->localNets);  }  if(asoc->maskList != NULL){    w_free(m,(char *)asoc->maskList);  }  if(asoc->ECN_echo != NULL){    w_free(m,asoc->ECN_echo);  }  asoc->ECN_echo = NULL;  if(asoc->CWR != NULL){    w_free(m,asoc->CWR);  }  asoc->CWR = NULL;  if(asoc->strmout != NULL)    w_free(m,asoc->strmout);  asoc->strmout = NULL;  if(asoc->nets != NULL){    for(i=0;i<asoc->numnets;i++){      struct SCTP_association *lasoc;      if(asoc->nets[i].ina != NULL){	if(asoc->nets[i].ina->sa_family == AF_INET){	  keySiz = sizeof(struct sockaddr_in);	}else if(asoc->nets[i].ina->sa_family == AF_INET6){	  keySiz = sizeof(struct sockaddr_in6);	}else{	  keySiz = 0;	}	if(keySiz){	  lasoc = HashedTbl_lookup(m->allAssoc,(void *)asoc->nets[i].ina,keySiz,(void **)NULL);	  if(lasoc == NULL){	    SCTPdebugPrint(m,"Warning, can't find address %d of freeing association\n",i);	    w_free(m,asoc->nets[i].ina);	    continue;	  }	  if((void *)lasoc != (void *)asoc){	    SCTPdebugPrint(m,"Ass KEY mis-match on free assoc:%x and f-assoc:%x both hold\n",			   (u_int)lasoc,(u_int)asoc);	    SCTPdebugPrintAddress(m,asoc->nets[i].ina);	    /* Free my copy and leave the other pointing in */	    w_free(m,asoc->nets[i].ina);	    continue;	  }	  /* This is what should happen and if I was not	   * paranoid I would just do a HashedTbl_remove() without looking :)	   */	  lasoc = (struct SCTP_association *)HashedTbl_remove(m->allAssoc,							      (void *)asoc->nets[i].ina,							      keySiz,(void **)NULL);	}	w_free(m,asoc->nets[i].ina);      }    }    w_free(m,asoc->nets);    asoc->nets = NULL;  }  if(asoc->mappingArray != NULL){    w_free(m,asoc->mappingArray);    asoc->mappingArray = NULL;  }  if(asoc->cookie != NULL){    w_free(m,asoc->cookie);    asoc->cookie = NULL;  }  asoc->numnets = 0;  if(asoc->queueOfRelReq != NULL){    dlist_destroy(asoc->queueOfRelReq);    asoc->queueOfRelReq = NULL;  }  if(asoc->pendingChunks != NULL){    HashedTbl_destroy(asoc->pendingChunks);    asoc->pendingChunks = NULL;  }  if(asoc->lastSentRelReq != NULL){    w_free(m,(char *)asoc->lastSentRelReq);    asoc->lastSentRelReq = NULL;  }  if(asoc->lastSentRelAck != NULL){    w_free(m,(char *)asoc->lastSentRelAck);    asoc->lastSentRelAck = NULL;  }  /* now lets take it out of the linked list */  if(asoc->prev == NULL){    /* at the head of the list */    m->assoc = asoc->next;    if(asoc->next){      asoc->next->prev = NULL;    }else{      /* list is now empty */      m->assoc = NULL;    }  }else{    /* not at head of list */    if(asoc->next == NULL){      /* at end of list */      if(asoc->prev != NULL){	asoc->prev->next = NULL;	asoc->prev = NULL;      }else{	/* list is now empty */	m->assoc = NULL;      }    }else{      /* in the middle someplace */      asoc->prev->next = asoc->next;      asoc->next->prev = asoc->prev;      asoc->prev = asoc->next = NULL;    }  }  w_free(m,asoc);  return(1);}u_longcalculateRTO(struct SCTP *m,	     struct SCTP_association *asoc,	     int on,  /* the network */	     u_long value1, 	     u_long value2){  /* given an association and the starting time of the current RTT    * period (in value1/value2) return RTO in number of us to the caller.   */  int calcTime, newRTO = 0;  struct timespec timenow;  /************************/  /* 1. calculate new RTT */  /************************/  /* First we get the time */  (*m->getTime)(&timenow);    calcTime = 0;  /* Now do the subtraction to get the RTT value */  if((u_long)timenow.tv_sec > value1) {    calcTime = ((u_long)timenow.tv_sec - value1) * 1000000;    if((u_long)timenow.tv_nsec > value2) {      calcTime += ((timenow.tv_nsec - value2)/1000);    } else if((u_long)timenow.tv_nsec < value2) {      calcTime -= (value2/1000);      calcTime += (timenow.tv_nsec/1000);    }  } else if((u_long)timenow.tv_sec == value1) {    if((u_long)timenow.tv_nsec > value2) {      calcTime = (timenow.tv_nsec - value2)/1000;    } else if ((u_long)timenow.tv_nsec < value2) {      /* impossible .. garbage in nothing out */      return(0);    } else {      /* impossible .. garbage in nothing out */      return(0);    }  } else {    /* impossible .. garbage in nothing out */    return(0);  }  /***************************/  /* 2. update RTTVAR & SRTT */  /***************************/  SCTPdebugPrint(m,"Time in usec is %d\n",calcTime);  SCTPdebugPrint(m,"lastsa:%d lastsv:%d\n",		 asoc->nets[on].lastsa,		 asoc->nets[on].lastsv);  if(asoc->nets[on].lastsv || asoc->nets[on].lastsa) {    /* per Section 5.3.1 C3 in SCTP */    asoc->nets[on].lastsv /* RTTVAR */      = (int)(((double)(1.0 - 0.25) * (double)asoc->nets[on].lastsv) +	      (double)(0.25 * (double)abs(asoc->nets[on].lastsa - calcTime)));    asoc->nets[on].lastsa /* SRTT */      = (int)(((double)(1.0 - 0.125) * (double)asoc->nets[on].lastsa) + 	      (double)(0.125 * (double)calcTime));    SCTPdebugPrint(m,"Next update to sa/sv now lastsa:%d lastsv:%d\n",		   asoc->nets[on].lastsa,		   asoc->nets[on].lastsv);  } else {    /* the first RTT calculation, per C2 Section 5.3.1 */    asoc->nets[on].lastsa  /* SRTT */      = calcTime;    asoc->nets[on].lastsv /* RTTVAR */      = calcTime / 2;    SCTPdebugPrint(m,"First update to sa/sv now lastsa:%d lastsv:%d\n",		 asoc->nets[on].lastsa,		 asoc->nets[on].lastsv);  }  /* if RTTVAR goes to 0 you set to clock grainularity */  if(asoc->nets[on].lastsv == 0){    asoc->nets[on].lastsv =  SCTP_CLOCK_GRAINULARITY;  }  newRTO = asoc->nets[on].lastsa + 4 * asoc->nets[on].lastsv;  /* this is Van Jacobson's integer version */  /*    calcTime -= (asoc->nets[on].lastsa >> 3);    asoc->nets[on].lastsa += calcTime;    if(calcTime < 0) {      calcTime = -calcTime;    }    calcTime -= (asoc->nets[on].lastsv >> 2);    asoc->nets[on].lastsv += calcTime;    newRTO = ((asoc->nets[on].lastsa >> 2) + asoc->nets[on].lastsv) >> 1;  */    SCTPdebugPrint(m,"calculated time is 0x%x/%d\n", newRTO, newRTO);  /* bound it, per C6/C7 in Section 5.3.1 */  if(newRTO < SCTP_RTO_LOWER_BOUND){    SCTPdebugPrint(m,"Rounded to up to lower bound\n");    newRTO = SCTP_RTO_LOWER_BOUND;  }  if(newRTO > SCTP_RTO_UPPER_BOUND){    SCTPdebugPrint(m,"Rounded down to upper bound\n");    newRTO = SCTP_RTO_UPPER_BOUND;  }  /* we are now returning the RTT Smoothed */  return((u_long)newRTO);}voidupdateRTOtime(struct SCTP *m,	      struct SCTP_association *asoc,	      int netOn){  /* Do last calculation to update RTO.   * This is called to reset RTO when new   * data is ack'd   */  asoc->nets[netOn].RTO = asoc->nets[netOn].lastsa +                           4 * asoc->nets[netOn].lastsv;  /* this is Van Jacobson's integer version */  /*    asoc->nets[netOn].RTO = (((asoc->nets[netOn].lastsa >> 2) + 			    asoc->nets[netOn].lastsv) >> 1);    */  /* bound it, per C6/C7 in Section 5.3.1 */  if(asoc->nets[netOn].RTO < SCTP_RTO_LOWER_BOUND){    asoc->nets[netOn].RTO = SCTP_RTO_LOWER_BOUND;  }  if(asoc->nets[netOn].RTO > SCTP_RTO_UPPER_BOUND){    asoc->nets[netOn].RTO = SCTP_RTO_UPPER_BOUND;  }}voidinitSctpHeader(struct sctpHeader *h,u_long tag){  /* this is equivalant to a constructor   * for a SCTP default header.   */  h->source = h->destination = 0;  h->adler32 = 0;  h->verificationTag = htonl(tag);}struct sctpChunkDesc *SCTPbuildASAck(struct SCTP *m,	       struct SCTP_association *asoc){  struct sctpUnifiedSack *mh;  struct sctpSelectiveFrag *gapDescription;  int mysz,i;  char *dataAlloced;  u_short cntOfDupSacks;  u_long *duppoint;  int cntsegs,seeingOnes,maxi;    cntOfDupSacks = 0;  cntsegs = 0;  seeingOnes = 0;  /* a little optimize to only check where we have placed TSN's */  if(asoc->highestTSNinside >= asoc->mappingArrayHighestTSN){    maxi = asoc->highestTSNinside - asoc->mappingArrayHighestTSN;  }else{    maxi = asoc->highestTSNinside + (MAX_TSN - asoc->mappingArrayHighestTSN);  }  /* add one more to make sure calc's below come out right */  maxi++;  if(maxi > asoc->mappingArraySz){    /* this should not happen */    maxi = asoc->mappingArraySz;  }  /* first count the segments I hold. */  SCTPdebugPrint(m,"Now building a S-Ack structure\n");  for(i=0;i<maxi;i++){    if(seeingOnes){      /* while seeing Ones I must       * transition back to 0 before       * finding the next gap and       * counting the segment.       */      if(asoc->mappingArray[i] == 0){	cntsegs++;	seeingOnes = 0;      }	    }else{      if(asoc->mappingArray[i]){	seeingOnes = 1;      }    }  }  if(seeingOnes){    /* ended seeing 1's so I must count that     * segment too      */    cntsegs++;  }  /* now we have a count of segments.   * I need a struct sctpUnifiedSack, with a   * struct sctpSelectiveFrag for each fragment.   *   */  if((asoc->state & SCTP_STATE_MASK) == SCTP_STATE_SHUTDOWN){    mysz = (sizeof(struct sctpUnifiedSack) + (cntsegs * sizeof(struct sctpSelectiveFrag))) +       sizeof(struct sctpUnifiedShutdown);  }else{    mysz = (sizeof(struct sctpUnifiedSack) + (cntsegs * sizeof(struct sctpSelectiveFrag)));  }  if(asoc->numduptsns){    cntOfDupSacks = asoc->numduptsns;    mysz += (asoc->numduptsns * sizeof(u_long));    asoc->numduptsns = 0;  }  if(mysz+sizeof(struct sctpHeader) > (asoc->smallestMTU - (IP_HDR_SIZE + sizeof(struct sctpECN_echo)))){    int over;    /* We must never return more than what will fit in     * a MTU for the destination.      * Remove last segments from list and size alloc'd so that     * it all fits in the MTU.     */    over = (mysz+sizeof(struct sctpHeader) - (asoc->smallestMTU - (IP_HDR_SIZE + sizeof(struct sctpECN_echo)))) +       (sizeof(struct sctpSelectiveFrag) -1);    over /= sizeof(struct sctpSelectiveFrag);    mysz -= (over * sizeof(struct sctpSelectiveFrag));	    cntsegs -= over;  }  /* make some space for the sack's dup tsn's */  dataAlloced = w_calloc(m,1,mysz);  if(dataAlloced == NULL){    /* we are in big trouble if this happens */    printf("Out of memory .. can't build a S-Ack\n");    return(NULL);  }  mh = (struct sctpUnifiedSack *)dataAlloced;  mh->uh.chunkID = SCTP_SELECTIVE_ACK;  mh->uh.chunkFlg = 0;  mh->uh.chunkLength = htons(mysz);  gapDescription = (struct sctpSelectiveFrag *)((u_long)mh + sizeof(struct sctpUnifiedSack));  mh->sack.highestConseqTSN = htonl(asoc->mappingArrayHighestTSN);  /* here we should go out and count the number on the in-queue   * that are unread or have a count maintained in the m-> struct   * but since we are not doing it, give peer the max saying I   * have lots of room.   */  mh->sack.updatedRwnd = htonl(asoc->myRwnd);  mh->sack.numDupTsns = htons(cntOfDupSacks);  mh->sack.numberOfdesc = htons(cntsegs);    SCTPdebugPrint(m,		 "Now placing last acked %x in dg\n",		 asoc->mappingArrayHighestTSN);  seeingOnes = 0;  SCTPdebugPrint(m,"Number of Gap segments is %d\n",cntsegs);  SCTPdebugPrint(m,"Mapping array looks as follows for maxi:%d octets\n",maxi);  SCTPdebugPrintArry(m,asoc->mappingArray,maxi);  for(i=0;i<maxi;i++){    if(cntsegs == 0){      SCTPdebugPrint(m,"Out of segments ...\n");      break;    }    if(seeingOnes){      /* while seeing Ones I must       * transition back to 0 before       * finding the next gap        */      SCTPdebugPrint(m,"In seeing ZEROS\n");      if(asoc->mappingArray[i] == 0){	SCTPdebugPrint(m,"Gap Start is %d\n",i);	gapDescription->fragmentEnd = htons(((u_short)(i)));	SCTPdebugPrint(m,"Gapp was %x\n",(u_long)gapDescription);	SCTPdebugPrintArry(m,(char *)gapDescription,(sizeof(*gapDescription)));	gapDescription++;	SCTPdebugPrint(m,"NEW Gapp was %x\n",(u_long)gapDescription);	seeingOnes = 0;	cntsegs--;	SCTPdebugPrint(m,"Transition ->Now seeing ZEROS, one less segment! seg's left:%d\n",		       cntsegs);      }	    }else{      SCTPdebugPrint(m,"IN seeing Zeros\n");      if(asoc->mappingArray[i]){	SCTPdebugPrint(m,"Gap Ends (i.e. I found a 1 at):%d p=%x\n",i,		       (u_int)gapDescription);	gapDescription->fragmentStart = htons(((u_short)(i+1)));	/* advance struct to next pointer */	seeingOnes = 1;	SCTPdebugPrint(m,"Transition ->Now seeing ONES!\n");      }    }  }  if(cntsegs){    /* special case where     * the array is all 1's     * to the end of the array.     */    SCTPdebugPrint(m,"Gap end (open) is %d\n",(i));    SCTPdebugPrint(m,"LAST:Gapp was %x\n",(u_long)gapDescription);    gapDescription->fragmentEnd = htons(((u_short)(i)));    SCTPdebugPrintArry(m,(char *)gapDescription,(sizeof(*gapDescription)));    gapDescription++;  }  /* now add on the list of duplicates if there   * is any.   */  if(cntOfDupSacks){    duppoint = (u_long *)gapDescription;    for(i=0;i<cntOfDupSacks;i++){      *duppoint = asoc->dupTsns[i];      duppoint++;    }    gapDescription = (struct sctpSelectiveFrag *)duppoint;  }  if((asoc->state & SCTP_STATE_MASK) == SCTP_STATE_SHUTDOWN){    /* append a SHUTDOWN chunk to this guy */    struct sctpUnifiedShutdown *sc;    sc = (struct sctpUnifiedShutdown *)gapDescription;    sc->uh.chunkID = SCTP_SHUTDOWN;    sc->uh.chunkFlg = 0;    sc->uh.chunkLength = htons(sizeof(struct sctpUnifiedShutdown));    sc->shut.TSN_Seen = htonl(asoc->mappingArrayHighestTSN);    sc++;    gapDescription = (struct sctpSelectiveFrag *)sc;  }  SCTPdebugPrint(m,"Ok all done with sack\n");  return((struct sctpChunkDesc *)mh);}intSCTPaddOutboundData(struct SCTP *m,		    struct SCTP_association *asoc,		    struct SCTP_stream_out *str,char *data,int siz,		    int options,int whichNet,int strNum,		    int payloadtype,int numOfRetrans){  /* we encode the data in a   * SCTP_transmitOnQueue structure    * setting the data pointer to point at   * a sctpHeader and data portion with the data   * following. The sending routine will   * need to piggyback out a S-Ack if it wants   * to ack. Or it may add a cookie if needed.   */  struct SCTP_transmitOnQueue *tmit,*tmplist,*tailtlist;  struct sctpUnifiedDatagram *qdta;  char *odata;  char *copyto;  int curchunk,fir,addedChk;  int sizeToAdd = siz;  int neededSize;  int smallestMTU;  tailtlist = tmplist = NULL;  fir = 1;  addedChk = 0;  odata = data;  /* PHIL CONRAD: Before adding I would check to see if   * the stream has a size limit. If it does you need   * to reject the send by returning a -1 or something   * like that   */  SCTPdebugPrint(m,"Add outbound wants to add data of %d\n",siz);  smallestMTU = asoc->smallestMTU;  smallestMTU -= (sizeof(struct sctpUnifiedDatagram) + 		  IP_HDR_SIZE +		  sizeof(struct sctpHeader));  if((asoc->state != SCTP_STATE_OPEN) ||     (asoc->ECN_Allowed)){    smallestMTU -= sizeof(struct sctpECN_echo);  }  while(sizeToAdd){    /* does it fit in one chunk or is it multi-part? */    curchunk = sizeToAdd;    neededSize = (curchunk + sizeof(struct sctpUnifiedDatagram) +  		  sizeof(struct sctpHeader) +		  IP_HDR_SIZE		  );    if((asoc->state != SCTP_STATE_OPEN) ||       (asoc->ECN_Allowed)){      neededSize += sizeof(struct sctpECN_echo);	          }    SCTPdebugPrint(m,"Ok, I need %d bytes REAL smallestMTU:%d\n",		   neededSize,asoc->smallestMTU);    if(neededSize > asoc->smallestMTU){      /* got to shrink the chunk size */      SCTPdebugPrint(m,"Shrink chunk size to %d\n",smallestMTU);      curchunk = smallestMTU;    }    /* get a struct to point to it */    tmit = w_calloc(m,1,sizeof(struct SCTP_transmitOnQueue));    if(tmit == NULL){      /* no memory */      while(tmplist != NULL){	tmit = tmplist;	tmplist = tmit->next;	SCTPdebugPrint(m,"add outbound data:%x\n",(u_int)tmit->data);	w_free(m,tmit->data);	SCTPdebugPrint(m,"add outbound struct:%x\n",(u_int)tmit);	w_free(m,tmit);      }      return(-1);    }    SCTPdebugPrint(m,"ALLOC:add outbound grabs:%x\n",(u_int)tmit);    tmit->doingFastRetransmit = 0;    tmit->toAddr = 0;    tmit->tos = asoc->tos;    /* We will need to allow the user to set this FIX */    tmit->ipv6_flow = strNum;    tmit->sizeOfTmit = sizeof(struct sctpUnifiedDatagram) + curchunk;    tmit->data = w_calloc(m,1,tmit->sizeOfTmit);    if(tmit->data == NULL){      /* no memory,        * preserve errno because       * I am parinoid.       */      int x;      x = errno;      w_free(m,tmit);      while(tmplist != NULL){	tmit = tmplist;	tmplist = tmit->next;	SCTPdebugPrint(m,"2:add outbound data:%x\n",(u_int)tmit->data);	w_free(m,tmit->data);	SCTPdebugPrint(m,"2:add outbound struct:%x\n",(u_int)tmit);	w_free(m,tmit);      }      errno = x;      return(-1);    }    SCTPdebugPrint(m,"ALLOC:add outbound grabs data:%x siz:%d\n",(u_int)tmit->data,		   tmit->sizeOfTmit);    /* add this to the chain */    tmit->next = NULL;    if(tailtlist == NULL){      tmplist = tmit;      tmit->prev = tailtlist;      tailtlist = tmit;    }else{      tmit->prev = tailtlist;      tailtlist->next = tmit;      tailtlist = tmit;    }    /* assign sequence number no increment. */    tmit->streamSeq = str->nextSequenceSent;    tmit->asoc = asoc;    tmit->sent = SCTP_DATAGRAM_UNSENT;    tmit->whichNet = whichNet;    tmit->sent_rcv_Time.tv_sec = 0;    tmit->sent_rcv_Time.tv_nsec = 0;    tmit->sndCount = 0;    tmit->payloadtype = payloadtype;    tmit->numOfRetrans = numOfRetrans;    tmit->sendOptions = options | SCTP_DONT_FRAGMENT;    tmit->TSN_seq = asoc->sendingSeq++;    qdta = (struct sctpUnifiedDatagram *)tmit->data;    qdta->uh.chunkID = SCTP_DATA;    /*******************************************/    /* which piece am i on?                    */    /* fir = 1 at the begginging so if it is   */    /* 1 and siz == curchunk it is non-frag    */    /* if fir=0 and sie == curchunk it is last */    /* otherwise it is middle                  */    /*******************************************/    if((siz == curchunk) && (fir == 1)){      qdta->uh.chunkFlg = SCTP_DATA_NOT_FRAG;    }else if(fir){      qdta->uh.chunkFlg = SCTP_DATA_FIRST_FRAG;      fir = 0;    }else if(sizeToAdd == curchunk){      qdta->uh.chunkFlg = SCTP_DATA_LAST_FRAG;    }else{      qdta->uh.chunkFlg = SCTP_DATA_MIDDLE_FRAG;    }    qdta->uh.chunkLength = htons((u_short)tmit->sizeOfTmit);    /* This will set the non-ordered delivery flag if needed */    if(options & SCTP_NON_ORDERED_DELIVERY){      qdta->uh.chunkFlg |= SCTP_DATA_UNORDERED;    }    /* set into the data area the right values */    qdta->dp.streamId = (u_short)htons(strNum);    qdta->dp.sequence = (u_short)htons(tmit->streamSeq);    qdta->dp.payloadtype = (u_long)htonl(payloadtype);    /* These should be filled in by     * the actual send mod when it changes tmit->sent     * once changed they should never be touched again. Especially     * if I was going to add the time-out function.     */    qdta->dp.TSN = htonl(tmit->TSN_seq);    copyto = (char *)((u_long)qdta + sizeof(struct sctpUnifiedDatagram));    memcpy(copyto,odata,curchunk);    addedChk++;    /* ok now put it on the end of the outbound list */    /* the brute force way :-> */    asoc->outQueueCount++;    sizeToAdd -= curchunk;    /* re-calculate next postion to copy from */    odata = (char *)((u_int)odata + curchunk);  }  /* now put it on the end of the queue */  if(asoc->outqueue == NULL){    asoc->outqueue = tmplist;    asoc->tailoutq = tailtlist;  }else{    asoc->tailoutq->next = tmplist;    tmplist->prev = asoc->tailoutq;    asoc->tailoutq = tailtlist;  }  /* if it was ordered bump the stream seq number */  if((options & SCTP_NON_ORDERED_DELIVERY) == 0){    str->nextSequenceSent++;  }  asoc->numberUnsent += addedChk;  return(0);}void SCTPProcHBResp(struct SCTP *m,		    struct SCTP_association *asoc,		    struct sockaddr *from,		    struct sctpHBsender *uh,		    int netOn){  /* Processes a HB response from a previous request.   *   - take care of HB stuff saying it arrived if same   *   - call calcRtt to generate RTT results data to update   *     RTO info for the destination. We should get   *     more fancy and use the DEST info to where we   *     sent it but this impl only lets one HB out at   *     a time.   */  struct SCTP_association *lasoc;  int realNet;    lasoc = SCTPfindAssociation(m,(struct sockaddr *)uh->addrFmt,&realNet);  if(lasoc == NULL)    return;  if(uh->userreq){    /* user demanded HB, go ahead     * and notify the user.     */    SCTPupperLayerNotification(m,asoc,SCTP_NOTIFY_HB_RESP,(int)uh);    /* we do NO processing, since it is not in our     * normal time-frame and we don't want any RTT     * estimates changed based on user requests.     */    return;  }  if(realNet == lasoc->lastHBOn){    /* tell hb that we got a response here */    lasoc->gotLastHB = 1;    lasoc->nets[realNet].errorCount = 0;    if((lasoc->nets[realNet].intfRotationState & SCTP_ADDR_REACHABLE) == 0){      /* announce the addition of a interface */      char to[SCTP_ADDRMAX];      SCTPmakeIntoSock(to,asoc,realNet);      asoc->nets[realNet].intfRotationState &= ~SCTP_ADDR_NOT_REACHABLE;      asoc->nets[realNet].intfRotationState |= SCTP_ADDR_REACHABLE;      asoc->nets[realNet].errorCount = 0;      SCTPupperLayerNotification(m,asoc,SCTP_NOTIFY_INTF_UP,(int)to);    }    /* now get RTT stuff and call the calc function. */    lasoc->nets[realNet].RTO = calculateRTO(m,lasoc,					 realNet,					 uh->rtt.time_value_1,					 uh->rtt.time_value_2);    SCTPdebugPrint(m,"RTO %d\n",		   lasoc->nets[realNet].RTO);  }else{    SCTPdebugPrint(m,"Response came from %d not %d skipping HB\n",		   realNet,lasoc->lastHBOn);  }}struct cookieMessage *SCTPbuildACookie(struct SCTP *m,		 struct SCTP_association *pasoc,		 struct sctpUnifiedInit *uh,		 int *lenOfCook,		 char **report,		 int *repsz,		 struct sockaddr *to){  /* this module will build a cookie and   * return it to the caller. It will use the   * passed in association to build the cookie. The   * time information needed for validation is   * already in the allocated association.   */  struct sctpParamDesc *datasrch;  char *retCookie,*paramarea,*copyPoint;  int death;  int szOfCook,netsz,nonSignPart,extendedTime,sizeLimit;  int setFlag;  u_int *addrsPs;  u_int i;  int siteScope,locScope,addrSize,ipv4Scope;  struct cookieMessage *cp;  struct sockaddr_in6 *a6;    struct sockaddr_in *a;    setFlag = 0;  netsz = ntohs(uh->uh.chunkLength);  SCTPdebugPrint(m,"Size of INIT msg %d\n",netsz);  /* More IPv6 stuff to worry about here too */  nonSignPart = sizeof(struct cookieMessage) + netsz;  SCTPdebugPrint(m,"Size of cookie %d\n",nonSignPart);  /* calculate the scope variables. */  if(to->sa_family == AF_INET6){    a6 = (struct sockaddr_in6 *)to;    /*    ipv4Scope = 0;*/    ipv4Scope = 1;    if(IN6_IS_ADDR_LINKLOCAL(&a6->sin6_addr)){      /* link, site and global scope */      locScope = siteScope = 1;    }else if(IN6_IS_ADDR_SITELOCAL(&a6->sin6_addr)){      /* site&global scope */      locScope = 0;      siteScope = 1;    }else{      /* global scope */      locScope = 0;      siteScope = 0;    }  }else{    a = (struct sockaddr_in *)to;    SCTPdebugPrint(m,"To address is\n");    SCTPdebugPrintAddress(m,to);    locScope = 0;    siteScope = 1;    /*    if(IN4_ISPRIVATE_ADDRESS(&a->sin_addr)){*/    /*      SCTPdebugPrint(m,"Address is private\n");*/      ipv4Scope = 1;      /*    }else{*/      /*      SCTPdebugPrint(m,"Address is NOT private\n");*/      /*      ipv4Scope = 0;*/      /*    }*/  }  SCTPdebugPrint(m,"Scope IPV4:%d IPV6:%d/%d\n",		 ipv4Scope,locScope,siteScope);  addrSize = 0;  for(i=0;i<m->numberOfNets;i++){    if(m->localNets[i]->sa_family == AF_INET){      a = (struct sockaddr_in *)m->localNets[i];      if((ipv4Scope == 0) && (IN4_ISPRIVATE_ADDRESS(&a->sin_addr))){	SCTPdebugPrint(m,"Skip private IPV4 address\n");	continue;      }      addrSize += sizeof(struct sctpV4IpAddress);      SCTPdebugPrint(m,"Adding IPV4 address [%d] size now %d\n",		     i,addrSize);    }else if(m->localNets[i]->sa_family == AF_INET6){      a6 = (struct sockaddr_in6 *)m->localNets[i];      if((locScope == 0) && (IN6_IS_ADDR_LINKLOCAL(&a6->sin6_addr))){	continue;      }else if((siteScope == 0) && (IN6_IS_ADDR_SITELOCAL(&a6->sin6_addr))){	continue;      }      addrSize += sizeof(struct sctpV6IpAddress);      SCTPdebugPrint(m,"Adding IPV6 address [%d] size now %d\n",		     i,addrSize);    }  }  nonSignPart += addrSize;  /* Add in size part */  nonSignPart += sizeof(u_int);  SCTPdebugPrint(m,"Adding for networks %d bytes for a total of %d\n",		 addrSize,nonSignPart);  szOfCook = nonSignPart + SCTP_SIGNATURE_SIZE;  SCTPdebugPrint(m,"Size of cookie I build is %d\n",szOfCook);  retCookie = w_calloc(m,1,szOfCook);  if(retCookie == NULL){    *lenOfCook = 0;    return(NULL);  }  *lenOfCook = szOfCook;  cp = (struct cookieMessage *)retCookie;  if(pasoc == NULL){    cp->TieTag_curTag = 0;    cp->TieTag_hisTag = 0;    cp->addressWhereISent[0] = 0;    cp->addressWhereISent[1] = 0;    cp->addressWhereISent[2] = 0;    cp->addressWhereISent[3] = 0;    cp->addrtype = 0;  }else{    cp->TieTag_curTag = pasoc->curTag;    cp->TieTag_hisTag = pasoc->hisTag;    /* Save off the base address of this so I can     * find it     */        if(pasoc->nets[0].ina->sa_family == AF_INET){      struct sockaddr_in *sin;      sin = (struct sockaddr_in *)pasoc->nets[0].ina;      cp->addressWhereISent[0] = sin->sin_addr.s_addr;      cp->addressWhereISent[1] = 0;      cp->addressWhereISent[2] = 0;      cp->addressWhereISent[3] = 0;      cp->addrtype = SCTP_IPV4_PARAM_TYPE;    }else{      struct sockaddr_in6 *sin6;      char *ploc;      sin6 = (struct sockaddr_in6 *)pasoc->nets[0].ina;      ploc = (char *)cp->addressWhereISent;      memcpy(ploc,(char *)&sin6->sin6_addr,sizeof(struct in6_addr));      cp->addrtype = SCTP_IPV6_PARAM_TYPE;    }  }  /* set the scope into the cookie */  cp->locScope = locScope;  cp->siteScope = siteScope;  cp->ipv4Scope = ipv4Scope;  addrsPs = (u_int *)((u_long)cp + sizeof(struct cookieMessage));  SCTPdebugPrint(m,"Cookies address is 0x%x, addressPointers is at %x sz:%d\n",		 (u_int)cp,(u_int)addrsPs,addrSize);  *addrsPs = addrSize;  addrsPs++;  /* Copy out all of the addresses I am sending as well */  for(i=0;i<m->numberOfNets;i++){    if(m->localNets[i]->sa_family == AF_INET){      struct sctpV4IpAddress *foobar;      a = (struct sockaddr_in *)m->localNets[i];      if((ipv4Scope == 0) && IN4_ISPRIVATE_ADDRESS(&a->sin_addr)){	SCTPdebugPrint(m,"Skip private IPV4 address in copy\n");	continue;      }      foobar = (struct sctpV4IpAddress *)addrsPs;      /* we save these in our byte order */      foobar->p.paramType = SCTP_IPV4_PARAM_TYPE;      foobar->p.paramLength = sizeof(struct sctpV4IpAddress);      SCTPdebugPrint(m,"Copy IPV4 address loc:%x\n",(u_int)foobar);      SCTPdebugPrintAddress(m,m->localNets[i]);      foobar->ipAddress = a->sin_addr.s_addr;      foobar++;      addrsPs = (u_int *)foobar;    }else if(m->localNets[i]->sa_family == AF_INET6){      struct sctpV6IpAddress *foobar6;      a6 = (struct sockaddr_in6 *)m->localNets[i];      if((locScope == 0) && (IN6_IS_ADDR_LINKLOCAL(&a6->sin6_addr))){	continue;      }else if((siteScope == 0) && (IN6_IS_ADDR_SITELOCAL(&a6->sin6_addr))){	continue;      }      SCTPdebugPrint(m,"Copying IPV6 address %d into cookie loc:%x\n",		     i,(u_int)addrsPs);      SCTPdebugPrintAddress(m,m->localNets[i]);      foobar6 = (struct sctpV6IpAddress *)addrsPs;      foobar6->p.paramType = SCTP_IPV6_PARAM_TYPE;      foobar6->p.paramLength = sizeof(struct sctpV6IpAddress);      memcpy(foobar6->ipAddress,	     &a6->sin6_addr,	     sizeof(struct in6_addr));      foobar6++;      addrsPs = (u_int *)foobar6;    }  }  copyPoint = (char *)addrsPs;  SCTPdebugPrint(m,"Init/Param area is at %x\n",(u_int)copyPoint);  sizeLimit = netsz - sizeof(struct sctpUnifiedInit);  paramarea = (char *)((u_long)&uh->initm + sizeof(struct sctpInitiation));  /* Lets see if we want to extend the cookie life,   * we limit any such extension to no more than 2 * our normal   * cookie life.   */  death = 0;  datasrch = findAParameter(m,SCTP_COOKIE_PRESERVE,paramarea,			    sizeLimit,&death,report,repsz);  if(death){    SCTPdebugPrint(m,"Can NOT continue processing unrec param\n");    w_free(m,retCookie);    return(NULL);  }  if(datasrch != NULL){    struct sctpCookiePreserve *pres;    pres = (struct sctpCookiePreserve *)datasrch;    extendedTime = ntohl(pres->extraTime)/SCTP_MSEC_IN_A_SEC;    if((extendedTime == 0) && (pres->extraTime)){      /* min request is 1 second */      extendedTime = 1;    }    if(extendedTime > m->defCookieLife){      /* max of 2 * my cookie life */      extendedTime = m->defCookieLife;    }  }else{    extendedTime = 0;  }  cp->cookieLife = m->defCookieLife + extendedTime;  (*m->getTime)(&cp->timeEnteringState);  /* Copy out at the end the INIT w/params that arrived */  memcpy(copyPoint,uh,netsz);  if(m->preOpenStreamCount > uh->initm.MaxInboundStreams){    /* cut back my preopened streams. */    cp->initAckISent.NumPreopenStreams = htons(uh->initm.MaxInboundStreams);  }else{    cp->initAckISent.NumPreopenStreams = htons(m->preOpenStreamCount);  }  setFlag = 0;  if(pasoc != NULL){    if((pasoc->state == SCTP_STATE_COOKIE_WAIT) ||       (pasoc->state == SCTP_STATE_COOKIE_SENT)){      setFlag = 1;    }  }  SCTPdebugPrint(m,"Set flag is %d\n",setFlag);  if(setFlag == 0){    cp->initAckISent.initTag = htonl(SCTPselectATag(m));    cp->initAckISent.initialTSN = htonl(SCTPselectInitialTSN(m));    cp->initAckISent.rcvWindowCredit = htonl(m->maxWindow);    cp->initAckISent.MaxInboundStreams = htons(MAX_SCTP_STREAMS);    SCTPdebugPrint(m,"Set tags and things\n");  }else{    /* pull from pasoc must be in COOKIE-WAIT or COOKIE-ECHOED */    cp->initAckISent.initTag = htonl(pasoc->curTag);    cp->initAckISent.initialTSN = htonl(pasoc->initSeqNumber);    cp->initAckISent.rcvWindowCredit = htonl(m->maxWindow);    cp->initAckISent.MaxInboundStreams = htons(MAX_SCTP_STREAMS);    SCTPdebugPrint(m,"Set tags and things too\n");  }  SCTPdebugPrint(m,"Go do the md5 signing\n");  sctpMd5Digest(m,		(char *)m->secretKey[m->currentSecretNumber],		SCTP_SECRET_SIZE,		retCookie,nonSignPart,		(unsigned char *)&retCookie[nonSignPart]);  SCTPdebugPrint(m,"I built this cookie:%d\n",szOfCook);  SCTPdebugPrintArry(m,(char *)cp,16);  return(cp);}struct SCTP_association *SCTPplainCookie(struct SCTP *m,char *cookie,int len,		struct sockaddr *from,		struct SCTP_association *existing,		struct sctpHeader *dg,		struct cookieMessage *cookieP,		struct sctpUnifiedInit *peersInit		){  /* ok its a good cookie, and it is not a restart situation (normal   * association startup case.    */  int ret,oldstate;  struct SCTP_association *asoc;  asoc = SCTPalocAssociation(m,from,cookieP->locScope,cookieP->siteScope,			     cookieP->ipv4Scope);  if(asoc == NULL){    struct SCTP_association *as;    as = (struct SCTP_association *)cookie;    SCTPdebugPrint(m,"sorry no room at the inn\n");    SCTPsendAAbort(m,asoc,from,as->hisTag,SCTP_OP_ERROR_NO_RESOURCE,0);    return(NULL);  }  /* now we restore the association into its open state */  /* first glom out my local items */  asoc->curTag = ntohl(cookieP->initAckISent.initTag);  asoc->relReqSeqOut = asoc->initSeqNumber = asoc->sendingSeq = ntohl(cookieP->initAckISent.initialTSN);  asoc->t3timeoutHighestMarked = asoc->relReqSeqOut;  asoc->lastCWR_TSN = asoc->initSeqNumber - 1;  asoc->relReqSeqIn = asoc->lastAckedSeq = asoc->initSeqNumber - 1;  asoc->myRwnd = ntohl(cookieP->initAckISent.rcvWindowCredit);  asoc->preOpenStreams = ntohs(cookieP->initAckISent.NumPreopenStreams);  SCTPdebugPrint(m,"Now adopting the INIT\n");  ret = SCTPadoptThisInit(m,from,asoc,peersInit);  if(ret < 0){    SCTPdebugPrint(m,"We have a problem %d -- either deadflag or unresovlable name\n",ret);    if(ret == -1){      /* Any operational error will be picked up by the        * abort code and sent along with the NO_RESOURCE        * indication.       */      SCTPsendAAbort(m,asoc,from,asoc->hisTag,SCTP_OP_ERROR_NO_RESOURCE,0);    }else{      /* Here is the other case, where we discard the packet (per       * the upper bit of the parameter) so we do not send       * back a cookie ack, and we instead send a op error.       * This should have been caught at the INIT-ACK send though.       */      if(asoc->opErr != NULL){	SCTPsendOpErr(m,from,asoc->opErr,asoc->opErrSiz,peersInit->initm.initTag);      }    }    SCTPfreeAssociation(m,asoc);    return(NULL);  }  SCTPdebugPrint(m,"Do RTT calculation from Init-Ack <-> Cookie time\n");  asoc->nets[asoc->lastNetRcvdFrom].RTO = calculateRTO(m,asoc,asoc->lastNetRcvdFrom,						       cookieP->timeEnteringState.tv_sec,						       cookieP->timeEnteringState.tv_nsec);  /* Tell the peer we are happy */  SCTPsendCookieAck(m,asoc,from);  /*    * report the assocation up to the upper layer   */   oldstate = asoc->state & SCTP_STATE_SHUTDOWN_PEND;  SCTPdebugPrint(m,"STATE SET TO OPEN ORed with %d\n",oldstate);  asoc->state = (SCTP_STATE_OPEN | oldstate);  SCTPupperLayerNotification(m,asoc,			     SCTP_NOTIFY_ASSOC_UP,asoc->numnets);  timerWork(m,asoc,SCTP_TIMER_START,SctpTimerTypeHeartbeat,0);  /* bring up the PMTU raise timer */  timerWork(m,asoc,SCTP_TIMER_START,SctpTimerTypePathMtuRaise,0);  return(asoc);}struct SCTP_association *SCTPcomplexCookie(struct SCTP *m,char *cookie,int len,		  struct sockaddr *from,		  struct SCTP_association *existing,		  struct sctpHeader *dg,		  struct cookieMessage *cookieP,		  struct sctpUnifiedInit *peersInit,		  struct sockaddr *toAddr		  ){  /* ok this is the case where we have   * gotten another cookie and a already   * existing association. It may be   * a restart, it may be a old dg. lets   * find out.   */  struct SCTP_association lasoc;  unsigned long tmp;  int i,ret,oldstate;  SCTPdebugPrint(m,"Doing complex case ... collision?\n");  if((existing->state&SCTP_STATE_MASK) == SCTP_STATE_SHUTDOWN_ACK_SENT){    /* special case of crossing INIT-ACK and then a     * shutdown came in     */    SCTPsendShutdownAck(m,existing,from,SCTP_SHUTDOWN_ACK,0,toAddr);    return(NULL);  }  memcpy((char *)&lasoc,cookie,sizeof(struct SCTP_association));  /* do a bit of fixing of the internal cookieP info */  tmp = ntohl(cookieP->initAckISent.initTag);  cookieP->initAckISent.initTag = tmp;  tmp = ntohl(cookieP->initAckISent.rcvWindowCredit);  cookieP->initAckISent.rcvWindowCredit = tmp;  tmp = ntohl(cookieP->initAckISent.initialTSN);  cookieP->initAckISent.initialTSN = tmp;  tmp = ntohs(cookieP->initAckISent.NumPreopenStreams);  cookieP->initAckISent.NumPreopenStreams = tmp;  tmp = ntohs(cookieP->initAckISent.MaxInboundStreams);  cookieP->initAckISent.MaxInboundStreams = tmp;  if((cookieP->initAckISent.initTag == existing->curTag) &&      (peersInit->initm.initTag == existing->hisTag)){    /* note, no ntohl on the peersInit is needed since     * we did that and stuffed the host order      * fixed INIT params in the outbound Cookie     */    /* If both tags match it is Case D, and it may be     * we need do nothing but send a Cookie-Ack     * :M M A A: case if we are before the OPEN state     * we need to move out to Establised/OPEN.     */    SCTPdebugPrint(m,"Direct colliding INITs or lost cookie-ack\n");    switch((existing->state&SCTP_STATE_MASK)){    case SCTP_STATE_COOKIE_WAIT:      /* I have sent a INIT and somehow, not sure how, I       * have both tags and they match. It is M M A A       * case so we stop and accept all.       */      SCTPdebugPrint(m,"I was in cookie-wait\n");    case SCTP_STATE_COOKIE_SENT:      /* Here is clearly a duplicate INIT case.        * A difference indicating a collision but       * we won't since it is a mote point :)       */      if((existing->state&SCTP_STATE_MASK) == SCTP_STATE_COOKIE_SENT){	SCTPdebugPrint(m,"I was in cookie-sent\n");      }      timerWork(m,existing,SCTP_TIMER_STOP,SctpTimerTypeHeartbeat,0);      timerWork(m,existing,SCTP_TIMER_STOP,SctpTimerTypePathMtuRaise,0);      timerWork(m,existing,SCTP_TIMER_STOP,SctpTimerTypeInit,0);      timerWork(m,existing,SCTP_TIMER_STOP,SctpTimerTypeCookie,0);      for(i=0;i<existing->numnets;i++){	timerWork(m,existing,SCTP_TIMER_STOP,SctpTimerTypeSend,i);      }      /* preserve any shutdown pending mask */      oldstate = existing->state & SCTP_STATE_SHUTDOWN_PEND;      existing->state = (SCTP_STATE_OPEN | oldstate);      SCTPdebugPrint(m,"STATE SET TO OPEN ORed with %d\n",oldstate);      SCTPupperLayerNotification(m,existing,			     SCTP_NOTIFY_ASSOC_UP,existing->numnets);      timerWork(m,existing,SCTP_TIMER_START,SctpTimerTypePathMtuRaise,0);      timerWork(m,existing,SCTP_TIMER_START,SctpTimerTypeHeartbeat,0);      /* add a slight cross check for sanity :) a TSNH */      if(existing->streamincnt != peersInit->initm.NumPreopenStreams){	SCTPdebugPrint(m,		       "Either really bad luck on restart or software error asoc:Sin=%d peer:Sin=%d\n",		       existing->streamincnt,peersInit->initm.NumPreopenStreams);      }      break;    default:      /* we have already went beyond the Established       * state. Must be a lost Cookie-Ack, so we break       * and the send of a Cookie-Ack finishes us up.       */      break;    }    SCTPdebugPrint(m,"SENDING OUT COOKIE ACK\n");    SCTPsendCookieAck(m,existing,from);    return(existing);  }  if((cookieP->initAckISent.initTag != existing->curTag) &&     (peersInit->initm.initTag == existing->hisTag) &&     (cookieP->TieTag_curTag == 0) &&     (cookieP->TieTag_hisTag ==0)      ){         /* case C in table at 5.2.4, old stale cookie. Silently     * :X M 0 0:      * discard the cookie, we ret NULL     * which will cause the caller     * to return and null dp.     */    SCTPdebugPrint(m,"X M 0 0 case\n");    return(NULL);  }  if((cookieP->initAckISent.initTag == existing->curTag) &&     ((peersInit->initm.initTag != existing->hisTag) ||      (peersInit->initm.initTag == 0))     ){    /* case B of 5.2.4, This is a duplicate INIT case     * where I got a cookie sent to him and he will     * discard it since his init collided and had     * him pick a new Tag. My tag is ok, and so     * should all my info, his stuff may have     * changed from the INIT-ACK I got so I must     * re-accept this.     * This is :M X A A: or  :M 0 A A:     */    /* I am a bit parnoid so I will do the following, event     * though they should be the same :)     */    SCTPdebugPrint(m,"M X A A case\n");    existing->relReqSeqOut = existing->initSeqNumber = existing->sendingSeq = cookieP->initAckISent.initialTSN;    existing->t3timeoutHighestMarked = existing->relReqSeqOut;    existing->lastCWR_TSN = existing->initSeqNumber - 1;    existing->relReqSeqIn = existing->lastAckedSeq = existing->initSeqNumber - 1;    existing->myRwnd = cookieP->initAckISent.rcvWindowCredit;    existing->preOpenStreams = cookieP->initAckISent.NumPreopenStreams;    SCTPdebugPrint(m,"Now RE-adopting the INIT instead of the INIT-ACK\n");    ret = SCTPadoptThisInit(m,from,existing,peersInit);    if(ret < 0){      SCTPdebugPrint(m,"We have a problem %d -- either deadflag or unresovlable name\n");      if(ret == -1){	/* Any operational error will be picked up by the 	 * abort code and sent along with the NO_RESOURCE 	 * indication.	 */	SCTPsendAAbort(m,existing,		       from,existing->hisTag,		       SCTP_OP_ERROR_NO_RESOURCE,0);      }else{	/* Here is the other case, where we discard the packet (per	 * the upper bit of the parameter) so we do not send	 * back a cookie ack, and we instead send a op error.	 * This should have been caught at the INIT-ACK send though.	 */	if(existing->opErr != NULL){	  SCTPsendOpErr(m,from,existing->opErr,existing->opErrSiz,peersInit->initm.initTag);	}      }      SCTPreportAllOutboundLost(m,existing);      SCTPupperLayerNotification(m,existing,SCTP_NOTIFY_ASSOC_DOWN,				 (int)from);      SCTPfreeAssociation(m,existing);      return(NULL);    }    if(((existing->state&SCTP_STATE_MASK) == SCTP_STATE_COOKIE_WAIT) ||       ((existing->state&SCTP_STATE_MASK) == SCTP_STATE_COOKIE_SENT)       ){      oldstate = existing->state & SCTP_STATE_SHUTDOWN_PEND;      existing->state = (SCTP_STATE_OPEN | oldstate);	      SCTPdebugPrint(m,"STATE SET TO OPEN ORed with %d\n",oldstate);      timerWork(m,existing,SCTP_TIMER_STOP,SctpTimerTypeInit,0);      timerWork(m,existing,SCTP_TIMER_STOP,SctpTimerTypeCookie,0);      timerWork(m,existing,SCTP_TIMER_STOP,SctpTimerTypeHeartbeat,0);      timerWork(m,existing,SCTP_TIMER_STOP,SctpTimerTypePathMtuRaise,0);      timerWork(m,existing,SCTP_TIMER_START,SctpTimerTypeHeartbeat,0);      /* bring up the PMTU raise timer */      timerWork(m,existing,SCTP_TIMER_START,SctpTimerTypePathMtuRaise,0);    }    SCTPupperLayerNotification(m,existing,			       SCTP_NOTIFY_ASSOC_UP,existing->numnets);    SCTPsendCookieAck(m,existing,from);    return(existing);  }    if(((cookieP->initAckISent.initTag != existing->curTag) &&      (peersInit->initm.initTag != existing->hisTag)) &&     (cookieP->TieTag_curTag == existing->curTag) &&		/* My tag matches to the Tie-Tag */     (cookieP->TieTag_curTag != 0) &&				/* My tag is set.. this SHOULD be true */     (cookieP->TieTag_hisTag == existing->hisTag) &&		/* His tag matches the tie tag */     (cookieP->TieTag_hisTag != 0)				/* This must be checked to make sure we								 * did have a tie-tag set for the peer								 */     ){    /* Restart case */    /*     * report the assocation up to the upper layer     */     /* now we need to clean up any stray associations that may be     * associated with the new INIT that were broken out as seperate     * associations in the old un-restarted host.     */    timerWork(m,existing,SCTP_TIMER_STOP,SctpTimerTypeInit,0);    timerWork(m,existing,SCTP_TIMER_STOP,SctpTimerTypeCookie,0);    timerWork(m,existing,SCTP_TIMER_STOP,SctpTimerTypeHeartbeat,0);    timerWork(m,existing,SCTP_TIMER_STOP,SctpTimerTypePathMtuRaise,0);    for(i=0;i<existing->numnets;i++){      timerWork(m,existing,SCTP_TIMER_STOP,SctpTimerTypeSend,i);    }    SCTPreportAllOutboundLost(m,existing);    SCTPupperLayerNotification(m,existing,SCTP_NOTIFY_ASSOC_RESTART,existing->numnets);    /* setup the local parameters to the new values from the initAck I sent */    existing->initSeqNumber = existing->sendingSeq = cookieP->initAckISent.initialTSN;    existing->t3timeoutHighestMarked = existing->relReqSeqOut;    existing->lastCWR_TSN = existing->initSeqNumber - 1;    existing->lastAckedSeq = existing->initSeqNumber - 1;    existing->myRwnd = cookieP->initAckISent.rcvWindowCredit;    existing->preOpenStreams = cookieP->initAckISent.NumPreopenStreams;    existing->curTag = cookieP->initAckISent.initTag;    /* Here we set the INITIAL values in the stream 0      * outbound sequence counter. The adoptThisInit will     * preserve this value since it is a common module and     * the sending of a INIT fired by the UDP model will     * cause this value to increment so the underlying adoptThisInit     * module preserves the outbound stream sequence for stream 0, in     * a restart case we don't want this behavior so we set the SSN to     * 0 so that it will be set to the proper value.     */    existing->outbound.nextSequenceSent = 0;    existing->outbound.reliable = SCTP_STRM_RELIABLE;    existing->inbound.lastSequenceDelivered = 0xffff;    existing->inbound.reliable = SCTP_STRM_RELIABLE;    if(existing->inbound.inqueue != NULL){      SCTPdebugPrint(m,"Memory leak ?? report outbound did not clean up??\n");      existing->inbound.inqueue = NULL;    }    SCTPdebugPrint(m,"***OLD INIT tag of peer to %x\n",existing->hisTag);    /* now adopt the parameters */    ret = SCTPadoptThisInit(m,from,existing,peersInit);    SCTPdebugPrint(m,"***AFTER ADOPT INIT tag of peer to %x\n",existing->hisTag);    timerWork(m,existing,SCTP_TIMER_START,SctpTimerTypeHeartbeat,0);    /* bring up the PMTU raise timer */    timerWork(m,existing,SCTP_TIMER_START,SctpTimerTypePathMtuRaise,0);    SCTPsendCookieAck(m,existing,from);    return(existing);  }  /* all other cases we silently discard the cookie */  return(NULL);}struct SCTP_association *SCTPunpackCookie(struct SCTP *m,char *cookie,int len,		 struct sockaddr *from,		 struct SCTP_association *existing,		 struct sctpHeader *dg,		 struct sockaddr *toAddr){  /* here we must unpack a cookie if it matches */  unsigned long tt;  struct sctpV4IpAddress *s4;  struct sctpV6IpAddress *s6;  int idx;  struct SCTP_association *asoc,*texist,*tret;  struct timespec timeE;  unsigned char digestBuf[SCTP_SIGNATURE_SIZE];  int noGood,i;  u_int addrSz,*paddrl;  int mismatch,fnd,cntChecked;  int addr_cnt;  struct cookieMessage *cookieP;  struct sctpUnifiedInit *peersInit;  /* here we check the size of the cookie, if it is   * NOT what we expect, don't even process it since   * it is a waste of our CPU and may be a real   * stupid attacker   */  asoc = NULL;  if(len < sizeof(struct cookieMessage)){    SCTPdebugPrint(m,"Intruder alert -- deck 5 level 1\n");    return(NULL);  }  /* which cookie should I use, the current one or the previous one? */  cookieP = (struct cookieMessage *)cookie;  if((cookieP->timeEnteringState.tv_sec < m->timeOfSecretChange) &&     (m->currentSecretNumber != m->lastSecretNumber)){    /* previous one */    sctpMd5Digest(m,		  (char *)m->secretKey[m->lastSecretNumber],		  SCTP_SECRET_SIZE,		  cookie,		  (len - SCTP_SIGNATURE_SIZE),		  digestBuf);  }else{    /* current one */    /* we also hit here if there is only one secret defined so     * far i.e. m->currentSecretNumber == m->lastSecretNumber     */    sctpMd5Digest(m,		  (char *)m->secretKey[m->currentSecretNumber],		  SCTP_SECRET_SIZE,		  cookie,		  (len - SCTP_SIGNATURE_SIZE),		  digestBuf);  }  /* Compare */  if(memcmp(digestBuf,&cookie[(len-SCTP_SIGNATURE_SIZE)],SCTP_SIGNATURE_SIZE)){    /* a imposter */    noGood = 1;    /* if the times are equal then we check the old too */    if((((struct SCTP_association *)cookie)->timeEnteringState.tv_sec == m->timeOfSecretChange) &&       (m->currentSecretNumber != m->lastSecretNumber)){      /* could have happened at the roll, try old too ? */      sctpMd5Digest(m,		    (char *)m->secretKey[m->lastSecretNumber],		    SCTP_SECRET_SIZE,		    cookie,		    (len - SCTP_SIGNATURE_SIZE),		    digestBuf);      if(memcmp(digestBuf,&cookie[(len-SCTP_SIGNATURE_SIZE)],SCTP_SIGNATURE_SIZE) == 0){	noGood = 0;      }    }  }else{    noGood = 0;  }  if(noGood){    SCTPdebugPrint(m,"Intruder alert -- deck 5 level 2\n");    return(NULL);  }  paddrl = (u_int *)((u_long)cookieP + sizeof(struct cookieMessage));  addrSz = *paddrl;  SCTPdebugPrint(m,"There is %d sets off address pairs buried in the cookie\n",		 addrSz);  paddrl++;  peersInit = (struct sctpUnifiedInit *)((u_long)paddrl + addrSz);  SCTPdebugPrint(m,"Peers INIT at %x (cookie at %x)\n",(u_int)peersInit,(u_int)cookieP);  /* check for stale cookie, we only do so   * in seconds granularity.   */  if(cookieP->addrtype == SCTP_IPV4_PARAM_TYPE){    /* look up the association via the marked address */    struct sockaddr_in sin,*frm;    memset(&sin,0,sizeof(sin));    frm = (struct sockaddr_in *)from;    sin.sin_family = AF_INET;    sin.sin_port = frm->sin_port;    sin.sin_addr.s_addr = cookieP->addressWhereISent[0];#ifdef USES_BSD_4_4_SOCKET    sin.sin_len = sizeof(struct sockaddr_in);#endif    texist = SCTPfindAssociation(m,(struct sockaddr *)&sin,&idx);    if(texist != NULL){      if(existing != texist){	/* this is the strange split/join case of a restart 	 * use the association that we recognized first.	 */	existing = texist;      }    }  }else if(cookieP->addrtype == SCTP_IPV6_PARAM_TYPE){    struct sockaddr_in6 si6,*frm6;    memset(&si6,0,sizeof(si6));    frm6 = (struct sockaddr_in6 *)from;    si6.sin6_family = AF_INET6;    si6.sin6_port = frm6->sin6_port;    memcpy(&si6.sin6_addr,(char *)cookieP->addressWhereISent,sizeof(struct in6_addr));#ifdef USES_BSD_4_4_SOCKET    si6.sin6_len = sizeof(struct sockaddr_in6);#endif    texist = SCTPfindAssociation(m,(struct sockaddr *)&sin,&idx);    if(texist != NULL){      if(existing != texist){	/* this is the strange split/join case of a restart 	 * use the association that we recognized first.	 */	existing = texist;      }    }  }  tt = cookieP->timeEnteringState.tv_sec;   tt += cookieP->cookieLife;  (*m->getTime)(&timeE);  if(timeE.tv_sec == tt){    SCTPdebugPrint(m,"Milli sec comparison is %d vs %d\n",		   timeE.tv_nsec,cookieP->timeEnteringState.tv_nsec);  }else{    SCTPdebugPrint(m,"Checking time of cookie:%d + life:%d against now:%d\n",		   cookieP->timeEnteringState.tv_sec,		   cookieP->cookieLife,		   timeE.tv_sec);  }  if((timeE.tv_sec > tt) ||      ((timeE.tv_sec == tt) &&       (timeE.tv_nsec > cookieP->timeEnteringState.tv_nsec))     ){    /* we got a stale cookie */    if(existing == NULL){      int staleby;      SCTPdebugPrint(m,"Sending stale cookie! time:%d > cookieTime:%d (%d + %d)\n",		     timeE.tv_sec,tt,cookieP->timeEnteringState.tv_sec,cookieP->cookieLife);        staleby = (timeE.tv_sec - tt) * 1000000;      if(staleby <= 0){	staleby = 1000000;      }      SCTPsendStaleCookie(m,peersInit->initm.initTag,from,staleby);      return(NULL);    }    /* The else to this is handled below since if the existing is true     * we go through other checks, and we won't do the stale cookie thing.     */  }  if(existing == NULL){    tret = SCTPplainCookie(m,cookie,len,from,existing,dg,cookieP,peersInit);  }else{    tret = SCTPcomplexCookie(m,cookie,len,from,existing,dg,cookieP,peersInit,			     toAddr);  }  if(tret == NULL){    return(NULL);  }  /* Ok now that all is done, adjust my address lists to the one sent in the   * init-ack. This should be the same but has a defensive measure we now carry   * it in the COOKIE :)   */  mismatch = 0;  SCTPdebugPrint(m,"Will now check on address consistency with what I sent out\n");  SCTPdebugPrint(m,"Asoc count:%d master count:%d\n",      tret->numberOfNets,      m->numberOfNets);  cntChecked = 0;  for(i=0;i<m->numberOfNets;i++){    struct sockaddr_in6 *a6;    if(m->localNets[i]->sa_family == AF_INET6){      /* see if we need to skip this */      a6 = (struct sockaddr_in6 *)m->localNets[i];      if(IN6_IS_ADDR_LINKLOCAL(&a6->sin6_addr)){	continue;      }else if((cookieP->siteScope == 0) && IN6_IS_ADDR_SITELOCAL(&a6->sin6_addr)){	continue;      }    }else{      struct sockaddr_in *a;      a = (struct sockaddr_in *)m->localNets[i];      if((cookieP->ipv4Scope == 0) && (IN4_ISPRIVATE_ADDRESS(&a->sin_addr))){	continue;      }    }    fnd = 0;    cntChecked++;    SCTPdebugPrint(m,"Looking for m sub address %d paddr:%x addrsz:%d\n",i,		   (u_int)paddrl,addrSz);    for(s4 = (struct sctpV4IpAddress *)paddrl;	((caddr_t)s4)<((caddr_t)paddrl + addrSz);	(s4 = (struct sctpV4IpAddress *)((caddr_t)s4 + s4->p.paramLength))){      if((s4->p.paramType == SCTP_IPV4_PARAM_TYPE)  &&	 (m->localNets[i]->sa_family == AF_INET)){	if(s4->ipAddress == ((struct sockaddr_in *)m->localNets[i])->sin_addr.s_addr){	  SCTPdebugPrint(m,"Found IPV4\n");	  fnd = 1;	  break;	}      }else if((s4->p.paramType == SCTP_IPV6_PARAM_TYPE)&&	       (m->localNets[i]->sa_family == AF_INET6)){	s6 = (struct sctpV6IpAddress *)s4;	SCTPdebugPrint(m,"compare IPV6 addresses\n");	if(memcmp(s6->ipAddress,		  (char *)&((struct sockaddr_in6 *)m->localNets[i])->sin6_addr,		  sizeof(struct in6_addr)) == 0){	  SCTPdebugPrint(m,"Found\n");	  fnd = 1;	  break;	}      }else{	SCTPdebugPrint(m,"Software error type is %d in my address list in cookie?\n",		       s4->p.paramType);      }      SCTPdebugPrint(m,"Will now advance %d\n",s4->p.paramLength);      SCTPdebugPrint(m,"New size s4 will be %x\n",((caddr_t)(s4 + s4->p.paramLength)));      SCTPdebugPrint(m,"Limit is %x\n",((caddr_t)((caddr_t)paddrl + addrSz)));    }    if(!fnd){      SCTPdebugPrint(m,"Mis-Match declared\n");      mismatch++;    }  }  /* We always count the toAddr address as one. */  addr_cnt = 0;  for(s4 = (struct sctpV4IpAddress *)paddrl;      ((caddr_t)s4)<((caddr_t)paddrl + addrSz);      (s4 = (struct sctpV4IpAddress *)((caddr_t)s4 + s4->p.paramLength))){	  if(s4->p.paramType == SCTP_IPV6_PARAM_TYPE){		  struct sockaddr_in6 a6;		  s6 = (struct sctpV6IpAddress *)s4;		  memcpy(&a6.sin6_addr,s6->ipAddress,sizeof(struct in6_addr));		  if(IN6_IS_ADDR_LINKLOCAL(&a6.sin6_addr)){			  continue;		  }	  }    addr_cnt++;  }  SCTPdebugPrint(m,"I see %d addresses, checked %d - mismatch\n",		   addr_cnt,cntChecked);  if(addr_cnt != cntChecked){    mismatch++;  }  if(mismatch){    /* free up the old */    for(i=0;i<tret->numberOfNets;i++){      if(tret->localNets[i] != NULL){	w_free(m,tret->localNets[i]);      }      tret->localNets[i] = NULL;    }    if(tret->numberOfNetsAlloced < addr_cnt){      SCTPdebugPrint(m,"Expands beyond what I have\n");      w_free(m,(char *)tret->localNets);      tret->localNets = w_calloc(m,m->numberOfNets,sizeof(struct sockaddr *));      tret->numberOfNetsAlloced = m->numberOfNets;      for(i=0;i<m->numberOfNets;i++){	tret->localNets[i] = NULL;      }      w_free(m,(char *)tret->maskList);      w_free(m,tret->addrStats);      tret->maskList = w_calloc(m,addr_cnt,sizeof(struct sockaddr_in));      tret->addrStats = w_calloc(m,addr_cnt,sizeof(char));    }    SCTPdebugPrint(m,"New count is %d\n",addr_cnt);    tret->numberOfNets = addr_cnt;    s4 = (struct sctpV4IpAddress *)paddrl;    for(i=0;i<tret->numberOfNets;i++){      tret->addrStats[i] = SCTP_ADDR_REACHABLE;      if(s4->p.paramType == SCTP_IPV4_PARAM_TYPE){	struct sockaddr_in *ain;	tret->localNets[i] = w_calloc(m,1,sizeof(struct sockaddr_in));	/* we copy all V4 addresses */	SCTPdebugPrint(m,"Setting in IPV4 address\n");	ain = (struct sockaddr_in *)tret->localNets[i];	memset((char *)ain,0,sizeof(struct sockaddr_in));	ain->sin_family = AF_INET;	ain->sin_port = m->port;	ain->sin_addr.s_addr = s4->ipAddress;#ifdef USES_BSD_4_4_SOCKET	ain->sin_len = sizeof(struct sockaddr_in);#endif      }else if(s4->p.paramType == SCTP_IPV6_PARAM_TYPE){	struct sockaddr_in6 *ain6;	s6 = (struct sctpV6IpAddress *)s4;	tret->localNets[i] = w_calloc(m,1,sizeof(struct sockaddr_in6));	ain6 = (struct sockaddr_in6 *)tret->localNets[i];	memset((char *)ain6,0,sizeof(struct sockaddr_in6));	ain6->sin6_family = AF_INET6;	ain6->sin6_port = m->port;	memcpy(&ain6->sin6_addr,s6->ipAddress,sizeof(struct in6_addr));#ifdef USES_BSD_4_4_SOCKET	ain6->sin6_len = sizeof(struct sockaddr_in6);#endif	SCTPdebugPrint(m,"Setting in IPV6 address\n");	SCTPdebugPrintArry(m,(char *)ain6,sizeof(struct sockaddr_in6));      }      /* advance forward */      s4 = (struct sctpV4IpAddress *)((caddr_t)s4 + s4->p.paramLength);    }    tret->listConsistent = 0;  }  return(tret);}voidSCTPdisplayCongestionStats(struct SCTP *m,			   struct SCTP_association *asoc,			   char *msg){  int i;  SCTPdebugPrint(m,"********************************\n");  SCTPdebugPrint(m,"%s SCTP congestion stats are (min mtu:%d):\n",msg,		 asoc->smallestMTU);  SCTPdebugPrint(m,"********************************\n");  for(i=0;i<asoc->numnets;i++){    SCTPdebugPrint(m,		   "net:%d cwnd:%d flight:%d pba:%d ssthresh:%d rtoPend:%d MTU:%d err:%d\n",		   i,		   asoc->nets[i].cwnd,		   asoc->nets[i].flightSize,		   asoc->nets[i].partial_bytes_acked,		   asoc->nets[i].ssthresh,		   asoc->nets[i].rtoPending,		   asoc->nets[i].MTU,		   asoc->nets[i].errorCount		   ); }  SCTPdebugPrint(m,"Peers RWND:%d\n",asoc->peersRwnd);  SCTPdebugPrint(m,"********************************\n");}intSCTPisThereAGap(struct SCTP *m,		struct SCTP_association *asoc){  /* tell me if there is a gap. */  if(asoc->highestTSNinside == asoc->mappingArrayHighestTSN)    return(0);  if(compare_with_wrap(asoc->highestTSNinside,asoc->mappingArrayHighestTSN,MAX_TSN)){    return(1);  }  return(0);}intSCTPwhichLanSentTo(struct SCTP *m,		   struct SCTP_association *asoc,		   unsigned long TSN){  /* find the TSN number and return what destination it was    * last sent to   */  struct SCTP_transmitOnQueue *tmit;  tmit = asoc->outqueue;  while(tmit != NULL){    if(tmit->TSN_seq == TSN){      return(tmit->whichNet);    }    tmit = tmit->next;  }  /* hmm can't find, return 0 */  return(0);} u_longfindLastSentTSN(struct SCTP *m,		struct SCTP_association *asoc){  /* find the TSN number that is the highest one   * that we have sent out. This we keep has a   * mark as to when the last dg was sent   * before we reduced the congestion window.   */  u_long retVal;  struct SCTP_transmitOnQueue *tmit;  if(asoc->outqueue == NULL){    /* none on the list so it must be the     * last one assigned, This should not     * happen, in theory :-).     */    return((asoc->sendingSeq-1));  }  tmit = asoc->outqueue;  retVal = tmit->TSN_seq - 1;  while(tmit != NULL){    if(tmit->sent == SCTP_DATAGRAM_UNSENT){      /* here is one that has not been transmitted */      break;    }    retVal = tmit->TSN_seq;    tmit = tmit->next;  }  /* hmm can't find, return 0 */  return(retVal);} intSCTPisToAddressInAssociation(struct SCTP *m,			     struct SCTP_association *asoc,			     struct sockaddr *to,			     int *adrIndx,			     int fromadddel){  struct sockaddr_in *in,*min;  struct sockaddr_in6 *in6,*min6;  int i;  in = NULL;  in6 = NULL;  if(adrIndx != NULL)    *adrIndx = 0;  /*    * See if an address sent to is part of the association.   */  if(to->sa_family == AF_INET){    SCTPdebugPrint(m,"Checking a IPv4 address against %d addresses\n",		   asoc->numberOfNets);    in = (struct sockaddr_in *)to;  }else if(to->sa_family == AF_INET6){    SCTPdebugPrint(m,"Checking a IPv6 address against %d addresses\n",		   asoc->numberOfNets);    in6 = (struct sockaddr_in6 *)to;  }else{    SCTPdebugPrint(m,"Huh, never heard of type %d\n",to->sa_family);    return(0);  }  for(i=0;i<asoc->numberOfNets;i++){    if(to->sa_family != asoc->localNets[i]->sa_family){      continue;    }    if(to->sa_family == AF_INET){      SCTPdebugPrint(m,"Checking V4 addresses at %d\n",i);      min = (struct sockaddr_in *)asoc->localNets[i];      if(in->sin_addr.s_addr == min->sin_addr.s_addr){	if(adrIndx != NULL)	  *adrIndx = i;	return(1);      }    }else{      SCTPdebugPrint(m,"Checking V6 addresses at %d\n",i);      min6 = (struct sockaddr_in6 *)asoc->localNets[i];      SCTPdebugPrint(m,"Call compare addresses on:\n");      SCTPdebugPrintArry(m,(char *)&in6->sin6_addr,			 sizeof(min6->sin6_addr));      SCTPdebugPrint(m,"To:\n");      SCTPdebugPrintArry(m,(char *)&min6->sin6_addr,			 sizeof(min6->sin6_addr));      if(IN6_ARE_ADDR_EQUAL(&in6->sin6_addr, &min6->sin6_addr)){	if(adrIndx != NULL)	  *adrIndx = i;	return(1);      }    }  }  /* if its from the add/delete go no further */  if(fromadddel){    SCTPdebugPrint(m,"fromadddel return\n");    return(0);  }  /* Here we must be careful, if the asoc->listConsistent and we   * have a pending ADCONF out, we may need to assess this   * packet as valid.   */  {    /* look out on the add/del queue to see if     * an add exists for this guy     */    struct sctpParamDesc *param;    HashedTbl_rewind(asoc->pendingChunks);    SCTPdebugPrint(m,"Check add queue\n");    while((param = (struct sctpParamDesc *)HashedTbl_searchNext(asoc->pendingChunks,								NULL,NULL)) != NULL){      if(ntohs(param->paramType) == SCTP_ADD_IP_ADDRESS){	short ptype;	/* its an add, is it ours ? */	/* move up to the actual address param */	SCTPdebugPrint(m,"Heres one\n");	param++;	ptype = ntohs(param->paramType);	if((to->sa_family == AF_INET) && 	   (ptype == SCTP_IPV4_PARAM_TYPE)){	  struct sctpV4IpAddress *v4;	  /* Could be lets check */	  v4 = (struct sctpV4IpAddress *)param;	  if(v4->ipAddress == 	     ((struct sockaddr_in *)to)->sin_addr.s_addr){	    /* yes */	    SCTPdebugPrint(m,"Yep one being added\n");	    return(1);	  }	}else if((to->sa_family == AF_INET6) && 	   (ptype == SCTP_IPV6_PARAM_TYPE)){	  struct sctpV6IpAddress *v6;	  /* could be lets check */	  v6 = (struct sctpV6IpAddress *)param;	  if(memcmp(v6->ipAddress,		    (char *)&((struct sockaddr_in6 *)m->localNets[i])->sin6_addr,		    sizeof(struct in6_addr)) == 0){	    /* yes */	    SCTPdebugPrint(m,"Yep one being added v6\n");	    return(1);	  }	}      }    }    return(0);  }  SCTPdebugPrint(m,"No match, fall through\n");  return(0);}intSCTPisToAddressInEndpoint(struct SCTP *m,			  struct sockaddr *to,			  int *adrIndx){  struct sockaddr_in *in,*min;  struct sockaddr_in6 *in6,*min6;  int i;  in = NULL;  in6 = NULL;  *adrIndx = 0;  /*    * See if an address sent to is part of the association.   */  if(to->sa_family == AF_INET){    in = (struct sockaddr_in *)to;  }else if(to->sa_family == AF_INET6){    in6 = (struct sockaddr_in6 *)to;  }else{    return(0);  }  for(i=0;i<m->numberOfNets;i++){    if(to->sa_family != m->localNets[i]->sa_family){      continue;    }    if(to->sa_family == AF_INET){      min = (struct sockaddr_in *)m->localNets[i];      if(in->sin_addr.s_addr == min->sin_addr.s_addr){	if(adrIndx != NULL)	  *adrIndx = i;	return(1);      }    }else{      min6 = (struct sockaddr_in6 *)m->localNets[i];      if(IN6_ARE_ADDR_EQUAL(&in6->sin6_addr, &min6->sin6_addr)){	if(adrIndx != NULL)	  *adrIndx = i;	return(1);      }    }  }  return(0);}