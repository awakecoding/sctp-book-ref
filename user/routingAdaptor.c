/* SCTP reference Implementation Copyright (C) 2001 CiscoThis file is part of the SCTP reference ImplementationVersion:4.0.5$Header: /home/sourceTree/src/sctp/user/routingAdaptor.c,v 1.20 2001/07/24 11:52:39 randall Exp $The SCTP reference implementation  is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published bythe Free Software Foundation; either version 2, or (at your option)any later version.the SCTP reference implementation  is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of                ************************MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See theGNU Library General Public License for more details.You should have received a copy of the GNU Library General Public Licensealong with GNU CC; see the file COPYING.  If not, write tothe Free Software Foundation, 59 Temple Place - Suite 330,Boston, MA 02111-1307, USA.  Please send any bug reports or fixes you make to one of the following emailaddresses:rrs@cisco.comkmorneau@cisco.comAny bugs reported given to us we will try to fix... any fixes shared willbe incorperated into the next SCTP release.There are still LOTS of bugs in this code... I always run on the motto"it is a wonder any code ever works :)"*/#include "routingAdaptor.h"#ifdef FREEBSDvoidroutingAStartTimer(struct routingAdaptor *r,int indx,int typ){  if(r->timers[indx].up != RoutingTimer_RUNNING){    dist_TimerStart(r->dist,		    routingAdaptorTimer,		    0,		/* 0   seconds */		    100000,	/* 100 millseconds */		    (void *)r,		    (void *)&r->timers[indx]);    r->timers[indx].up = RoutingTimer_RUNNING;    r->timers[indx].type = typ;  }}void RouteBreakOutAddr(struct sockaddr *start,int addrs, struct sockaddr **sa){  int i;  struct sockaddr *at;  at = start;  for(i=0;i<RTAX_MAX;i++){    if(addrs & (1 << i)){      sa[i] = at;      if(at->sa_len){	/* add sa_len rounded to the next 4 byte boundary */	at = (struct sockaddr *)((caddr_t)at + (((at->sa_len + 3) >> 2) << 2));      }else{	/* we always advance a long if nothing else */	at = (struct sockaddr *)((caddr_t)at + sizeof(long));      }    }else{      sa[i] = NULL;   }  }}static char *routeSockNames[] = {  "RTAX_DST",  "RTAX_GATEWAY",  "RTAX_NETMASK",  "RTAX_GENMASK",  "RTAX_IFP",  "RTAX_IFA",  "RTAX_AUTHOR",  "RTAX_BRD",  "RTAX_MAX",  "RTAX_HUH"};#include <sctputil.h>voidRoutePrintAnAddress(struct sockaddr *a){  if((a->sa_family == AF_INET) ||     (a->sa_family == AF_INET6) ||     (a->sa_family == AF_LINK)){    SCTPPrintAnAddress(a);  }else{    printf("Unsupported address type %d\n",a->sa_family);  }}introutingIsTypeIWant(struct sockaddr_dl *sin_dl){  int answer;  switch(sin_dl->sdl_type){  case IFT_ETHER:  case IFT_ISO88025:  case IFT_STARLAN:  case IFT_P10:  case IFT_P80:  case IFT_HY:  case IFT_FDDI:  case IFT_XETHER:  case IFT_ATM:  case IFT_SONET:  case IFT_FRELAYDCE:  case IFT_AAL5:  case IFT_SONETPATH:  case IFT_SONETVT:  case IFT_GIF:  case IFT_LOOP:	/* for now we accept the loop back */    answer = 1;    break;  default:    answer = 0;    break;  };  return(answer);}struct Route_ifname *routingFindifname(struct routingAdaptor *r,		  char *name){  /* find the name in the list */  struct Route_ifname *ret;  dlist_reset(r->iflist);  while((ret = (struct Route_ifname *)dlist_get(r->iflist)) != NULL){    if(strcmp(ret->if_name,name) == 0){      return(ret);    }  }  return(ret);}struct Route_ifname *routingFindindex(struct routingAdaptor *r,		 int indx){  /* find the name in the list */  struct Route_ifname *ret;  dlist_reset(r->iflist);  while((ret = (struct Route_ifname *)dlist_get(r->iflist)) != NULL){    if(ret->index == indx){      return(ret);    }  }  return(ret);}struct Route_ifname *routeAddARoute(struct routingAdaptor *r,	       int rtm_index,	       struct sockaddr *dst,	       struct sockaddr *gate,	       struct sockaddr *netmask){  struct Route_ifname *ifp;  struct routeEntry *re;  ifp = routingFindindex(r,rtm_index);  if(ifp == NULL){    /* we don't track this intf probably */    return(NULL);  }  re = calloc(1,sizeof(struct routeEntry));  if(re == NULL)    /* no memory */    return(ifp);  re->dst = calloc(1,dst->sa_len);  if(re->dst == NULL){    free(re);    return(ifp);  }  re->gate = calloc(1,gate->sa_len);  if(re->gate == NULL){    free(re->dst);    free(re);    return(ifp);  }  re->netmask = NULL;  if((netmask != NULL) &&     (netmask->sa_len)){    re->netmask = calloc(1,netmask->sa_len);    if(re->netmask == NULL){      free(re->dst);      free(re->gate);      free(re);      return(ifp);    }else{      memcpy(re->netmask,netmask,netmask->sa_len);    }  }  memcpy(re->gate,gate,gate->sa_len);  memcpy(re->dst,dst,dst->sa_len);  re->ifp = ifp;  /* now that we have built the route install it */  if(dlist_append(re->ifp->routes,(void *)re) != LIB_STATUS_GOOD){    if(re->netmask != NULL){      free(re->netmask);    }    free(re->dst);    free(re->gate);    free(re);  }  return(ifp);}struct Route_ifname *routeDelARoute(struct routingAdaptor *r,	       struct sockaddr *dst,	       struct sockaddr *gate,	       int rtm_index){  struct Route_ifname *ifp;  struct routeEntry *re;  int fnd;  fnd = 0;  re = NULL;  ifp = NULL;  if(rtm_index != 0){    /* If things are good, we have an index     * and we will go through this method     * to find the route      */    ifp = routingFindindex(r,rtm_index);    if(ifp == NULL){      /* an interface we are NOT tracking */      return(NULL);    }    dlist_reset(ifp->routes);    /* hunt through all the dst's */    while((re = dlist_get(ifp->routes))  != NULL){      /* is this the one I want? */      if(dst->sa_family != re->dst->sa_family){	/* can't be the same */	continue;      }      if(dst->sa_len != re->dst->sa_len){	/* can't be the same */	continue;      }      if(memcmp(dst,re->dst,dst->sa_len) == 0){	/* we may have a winner */	if(gate == NULL){	  /* consider it done if no gateway is specified */	  fnd = ifp->index;	  break;	}	/* double check the gateway too */	if(gate->sa_len != re->gate->sa_len)	  continue;	if(memcmp(gate,re->gate,gate->sa_len) == 0){	  /* yep same dst and gateway. */	  fnd = ifp->index;	  break;	}      }    }  }  if(fnd){    dlist_getThis(ifp->routes);    if(re->dst != NULL){      free(re->dst);      re->dst = NULL;    }    if(re->gate != NULL){      free(re->gate);      re->gate = NULL;    }    if(re->netmask != NULL){      free(re->netmask);      re->netmask = NULL;    }    free(re);    return(ifp);  }  /* Well if we reach here we are doing it the   * hard way. Hunt through all the interfaces    * looking for our route.   */  dlist_reset(r->iflist);  while((ifp = (struct Route_ifname *)dlist_get(r->iflist)) != NULL){    dlist_reset(ifp->routes);    /* hunt through all the dst's */    while((re = dlist_get(ifp->routes))  != NULL){      /* is this the one I want? */      if(dst->sa_family != re->dst->sa_family){	/* can't be the same */	continue;      }      if(dst->sa_len != re->dst->sa_len){	/* can't be the same */	continue;      }      if(memcmp(dst,re->dst,dst->sa_len) == 0){	/* we may have a winner */	if(gate == NULL){	  /* consider it done if no gateway is specified */	  printf("Break at ifp:%x fnd:%d\n",		 (u_int)ifp,ifp->index);	  fnd = ifp->index;	  break;	}	/* double check the gateway too */	if(gate->sa_len != re->gate->sa_len)	  continue;	if(memcmp(gate,re->gate,gate->sa_len) == 0){	  /* yep same dst and gateway. */	  fnd = ifp->index;	  break;	}      }    }    if(fnd)      break;  }  if(fnd){    dlist_getThis(ifp->routes);    if(re->dst != NULL){      free(re->dst);      re->dst = NULL;    }    if(re->gate != NULL){      free(re->gate);      re->gate = NULL;    }    if(re->netmask != NULL){      free(re->netmask);      re->netmask = NULL;    }    free(re);  }  return(ifp);}voidroutingAddAddresses(struct Route_ifname *ifp,		    struct sockaddr **arry){  struct sockaddr_storage *sad;  if(arry[RTAX_IFA] == NULL){    return;  }  if(arry[RTAX_IFA]->sa_len == 0)    /* don't add zero length addresses */    return;  sad = calloc(1,sizeof(struct sockaddr_storage));  if(sad != NULL){    memcpy(sad,arry[RTAX_IFA],arry[RTAX_IFA]->sa_len);    if(sad->ss_family == AF_INET6){      struct sockaddr_in6 *s6;      /* possibly fix scope */	      s6 = (struct sockaddr_in6 *)sad;      if((IN6_IS_ADDR_LINKLOCAL(&s6->sin6_addr) &&	  *(u_short *)&s6->sin6_addr.s6_addr[2] != 0)){	/* KAME HACK: to pull out embedded link local scope */	u_short index;	index = *(u_short *)&s6->sin6_addr.s6_addr[2];	*(u_short *)&s6->sin6_addr.s6_addr[2] = 0;	if (s6->sin6_scope_id == 0)	  s6->sin6_scope_id = ntohs(index);      }    }    if(dlist_append(ifp->addrList,(void *)sad) != LIB_STATUS_GOOD){      printf("Hmm, can't add\n");      free(sad);    }  }}voidroutingDelAddresses(struct routingAdaptor *r,		    struct Route_ifname *ifp,		    struct sockaddr **ary,		    int *remPrimary){  struct sockaddr *at,*arry;  int rmThisOne;  if(ary[RTAX_IFA] == NULL){    return;  }  *remPrimary = 0;  arry = ary[RTAX_IFA];  dlist_reset(ifp->addrList);  while((at = (struct sockaddr *)dlist_get(ifp->addrList)) != NULL){    rmThisOne = 0;    if(at->sa_family == arry->sa_family){      /* possible candidate */      if(at->sa_family == AF_INET){	struct sockaddr_in *lis,*it;	it = (struct sockaddr_in *)arry;	lis = (struct sockaddr_in *)at;	if(it->sin_addr.s_addr == lis->sin_addr.s_addr){	  rmThisOne = 1;	}      }else if(at->sa_family == AF_INET6){	/* first do a possible fix to the arry ll hack */	struct sockaddr_in6 *lis6,*s6;	s6 = (struct sockaddr_in6 *)arry;	lis6 = (struct sockaddr_in6 *)at;	if((IN6_IS_ADDR_LINKLOCAL(&s6->sin6_addr) &&	    *(u_short *)&s6->sin6_addr.s6_addr[2] != 0)){	  /* KAME HACK: to pull out embedded link local scope */	  u_short index;	  index = *(u_short *)&s6->sin6_addr.s6_addr[2];	  *(u_short *)&s6->sin6_addr.s6_addr[2] = 0;	  if (s6->sin6_scope_id == 0)	    s6->sin6_scope_id = ntohs(index);	}	if(IN6_ARE_ADDR_EQUAL(&s6->sin6_addr,&lis6->sin6_addr)){	  rmThisOne = 1;	}      }else{	if(memcmp(arry,at,at->sa_len) == 0){	  rmThisOne = 1;	}      }      if(rmThisOne){	void *v;	if(at == r->lastKnownPrimary){	  *remPrimary = 1;	}	v = dlist_getThis(ifp->addrList);	if(v != (void *)at){	  printf("Gak, list error - memory leaked\n");	  return;	}	free((char *)at);	return;      }    }  }}intRouteParseAdd(struct routingAdaptor *r,struct ifa_msghdr *ifam){  struct sockaddr *arry[RTAX_MAX],*start;  struct Route_ifname *ifp;  int action;  action = 0;  ifp = routingFindindex(r,ifam->ifam_index);  if(ifp == NULL){    printf("cant find index %d ifp\n",ifam->ifam_index);    return(0);  }  start = (struct sockaddr *)((caddr_t)ifam + sizeof(struct ifa_msghdr));  RouteBreakOutAddr(start,ifam->ifam_addrs,arry);  if(arry[RTAX_IFA] != NULL){    struct sockaddr_dl *dl;    if((arry[RTAX_IFA]->sa_family != AF_INET) &&       (arry[RTAX_IFA]->sa_family != AF_INET6)){      /* we only support IPv4 and IPv6 */      return(action);    }    if(arry[RTAX_IFA]->sa_family == AF_INET){      struct sockaddr_in *sin;      sin = (struct sockaddr_in *)arry[RTAX_IFA];      if(sin->sin_addr.s_addr == 0){	/* Can't add a zero address */	return(action);      }    }    if(arry[RTAX_IFA]->sa_family == AF_INET6){      struct sockaddr_in6 *sin6;      sin6 = (struct sockaddr_in6 *)arry[RTAX_IFA];      if(IN6_IS_ADDR_UNSPECIFIED(&sin6->sin6_addr)){	/* Can't add a zero address */	return(action);      }    }    routingAddAddresses(ifp,arry);    if(arry[RTAX_IFP] != NULL){      dl = (struct sockaddr_dl *)arry[RTAX_IFP];      if(routingIsTypeIWant(dl)){	printf("Calling add address:%d\n",r->flags);	sctpADDIPADDRESS(r->sctp,			 arry[RTAX_IFA],			 (struct sockaddr *)NULL,r->flags);	action = 1;      }    }else{      printf("Calling add address:%d\n",r->flags);      sctpADDIPADDRESS(r->sctp,		       arry[RTAX_IFA],		       (struct sockaddr *)NULL,r->flags);      action = 1;          }  }  return(action);}struct sockaddr *routingSelectPrimaryForAF(struct Route_ifname *ifp,			  struct sockaddr *dst,			  int *loc,			  int *site){  /* given a destination route, select a primary from   * the interface that has the higest scope.    */  struct sockaddr *at,*keeper;  int locScope,siteScope;  int atlocScope,atsiteScope;  keeper = NULL;  locScope = siteScope = 0;  atlocScope = atsiteScope = 0;  dlist_reset(ifp->addrList);;  while((at = (struct sockaddr *)dlist_get(ifp->addrList)) != NULL){    if(at->sa_family != dst->sa_family){      continue;    }    /* ok same family, see if we need to pick it */    /* calculate the at scopes */    if(at->sa_family == AF_INET){      struct sockaddr_in *s;      s = (struct sockaddr_in *)at;      if(IN4_ISPRIVATE_ADDRESS(&s->sin_addr)){	siteScope = 1;	locScope = 0;      }else{	/* we will take the first global scope */	keeper = at;	break;      }    }else if(at->sa_family == AF_INET6){      struct sockaddr_in6 *s6;      s6 = (struct sockaddr_in6 *)at;      if(IN6_IS_ADDR_LINKLOCAL(&s6->sin6_addr)){	atlocScope = 1;	atsiteScope = 0;      }else if(IN6_IS_ADDR_SITELOCAL(&s6->sin6_addr)){	atlocScope = 0;	atsiteScope = 1;      }else{	/* we will take the first global scope */	keeper = at;	break;      }    }    if(keeper == NULL){      /* got to have something. */      keeper = at;      locScope = atlocScope;      siteScope = atsiteScope;    }  }  if(keeper != NULL){    /* Transfer out scope if wanted */    if(loc != NULL){      *loc = locScope;    }    if(site != NULL){      *site = siteScope;    }  }  return(keeper);}voidrouteSelectDiffPrimaryThan(struct routingAdaptor *r,			   struct ifa_msghdr *ifam,			   struct sockaddr *adddeling){  /* The primary is going away, find a new one please of   * the appropriate family, with the highest scope.   */  struct Route_ifname *ifp;  struct sockaddr *potentialPrimary,*newone;  int locScope,siteScope;  int atlocScope,atsiteScope;  locScope = siteScope = 0;  atlocScope = atsiteScope = 0;  dlist_reset(r->iflist);  potentialPrimary = newone = NULL;  while((ifp = (struct Route_ifname *)dlist_get(r->iflist)) != NULL){    /* is this the intf dropping from? */    if(ifp->index == ifam->ifam_index){      /* skip this interface */      continue;    }    newone = routingSelectPrimaryForAF(ifp,adddeling,				       &atlocScope,				       &atsiteScope);    if(newone == NULL)      continue;    if(potentialPrimary == NULL){      potentialPrimary = newone;      locScope = atlocScope;      siteScope = atsiteScope;      if((locScope == 0) && (siteScope == 0)){	/* Can't get better, its global */	break;      }    }    /* is this one better? */    if(locScope && atsiteScope){      /* this one is better */      potentialPrimary = newone;      locScope = atlocScope;      siteScope = atsiteScope;    }else if((atsiteScope == 0) && (atlocScope == 0)){      /* this one is global */      potentialPrimary = newone;      break;    }  }  if(potentialPrimary == NULL){    /* ok this did not work, lets try looking for     * opposite family type     */    if(adddeling->sa_family == AF_INET){      adddeling->sa_family = AF_INET6;    }else if(adddeling->sa_family == AF_INET6){      adddeling->sa_family = AF_INET;    }else{      return;    }    /* now back through to see if we can find someone */    dlist_reset(r->iflist);    while((ifp = (struct Route_ifname *)dlist_get(r->iflist)) != NULL){      /* is this the intf dropping from? */      if(ifp->index == ifam->ifam_index){	/* skip this interface */	continue;      }      newone = routingSelectPrimaryForAF(ifp,adddeling,					 &atlocScope,					 &atsiteScope);      if(newone == NULL)	continue;      if(potentialPrimary == NULL){	potentialPrimary = newone;	locScope = atlocScope;	siteScope = atsiteScope;	if((locScope == 0) && (siteScope == 0)){	  /* Can't get better, its global */	  break;	}      }      /* is this one better? */      if(locScope && atsiteScope){	/* this one is better */	potentialPrimary = newone;	locScope = atlocScope;	siteScope = atsiteScope;      }else if((atsiteScope == 0) && (atlocScope == 0)){	/* this one is global */	potentialPrimary = newone;	break;      }    }  }  if(potentialPrimary == NULL){    printf("No where to run to :< - primary is hosed \n");    return;  }  printf("Now changing primary due to delete to:\n");  RoutePrintAnAddress(potentialPrimary);  sctpREMOTESETPRIMARYALL(r->sctp,			  potentialPrimary,			  SCTP_ACTION_QUEUE_REQUEST_ONLY);   r->lastKnownPrimary = potentialPrimary;}intRouteParseDel(struct routingAdaptor *r,struct ifa_msghdr *ifam){  struct sockaddr *arry[RTAX_MAX],*start;  struct Route_ifname *ifp;  int action,remPrimary;  action = 0;  ifp = routingFindindex(r,ifam->ifam_index);  if(ifp == NULL){    printf("cant find index %d ifp\n",ifam->ifam_index);    return(0);  }  start = (struct sockaddr *)((caddr_t)ifam + sizeof(struct ifa_msghdr));  RouteBreakOutAddr(start,ifam->ifam_addrs,arry);  if(arry[RTAX_IFA] != NULL){    struct sockaddr_dl *dl;        if((arry[RTAX_IFA]->sa_family != AF_INET) &&       (arry[RTAX_IFA]->sa_family != AF_INET6)){      /* we only support IPv4 and IPv6 */      return(action);    }    if(arry[RTAX_IFA]->sa_family == AF_INET){      struct sockaddr_in *sin;      sin = (struct sockaddr_in *)arry[RTAX_IFA];      if(sin->sin_addr.s_addr == 0){	/* Can't del a zero address */	return(action);      }    }    if(arry[RTAX_IFA]->sa_family == AF_INET6){      struct sockaddr_in6 *sin6;      sin6 = (struct sockaddr_in6 *)arry[RTAX_IFA];      if(IN6_IS_ADDR_UNSPECIFIED(&sin6->sin6_addr)){	/* Can't del a zero address */	return(action);      }    }    routingDelAddresses(r,ifp,arry,&remPrimary);    if(arry[RTAX_IFP] != NULL){      dl = (struct sockaddr_dl *)arry[RTAX_IFP];      if(routingIsTypeIWant(dl)){	printf("Calling del address:%d\n",r->flags);	sctpDELIPADDRESS(r->sctp,			 arry[RTAX_IFA],			 (struct sockaddr *)NULL,			 r->flags);	action = 1;	if(remPrimary){	  routeSelectDiffPrimaryThan(r,ifam,arry[RTAX_IFA]);	}      }    }else{      printf("Calling del address:%d\n",r->flags);      sctpDELIPADDRESS(r->sctp,		       arry[RTAX_IFA],		       (struct sockaddr *)NULL,		       r->flags);      action = 1;      if(remPrimary){	if(remPrimary){	  routeSelectDiffPrimaryThan(r,ifam,arry[RTAX_IFA]);	}      }    }  }  return(action);}introutingSetPrimaryIfNeeded(struct routingAdaptor *r,struct rt_msghdr *rtm){  int action;  struct Route_ifname *ifp;  struct sockaddr *arry[RTAX_MAX],*start;  action = 0;  /* user does not want us to look at routing changes */  if(r->flags_passed & ROUTING_DONT_SET_PRIMARY)    return(action);  start = (struct sockaddr *)((caddr_t)rtm + sizeof(struct rt_msghdr));  RouteBreakOutAddr(start,rtm->rtm_addrs,arry);  /* if this route is not in don't set a primary */  if(((rtm->rtm_flags & RTF_DONE) == 0) &&     (rtm->rtm_errno)){    /* if DONE is not set and errno is, then it was     * an error. Sometimes DONE will not be set     * but error will be clear (for automatic routes)     */    return(action);  }  if(rtm->rtm_index == 0){    int i;    printf("Got a rtm type %d w/index 0\n",rtm->rtm_type);    printf("Addresses\n");    for(i=0;i<RTAX_MAX;i++){      if(arry[i] != NULL){	printf("%s - ",routeSockNames[i]);	RoutePrintAnAddress(arry[i]);      }    }      }  if(arry[RTAX_DST] == NULL){    printf("Can't know what to do, no destination?\n");    return(action);  }  if((rtm->rtm_type ==  RTM_ADD) ||     (rtm->rtm_type == RTM_OLDADD)){    /* an add */    ifp = routeAddARoute(r,rtm->rtm_index,			 arry[RTAX_DST],			 arry[RTAX_GATEWAY],			 arry[RTAX_NETMASK]);  }else if((rtm->rtm_type == RTM_CHANGE) ||	   (rtm->rtm_type == RTM_REDIRECT)){    /* A change or redirect is handled has a del/add */    ifp = routeDelARoute(r,arry[RTAX_DST],NULL,			 rtm->rtm_index);    ifp = routeAddARoute(r,rtm->rtm_index,			 arry[RTAX_DST],			 arry[RTAX_GATEWAY],			 arry[RTAX_NETMASK]);  }else if((rtm->rtm_type == RTM_DELETE) ||	   (rtm->rtm_type == RTM_OLDDEL)){    /* a delete */    ifp = routeDelARoute(r,arry[RTAX_DST],arry[RTAX_GATEWAY],			 rtm->rtm_index);    return(0);  }else{    /* not handled here */    return(0);  }  if(ifp == NULL){    printf("Can't locate interface %d\n",rtm->rtm_index);    return(0);  }  if(ifp->if_type == IFT_LOOP){    /* we never allow a loopback to be primary */    return(0);  }  arry[RTAX_IFA] = routingSelectPrimaryForAF(ifp,arry[RTAX_DST],NULL,NULL);  if(arry[RTAX_IFA] == NULL){    printf("Can't find a suitable primary for interface %s fam:%d\n",	   ifp->if_name,	   arry[RTAX_DST]->sa_family);    return(action);  }  /* Check for unspecifed addresses, this should not happen */  if(arry[RTAX_IFA]->sa_family == AF_INET){    struct sockaddr_in *sin;    sin = (struct sockaddr_in *)arry[RTAX_IFA];    if(sin->sin_addr.s_addr == 0){      /* Can't setprimary a zero address */      return(action);    }  }else if(arry[RTAX_IFA]->sa_family == AF_INET6){    struct sockaddr_in6 *sin6;    sin6 = (struct sockaddr_in6 *)arry[RTAX_IFA];    if(IN6_IS_ADDR_UNSPECIFIED(&sin6->sin6_addr)){      /* Can't setprimary a zero address */      return(action);    }  }  if(r->flags_passed & ROUTING_PRIMARY_TRACKS_DEF_RT){    if(rtm->rtm_flags & RTF_GATEWAY){      if(arry[RTAX_DST]->sa_family == AF_INET){	struct sockaddr_in *sin;	sin = (struct sockaddr_in *)arry[RTAX_DST];	if(sin->sin_addr.s_addr == 0){	  printf("Setting the primary address to:\n");	  RoutePrintAnAddress(arry[RTAX_IFA]);	  sctpREMOTESETPRIMARYALL(r->sctp,				  arry[RTAX_IFA],				  SCTP_ACTION_QUEUE_REQUEST_ONLY); 	  r->lastKnownPrimary = arry[RTAX_IFA];	  action = 1;	}      }else if(arry[RTAX_DST]->sa_family == AF_INET6){	struct sockaddr_in6 *sin6;	sin6 = (struct sockaddr_in6 *)arry[RTAX_DST];	if(IN6_IS_ADDR_UNSPECIFIED(&sin6->sin6_addr)){	  printf("Setting the primary address to:\n");	  RoutePrintAnAddress(arry[RTAX_IFA]);	  sctpREMOTESETPRIMARYALL(r->sctp,				  arry[RTAX_IFA],				  SCTP_ACTION_QUEUE_REQUEST_ONLY); 	  r->lastKnownPrimary = arry[RTAX_IFA];	  action = 1;	}      }    }  }else if(r->flags_passed & ROUTING_PRIMARY_TRACKS_HOST_RT){    if(rtm->rtm_flags & RTF_HOST){      printf("Setting the primary address to:\n");      RoutePrintAnAddress(arry[RTAX_IFA]);            sctpREMOTESETPRIMARYALL(r->sctp,			      arry[RTAX_IFA],			      SCTP_ACTION_QUEUE_REQUEST_ONLY);       r->lastKnownPrimary = arry[RTAX_IFA];      action = 1;    }  }  return(action);}char *routingSkipToNext(struct if_msghdr *ifm,char *limit){  struct if_msghdr *ifmt;  char *at;  if(ifm->ifm_msglen > 0)    at = (char *)((caddr_t)ifm + ifm->ifm_msglen);  else{    printf("gak bad pointer passed in\n");    return(NULL);  }  while(at < limit){    ifmt = (struct if_msghdr *)at;    if(ifmt->ifm_type == RTM_IFINFO){      /* found the next INFO */      return(at);    }    if(ifmt->ifm_msglen > 0)      at = (char *)((caddr_t)ifmt + ifmt->ifm_msglen);    else{      printf("gak, out of sync\n");      return(NULL);    }  }  return(NULL);}voidroutingAddAddressesToIf(struct Route_ifname *ifp,			struct ifa_msghdr *ifam){  struct sockaddr *arry[RTAX_MAX],*start;  start = (struct sockaddr *)((caddr_t)ifam+ sizeof(struct ifa_msghdr));  RouteBreakOutAddr(start,ifam->ifam_addrs,arry);  if(arry[RTAX_IFA] != NULL){    if((arry[RTAX_IFA]->sa_family != AF_INET) &&       (arry[RTAX_IFA]->sa_family != AF_INET6)){      /* we only support IPv4 and IPv6 */      return;    }    if(arry[RTAX_IFA]->sa_family == AF_INET){      struct sockaddr_in *sin;      sin = (struct sockaddr_in *)arry[RTAX_IFA];      if(sin->sin_addr.s_addr == 0){	/* Can't add a zero address */	return;      }    }    if(arry[RTAX_IFA]->sa_family == AF_INET6){      struct sockaddr_in6 *sin6;      sin6 = (struct sockaddr_in6 *)arry[RTAX_IFA];      if(IN6_IS_ADDR_UNSPECIFIED(&sin6->sin6_addr)){	/* Can't add a zero address */	return;      }    }    routingAddAddresses(ifp,arry);  }}char *routingDecodeif(dlist_t *addto,		struct if_msghdr *ifm,		struct Route_ifname *ifp,		char *limit){  struct sockaddr *arry[RTAX_MAX],*start;  char *at;  struct ifa_msghdr *ifam;  struct sockaddr_dl *sin_dl;  ifam = NULL;  /* user does not want us to look at routing changes */  start = (struct sockaddr *)((caddr_t)ifm + sizeof(struct if_msghdr));  RouteBreakOutAddr(start,ifm->ifm_addrs,arry);  /* we expect an inteface address */  sin_dl = (struct sockaddr_dl *)arry[RTAX_IFP];  if(sin_dl == NULL){    dlist_destroy(ifp->addrList);    dlist_destroy(ifp->routes);    free(ifp);    return(routingSkipToNext(ifm,limit));  }  if(routingIsTypeIWant(sin_dl) == 0){    dlist_destroy(ifp->addrList);    dlist_destroy(ifp->routes);    free(ifp);    return(routingSkipToNext(ifm,limit));  }  if(dlist_append(addto,(void *)ifp) != LIB_STATUS_GOOD){    dlist_destroy(ifp->addrList);    dlist_destroy(ifp->routes);    free(ifp);    return(routingSkipToNext(ifm,limit));  }  /* now first grab the name into ifp */  memcpy(ifp->if_name,sin_dl->sdl_data,sin_dl->sdl_nlen);  ifp->if_name[sin_dl->sdl_nlen] = 0;  ifp->if_type = sin_dl->sdl_type;  ifp->addrLen = sin_dl->sdl_alen;  if(ifp->addrLen > ROUTING_MAX_LINK_ADDRESS){    printf("Warning, had to truncate a hardware address from %d to max %d\n",	   ifp->addrLen,ROUTING_MAX_LINK_ADDRESS);    ifp->addrLen = ROUTING_MAX_LINK_ADDRESS;  }  memcpy(ifp->linkAddr,LLADDR(sin_dl),ifp->addrLen);  if(ifm->ifm_msglen > 0)    at = (char *)((caddr_t)ifm + ifm->ifm_msglen);  else{    printf("gak bad pointer passed in\n");    return(NULL);  }  while(at < limit){    ifam = (struct ifa_msghdr *)at;    if(ifam->ifam_type == RTM_IFINFO){      /* found the next INFO, we are done */      return(at);    }    if(ifam->ifam_msglen > 0)      at = (char *)((caddr_t)ifam + ifam->ifam_msglen);    else{      printf("gak, out of sync\n");      return(NULL);    }    if(ifam->ifam_type == RTM_NEWADDR){      routingAddAddressesToIf(ifp,ifam);    }  }  return(NULL);}voidroutingPossibleAddNewIFP(struct routingAdaptor *r,			 struct if_msghdr *ifm){  struct sockaddr_dl *sin_dl;  struct sockaddr *arry[RTAX_MAX],*start;  char ifname[(IFNAMSIZ+1)];  struct Route_ifname *ifp;  /* user does not want us to look at routing changes */  start = (struct sockaddr *)((caddr_t)ifm + sizeof(struct if_msghdr));  RouteBreakOutAddr(start,ifm->ifm_addrs,arry);    sin_dl = (struct sockaddr_dl *)arry[RTAX_IFP];    if(sin_dl == NULL){    if(ifm->ifm_index){      /* Interface status change */      return;    }    printf("Gak, new interface but no sock_dl for it index:%d\n",	   ifm->ifm_index);    return;  }  memcpy(ifname,sin_dl->sdl_data,sin_dl->sdl_nlen);  ifname[sin_dl->sdl_nlen] = 0;  if(routingIsTypeIWant(sin_dl) == 0){    /* don't care about this one */    printf("We don't track type %s\n",ifname);    return;  }  ifp = routingFindifname(r,ifname);  if(ifp != NULL){    /* already have this guy */    printf("Already in list ... found\n");    return;  }  /* need to add this guy in */  ifp = (struct Route_ifname *)calloc(1,sizeof(struct Route_ifname));  if(ifp == NULL){    printf("no more memory ifp failed to aloc - incomplete addrlists\n");    return;  }  ifp->addrList = dlist_create();  ifp->routes = dlist_create();  if(ifp->addrList == NULL){    printf("no more memory ifp->addrList - incomplete addrlists\n");    if(ifp->routes != NULL)      dlist_destroy(ifp->routes);    free(ifp);    return;  }  if(ifp->routes == NULL){    printf("no more memory ifp->addrList - incomplete addrlists\n");    dlist_destroy(ifp->addrList);    free(ifp);    return;  }  if(dlist_append(r->iflist,(void *)ifp) != LIB_STATUS_GOOD){    printf("Can't add interface to LL - incomplete addrlists\n");    dlist_destroy(ifp->addrList);    dlist_destroy(ifp->routes);    free(ifp);    return;  }  ifp->index = ifm->ifm_index;  memcpy(ifp->if_name,sin_dl->sdl_data,sin_dl->sdl_nlen);  ifp->if_name[sin_dl->sdl_nlen] = 0;  ifp->if_type = sin_dl->sdl_type;  ifp->addrLen = sin_dl->sdl_alen;  if(ifp->addrLen > ROUTING_MAX_LINK_ADDRESS){    printf("Warning, had to truncate a hardware address from %d to max %d\n",	   ifp->addrLen,ROUTING_MAX_LINK_ADDRESS);    ifp->addrLen = ROUTING_MAX_LINK_ADDRESS;  }  memcpy(ifp->linkAddr,LLADDR(sin_dl),ifp->addrLen);}dlist_t *routingInitialzeNameList(){  int mib[6],needed;  char *buf,*limit,*at;  struct Route_ifname *ifp;  dlist_t *ret;  struct if_msghdr *ifm;  /* setup for sys control */  mib[0] = CTL_NET;  mib[1] = PF_ROUTE;  mib[2] = 0;  mib[3] = 0;	/* address family */  mib[4] = NET_RT_IFLIST;  mib[5] = 0;  /* Find out space needed */  needed = 0;  if(sysctl(mib,6,NULL,&needed,NULL,0) < 0){    printf("Gak, failed to get list\n");    return(NULL);  }  buf = calloc(1,needed);  if(sysctl(mib,6,buf,&needed,NULL,0) < 0){    printf("Gak, failed to get list\n");    return(NULL);  }  limit = (char *)((caddr_t)buf + needed);  at = buf;  ret = dlist_create();  if(ret == NULL){    free(buf);    return(NULL);  }  while (at < limit) {    ifm = (struct if_msghdr *)at;    if(ifm->ifm_type == RTM_IFINFO) {      ifp = (struct Route_ifname *)calloc(1,sizeof(struct Route_ifname));      if(ifp == NULL){	printf("no more memory ifp failed to aloc - incomplete addrlists\n");	free(buf);	return(ret);      }      ifp->index = ifm->ifm_index;      ifp->addrList = dlist_create();      ifp->routes = dlist_create();      if(ifp->addrList == NULL){	printf("no more memory ifp->addrList - incomplete addrlists\n");	if(ifp->routes != NULL)	  dlist_destroy(ifp->routes);	free(buf);	free(ifp);	return(ret);      }      if(ifp->routes == NULL){	printf("no more memory ifp->routes\n");	dlist_destroy(ifp->addrList);	free(buf);	free(ifp);	return(ret);      }      if((at = routingDecodeif(ret,ifm,ifp,limit)) == NULL){	free(buf);	return(ret);      }    }else{      printf("RTM_IFINFO expected and not found\n");      break;    }  }  free(buf);  return(ret);}voidroutingInitializePrimary(struct routingAdaptor *r){  struct sockaddr *arry[RTAX_MAX],*start;  int mib[6],needed;  char *buf,*limit,*at;  struct rt_msghdr *rtm;  struct Route_ifname *ifp;  int setThePrim;  /* user does not want us to look at routing changes */  if(r->flags_passed & ROUTING_DONT_SET_PRIMARY)    return;  /* setup for sys control */  mib[0] = CTL_NET;  mib[1] = PF_ROUTE;  mib[2] = 0;  mib[3] = 0;	/* address family */  mib[4] = NET_RT_DUMP;  mib[5] = 0;  /* Find out space needed */  setThePrim = 0;  needed = 0;  if(sysctl(mib,6,NULL,&needed,NULL,0) < 0){    printf("Gak, failed to get list\n");    return;  }  buf = calloc(1,needed);  if(sysctl(mib,6,buf,&needed,NULL,0) < 0){    printf("Gak, failed to get list\n");    return;  }  limit = (char *)((caddr_t)buf + needed);  at = buf;  while(at < limit){    rtm = (struct rt_msghdr *)at;    at = (char *)((caddr_t)at + rtm->rtm_msglen);    start = (struct sockaddr *)((caddr_t)rtm + sizeof(struct rt_msghdr));    RouteBreakOutAddr(start,rtm->rtm_addrs,arry);    if(arry[RTAX_DST] == NULL){      printf("Route with no destination?\n");      continue;    }    if(arry[RTAX_GATEWAY] == NULL){      printf("Route with no gateway?\n");      continue;    }    routeAddARoute(r,rtm->rtm_index,		   arry[RTAX_DST],		   arry[RTAX_GATEWAY],		   arry[RTAX_NETMASK]);    /* don't go further if we have selected a primary */    if(setThePrim)      continue;    if(r->flags_passed & ROUTING_DONT_DO_INITIAL_PRIMARY){      /* No primary set at beginning */      continue;    }    if(r->flags_passed & ROUTING_PRIMARY_TRACKS_DEF_RT){      if(rtm->rtm_flags & RTF_GATEWAY){	ifp = routingFindindex(r,rtm->rtm_index);	if(ifp == NULL){	  continue;	}	if(ifp->if_type == IFT_LOOP){	  /* we never allow a Loopback to be primary */	  continue;	}	arry[RTAX_IFA] = routingSelectPrimaryForAF(ifp,						   arry[RTAX_DST],						   NULL,NULL);	if(arry[RTAX_IFA] == NULL){	  printf("Hmm can't find a suitable primary for %d\n",		 rtm->rtm_index);	  continue;	}	if(arry[RTAX_DST]->sa_family == AF_INET){	  struct sockaddr_in *sin;	  sin = (struct sockaddr_in *)arry[RTAX_DST];	  if(sin->sin_addr.s_addr == 0){	    /* Can't setprimary a zero address */	    printf("Initial Primary selected:\n");	    RoutePrintAnAddress(arry[RTAX_IFA]);	    sctpREMOTESETPRIMARYALL(r->sctp,				    arry[RTAX_IFA],				    SCTP_ACTION_QUEUE_REQUEST_ONLY); 	    r->lastKnownPrimary = arry[RTAX_IFA];	    setThePrim = 1;	    continue;	  }	}else if(arry[RTAX_DST]->sa_family == AF_INET6){	  struct sockaddr_in6 *sin6;	  sin6 = (struct sockaddr_in6 *)arry[RTAX_DST];	  if(IN6_IS_ADDR_UNSPECIFIED(&sin6->sin6_addr)){	    printf("Initial Primary selected:\n");	    RoutePrintAnAddress(arry[RTAX_IFA]);	    sctpREMOTESETPRIMARYALL(r->sctp,				    arry[RTAX_IFA],				    SCTP_ACTION_QUEUE_REQUEST_ONLY); 	    r->lastKnownPrimary = arry[RTAX_IFA];	    setThePrim = 1;	    continue;	  }	}      }    }else if(r->flags_passed & ROUTING_PRIMARY_TRACKS_HOST_RT){      if(rtm->rtm_flags & RTF_HOST){	ifp = routingFindindex(r,rtm->rtm_index);	if(ifp == NULL){	  printf("Can't find the index %d\n",rtm->rtm_index);	  continue;	}	arry[RTAX_IFA] = routingSelectPrimaryForAF(ifp,						   arry[RTAX_DST],						   NULL,NULL);	if(arry[RTAX_IFA] == NULL){	  printf("Hmm can't find a suitable primary for %d\n",		 rtm->rtm_index);	  continue;	}	printf("Initial Primary selected:\n");	RoutePrintAnAddress(arry[RTAX_IFA]);	sctpREMOTESETPRIMARYALL(r->sctp,				arry[RTAX_IFA],				SCTP_ACTION_QUEUE_REQUEST_ONLY); 	r->lastKnownPrimary = arry[RTAX_IFA];	setThePrim = 1;	continue;      }    }  }  free(buf);}#endifstruct routingAdaptor *createRoutingAdaptor(struct distributor *d, struct SCTP *s, u_int flags){  int i;  struct routingAdaptor *ret;  ret = NULL;  i = 0;#ifdef FREEBSD  ret = calloc(1,sizeof(struct routingAdaptor));  if(ret == NULL)    return(ret);  ret->sctp = s;  ret->lastKnownPrimary = NULL;  ret->flags = (SCTP_ACTION_UPDATE_ENDPOINT|SCTP_ACTION_QUEUE_REQUEST_ONLY);  /* Flags controls if we just add to endpoint or   * also update the associations as well   */  ret->flags_passed = flags;  if(flags & ROUTING_UPDATE_ALL_ASSOC)    ret->flags |= SCTP_ACTION_UPDATE_ALL_ASSOC;  ret->dist = d;  for(i=0;i<ROUTING_NUMBER_OF_TIMERS;i++){    ret->timers[i].up = RoutingTimer_STOPPED;    ret->timers[i].type = RoutingTimerType_NONE;  }  ret->routefd = socket(PF_ROUTE, SOCK_DGRAM, 0);  if(ret->routefd == -1){    printf("error can't get routing socket %d\n",errno);    return(ret);  }  ret->iflist = routingInitialzeNameList();  ret->lastKnownPrimary = NULL;  routingInitializePrimary(ret);  dist_addFd(ret->dist,	     ret->routefd,	     routingAdaptorFdEvent,	     POLLIN,	     (void *)ret);#endif /* FREEBSD */  return(ret);}voiddestroyRoutingAdaptor(struct routingAdaptor *r){#ifdef FREEBSD  int i;  if(r != NULL){    if(r->routefd != -1){      if(r->dist != NULL){	dist_deleteFd(r->dist,r->routefd);	for(i=0;i<ROUTING_NUMBER_OF_TIMERS;i++){	  if(r->timers[i].up == RoutingTimer_RUNNING){	    dist_TimerStop(r->dist,			   routingAdaptorTimer,			   (void *)r,			   (void *)&r->timers[i]);	    r->timers[i].up = RoutingTimer_STOPPED;	  }	}      }      close(r->routefd);      r->routefd = -1;    }    if(r->iflist != NULL){      struct Route_ifname *ifp;      dlist_reset(r->iflist);      while((ifp = (struct Route_ifname *)dlist_getNext(r->iflist)) != NULL){	/* destroy the ifp */	struct sockaddr_storage *sad;	struct routeEntry *re;	if(ifp->addrList != NULL){	  dlist_reset(ifp->addrList);	  while((sad = (struct sockaddr_storage *)dlist_getNext(ifp->addrList))		!= NULL){	    free(sad);	  }	  dlist_reset(ifp->routes);	  while((re = (struct routeEntry *)dlist_getNext(ifp->routes)) != NULL){	    if(re->dst != NULL)	      free(re->dst);	    if(re->gate != NULL)	      free(re->gate);		    if(re->netmask != NULL)	      free(re->netmask);	    re->ifp = NULL;	  }	  dlist_destroy(ifp->addrList);	  dlist_destroy(ifp->routes);	}      }      dlist_destroy(r->iflist);    }  }  free(r);#endif}introutingAdaptorFdEvent(void *ra, int fd, int event){#ifdef FREEBSD  char readbuffer[ROUTE_READ_BUF_SIZE];  int at;  struct if_msghdr *ifm;	/* RTM_IFINFO */  struct ifa_msghdr *ifam; 	/* RTM_NEWADDR and RTM_DELADDR */  struct ifma_msghdr *ifmam;	/* RTM_NEWMADDR and RTM_DELMADDR */  struct rt_msghdr *rtm; 	/* All others use this one */  struct routingAdaptor *r;  int len,cnt,timerReq;  r = (struct routingAdaptor *)ra;  if(r->routefd != fd){    printf("Routing socket:Error, I have fd:%d passed %d\n",	   r->routefd,fd);    return(0);  }  memset(readbuffer,0,sizeof(readbuffer));  timerReq = 0;  len = read(r->routefd,readbuffer,sizeof(readbuffer));  if (len < 0){    printf("Routing socket:Error on read %d\n",errno);    return(0);  }  if(r->sctp == NULL)    return(0);  cnt = at = 0;  while(at < len){    rtm = (struct rt_msghdr *)&readbuffer[at];    cnt++;    if(rtm->rtm_msglen <= 0){      /* must be all done */      break;    }    if(rtm->rtm_msglen > (len - at)){      /* TSNH */      break;    }    switch(rtm->rtm_type) {    case RTM_ADD:    case RTM_CHANGE:    case RTM_OLDADD:    case RTM_REDIRECT:      timerReq += routingSetPrimaryIfNeeded(r,rtm);      break;    case RTM_DELETE:    case RTM_GET:    case RTM_OLDDEL:      /* No good to us, but call for testing */      timerReq += routingSetPrimaryIfNeeded(r,rtm);      break;    case RTM_LOSING:    case RTM_MISS:    case RTM_LOCK:    case RTM_RESOLVE:      break;    case RTM_NEWMADDR: /* mcast group membership being added to if */    case RTM_DELMADDR: /* mcast group membership being deleted */      ifmam = (struct ifma_msghdr *)rtm;      break;    case RTM_NEWADDR:      printf("ADD address?\n");      ifam = (struct ifa_msghdr *)rtm;      timerReq += RouteParseAdd(r,ifam);      break;    case RTM_DELADDR:      printf("DELETE address?\n");      ifam = (struct ifa_msghdr *)rtm;      timerReq += RouteParseDel(r,ifam);      break;    case RTM_IFINFO:	/* interface status change */      printf("New address?\n");      ifm = (struct if_msghdr *)rtm;      routingPossibleAddNewIFP(r,ifm);      break;    default:      break;    }    at += rtm->rtm_msglen;  }  if(timerReq)    routingAStartTimer(r,0,RoutingTimerType_SCTP_COMMIT);      fflush(stdout);#endif  return(0);}voidroutingAdaptorTimer(void *ra, void *timer){#ifdef FREEBSD  struct routingAdaptor *r;  struct routingTimer *rt;  r = (struct routingAdaptor *)ra;    rt = (struct routingTimer *)timer;  if((caddr_t)rt > ((caddr_t)r + sizeof(struct routingAdaptor))){    return;  }  rt->up = RoutingTimer_STOPPED;  if(rt->type == RoutingTimerType_SCTP_COMMIT){    if(r->sctp != NULL){      sctpEXECUTEAllAddDel(r->sctp);    }  }#endif}voidprintRoutingTable(struct routingAdaptor *r){#ifdef FREEBSD  struct Route_ifname *ifp;  struct routeEntry *re;  dlist_reset(r->iflist);  while((ifp = (struct Route_ifname *)dlist_get(r->iflist)) != NULL){    printf("****For interface %s index:%d",	   ifp->if_name,ifp->index);    if(dlist_getCnt(ifp->routes) == 0){      printf("-no routes on interface****\n");      continue;    }else{      printf("-has the following routes****\n");    }    dlist_reset(ifp->routes);    while((re = (struct routeEntry *)dlist_get(ifp->routes)) != NULL){      printf("Destination:");      RoutePrintAnAddress(re->dst);      printf("Gateway:");      RoutePrintAnAddress(re->gate);      if(ifp != re->ifp){	printf("WARNING!!! ifp in route does not match found interface\n");      }    }  }#endif}