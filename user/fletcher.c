unsigned int fletcher(const unsigned char *buf, int len){  unsigned long s1 = 0;  unsigned long s2 = 0;  unsigned short *bufp;  int n,nlen;  nlen = len / 2;  bufp = (unsigned short *)buf;  for (n = 0; n < nlen; n++,bufp++) {    s1 = ((s1 + *bufp) & 0x0000ffff);    s2 = ((s2 + s1) & 0x0000ffff);  }  if(len > (nlen *2)){    /* do the odd byte, we don't     * expect this code to execute.     */    unsigned short x;    x = buf[(len-1)] << 8 | 0;    s1 = ((s1 + x) & 0x0000ffff);    s2 = ((s2 + s1) & 0x0000ffff);  }  return ((unsigned int)(s2 << 16) + s1);}unsigned int tcp32(const unsigned char *buf, int len){  unsigned long s1 = 0;  unsigned long s2 = 0;  unsigned long wrap = 0;  unsigned long *bufp;  int n,nlen;  int odd;  nlen = len / 4;  bufp = (unsigned long *)buf;  for (n = 0; n < nlen; n++,bufp++) {    s2 = (s1 + *bufp);    if((s2 < s1) && (s2 < *bufp)){      wrap++;    }    s1 = s2;  }  odd = len-(nlen*4);  if(odd){    /* We never really expect this code to execute     * since SCTP requires 4 byte alignment of     * all data and padding.     */    unsigned long final;    unsigned char a,b,c,d;    if(odd == 1){      a = buf[(len-1)];      b = c = d = 0;    }else if(odd == 2){      a = buf[(len-2)];      b = buf[(len-1)];      c = d = 0;    }else{      a = buf[(len-3)];      b = buf[(len-2)];      c = buf[(len-1)];      d = 0;    }    final = (a << 24) | (b << 16) | (c << 8) | d;    s2 = (s1 + final);    if((s2 < s1) && (s2 < final)){      wrap++;    }    s1 = s2;  }  /* Now add the roll over */  s2 = s1 + wrap;  if((s2 < s1) && (s2 < wrap)){    /* roll it again */    s2 += 1;  }  s1 = ~s2;  return(s1);}