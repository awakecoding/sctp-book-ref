/* SCTP reference Implementation Copyright (C) 2001 Cisco And MotorolaThis file is part of the SCTP reference ImplementationVersion:4.0.5$Header: /home/sourceTree/src/sctp/user/sctpinbound.c,v 1.42 2001/07/25 18:47:55 randall Exp $The SCTP reference implementation  is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published bythe Free Software Foundation; either version 2, or (at your option)any later version.the SCTP reference implementation  is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of                ************************MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See theGNU Library General Public License for more details.You should have received a copy of the GNU Library General Public Licensealong with GNU CC; see the file COPYING.  If not, write tothe Free Software Foundation, 59 Temple Place - Suite 330,Boston, MA 02111-1307, USA.  Please send any bug reports or fixes you make to one of the following emailaddresses:rrs@cisco.comkmorneau@cisco.comqxie1@email.mot.comAny bugs reported given to us we will try to fix... any fixes shared willbe incorperated into the next SCTP release.There are still LOTS of bugs in this code... I always run on the motto"it is a wonder any code ever works :)"*/#include <sctp.h>#include <sctputil.h>#include <sctpsenders.h>#include <sctpinbound.h>voidSCTP_handleSegments(struct SCTP *m,		    struct SCTP_association *asoc,		    struct sctpUnifiedSack *uh,		    u_long lastTSN,		    u_long *biggestTSNacked,		    int numSeg){  /************************************************/  /* process fragments and update sendqueue        */  /************************************************/  struct sctpSelectiveAck *sack;  struct sctpSelectiveFrag *frag;  struct SCTP_transmitOnQueue *tp1;  int i,j;  u_short fragStrt, fragEnd;  u_long lastFraghigh;  sack = &(uh->sack);  frag = (struct sctpSelectiveFrag *)    ((u_long)sack + sizeof(struct sctpSelectiveAck));  SCTPdebugPrint(m,"Processing %d fragments\n",numSeg);  tp1 = NULL;  lastFraghigh = 0;  for(i=0; i<numSeg; i++) {    fragStrt = ntohs(frag->fragmentStart);    fragEnd = ntohs(frag->fragmentEnd);    /* some sanity checks on the fargment offsets */    SCTPdebugPrint(m,"process fragStart:%x fragEnd:%x\n",tp1,		   fragStrt, fragEnd);    if(fragStrt > fragEnd) {      /* this one is mulformed, skip */      frag++;      continue;    }    if(compare_with_wrap((fragEnd+lastTSN),*biggestTSNacked,MAX_TSN))      *biggestTSNacked = fragEnd+lastTSN;    /* mark acked dgs and find out the highestTSN being acked */    if(tp1 == NULL){      tp1 = asoc->sendqueue;      /* save the locations of the last frags */      lastFraghigh = fragEnd + lastTSN;    }else{      /* now lets see if we need to reset the queue       * due to a out-of-order SACK fragment        */      if(compare_with_wrap(fragStrt+lastTSN,lastFraghigh,MAX_TSN)){ 	/* if the new frag starts after the last TSN frag covered, we are ok */	/* and this one is beyond the last one */	;      }else{	/* ok, they have reset us, so we need to reset the queue 	 * this will cause extra hunting but hey, they chose the performance	 * hit when they failed to order there gaps..	 */	tp1 = asoc->sendqueue;      }      lastFraghigh = fragEnd + lastTSN;    }    for(j=fragStrt + lastTSN; j<=fragEnd + lastTSN; j++) {      while(tp1){	if(tp1->TSN_seq == j) {	  if(tp1->sent != SCTP_DATAGRAM_UNSENT){	    SCTPdebugPrint(m,"2. Marking acked TSN %x\n",tp1->TSN_seq);	    /* to held until cum-ack passes */	    if(tp1->sent < SCTP_DATAGRAM_ACKED){	      /* If it is less than ACKED, it is now no-longer in	       * flight. Higher values may already be set via previous	       * Gap Ack Blocks... i.e. ACKED or MARKED.	       */	      asoc->nets[tp1->whichNet].flightSize -= tp1->sizeOfTmit;	      if(asoc->nets[tp1->whichNet].flightSize  < 0){		asoc->nets[tp1->whichNet].flightSize = 0;	      }	      asoc->totalFlight -= tp1->sizeOfTmit;	      if(asoc->totalFlight < 0){		asoc->totalFlight = 0;	      }	      asoc->nets[tp1->whichNet].netAck += tp1->sizeOfTmit;	      if(tp1->sndCount < 2){		/* True non-retransmited chunk */		asoc->nets[tp1->whichNet].netAck2 += tp1->sizeOfTmit;		/* update RTO too? */		if(tp1->sent_rcv_Time.tv_sec || tp1->sent_rcv_Time.tv_nsec) {		  asoc->nets[tp1->whichNet].RTO = 		    calculateRTO(m, asoc,				 tp1->whichNet,				 tp1->sent_rcv_Time.tv_sec,				 tp1->sent_rcv_Time.tv_nsec);		  asoc->nets[tp1->whichNet].rtoPending = 0;		  tp1->sent_rcv_Time.tv_sec = tp1->sent_rcv_Time.tv_nsec = 0;		}	      }	    }#ifdef SCTP_NO_FR_UNLESS_SEGMENT_SMALLER	    if((tp1->sent <= SCTP_DATAGRAM_RESEND) && 	       (tp1->sent != SCTP_DATAGRAM_UNSENT) && 	       (compare_with_wrap(tp1->TSN_seq,asoc->thisSackHighestGap,MAX_TSN))){	      asoc->thisSackHighestGap = tp1->TSN_seq;	    }#endif	    tp1->sent = SCTP_DATAGRAM_MARKED;	  }else{	    SCTPdebugPrint(m,"ERROR: acking unsent TSN %x\n",tp1->TSN_seq);	  }	  break;	} /* if(tp1->TSN_seq == j) */	if(compare_with_wrap(tp1->TSN_seq,j,MAX_TSN))	  break;	tp1 = tp1->next;      }/* end while(tp1) */    }  /* end for(j=fragStart */    SCTPdebugPrint(m,"done process frag %x to %x (j=%x)\n",			   fragStrt, fragEnd, j);    frag++; /* next one */  }}voidSCTP_checkForRevoked(struct SCTP *m,		     struct SCTP_association *asoc,		     u_long cumAck){  struct SCTP_transmitOnQueue *tp1;  tp1 = asoc->sendqueue;  while(tp1){    if(compare_with_wrap(tp1->TSN_seq,cumAck,MAX_TSN)){      /* ok this guy is either ACK or MARKED. If it is ACKED it       * has been previously acked but not this time i.e. revoked.       * If it is MARKED it was ACK'ed again.       */      if(tp1->sent == SCTP_DATAGRAM_ACKED){	/* it has been revoked */	/* We do NOT add back to flight size here since 	 * it is really NOT in flight. Resend (when/if it occurs	 * will add to flight size 	 */	SCTPdebugPrint(m,"****WARNING, peer revoked SACK (you should feel bad peer)!\n");	tp1->sent = SCTP_DATAGRAM_SENT;      }else if(tp1->sent == SCTP_DATAGRAM_MARKED){	/* it has been re-acked in this SACK */	tp1->sent = SCTP_DATAGRAM_ACKED;      }    }    if(tp1->sent == SCTP_DATAGRAM_UNSENT)      break;    tp1 = tp1->next;  }}static u_long fretran[10000];static int fretranat=0;voidSCTP_strikeGapAckChunks(struct SCTP *m,			struct SCTP_association *asoc,			u_long biggestTSNacked			)		     {  struct SCTP_transmitOnQueue *tp1;  tp1 = asoc->sendqueue;  while(tp1){    if((compare_with_wrap(tp1->TSN_seq,biggestTSNacked,MAX_TSN)) ||       (tp1->sent == SCTP_DATAGRAM_UNSENT)) {      /* done */      break;    }    if(tp1->sent >= SCTP_DATAGRAM_RESEND){      /* either a RESEND, ACKED, or MARKED */      /* skip */      tp1 = tp1->next;      continue;    }    SCTPdebugPrint(m,"retrans mark up on TSN:%x\n",tp1->TSN_seq);#ifdef SCTP_NO_FR_UNLESS_SEGMENT_SMALLER    if(compare_with_wrap(tp1->TSN_seq,asoc->thisSackHighestGap,MAX_TSN)){      tp1 = tp1->next;      continue;    }#endif    tp1->sent++;    if(tp1->sent == SCTP_DATAGRAM_RESEND) {      /* asoc->numberToRetran++; */      asoc->pegs[SCTP_FAST_RETRAN]++;      fretran[fretranat] = tp1->TSN_seq;      fretranat++;      if(fretranat == 9999)	fretranat = 0;      tp1->doingFastRetransmit = 1;      SCTPdebugPrint(m,"**********TSN %x marked as new resend\n",		     tp1->TSN_seq);      if(tp1->sent_rcv_Time.tv_sec){	/*  this guy had a RTO calculation pending on it, cancel it */	asoc->nets[tp1->whichNet].rtoPending = 0;	tp1->sent_rcv_Time.tv_sec = tp1->sent_rcv_Time.tv_nsec = 0;      }      if(tp1->whichNet < asoc->numnets){	/* Here we COUNT the number of datagrams 	 * we will be doing a fast-retransmit on.	 * If we reach here, this destination address	 * gets a stroke against it since I must	 * retransmit this datagram.	 */	asoc->nets[tp1->whichNet].netAck++;      }      /* Now take away the flight size from both the       * totalFlight AND the former destination        */      asoc->nets[tp1->whichNet].flightSize -= tp1->sizeOfTmit;      asoc->totalFlight -= tp1->sizeOfTmit;    }    tp1 = tp1->next;  } /* while(tp1) */}voidSCTP_countNumberOfResends(struct SCTP *m,			  struct SCTP_association *asoc){  struct SCTP_transmitOnQueue *tp1;  tp1 = asoc->sendqueue;  while(tp1){    if(tp1->sent == SCTP_DATAGRAM_RESEND){      /* we should always be == to RESEND here */      asoc->numberToRetran++;      SCTPdebugPrint(m,"++++Counting up on numberToRetran:%d\n",		     asoc->numberToRetran);      tp1 = tp1->next;      continue;    }    if(tp1->sent == SCTP_DATAGRAM_UNSENT)      break;    tp1 = tp1->next;  }}voidSCTP_tryAdvancePeerAckPoint(struct SCTP *m,			 struct SCTP_association *asoc){  struct SCTP_transmitOnQueue *tp1;  u_short rl;  tp1 = asoc->sendqueue;  while(tp1) {    if(tp1->sent != SCTP_DATAGRAM_RESEND) {      /* no chance to advance, out of here */      break;    }    /* get the stream reliability flag */    if(tp1->streamNumber == 0) {      rl = asoc->outbound.reliable;    } else {      rl = asoc->strmout[tp1->streamNumber - 1].reliable;    }    if(rl == SCTP_STRM_UNRELIABLE && tp1->numOfRetrans < 1) {      /*        * now we got a chunk which is marked for another        * retransmission to an unreliable stream but has run        * out its chances already.       */      /* advance PeerAckPoint */      asoc->advancedPeerAckPoint = tp1->TSN_seq;      SCTPdebugPrint(m,"U-SCTP: advanced PeerAckPoint to 0x%x\n",			tp1->TSN_seq);      /* we don't want to de-queue it here. Just wait for the next       * peer SACK to come with a new cumTSN and then the chunk will       * be droped in the normal fashion.       */    }    tp1 = tp1->next;  }}static unsigned long rwndarray[6][10000];static int rwndat=0;voidSCTP_handleInboundSack(struct SCTP *m,		       struct SCTP_association *asoc,		       struct sctpUnifiedSack *uh,		       struct sockaddr *from){  /* Given a SACK chunk, in following the *uh   * update all the ack things, freeing packets and   * adjusting windows... maybe restart T3 timer if   * not all are acked... or just cancel if all are   * resolved.    */  struct sctpSelectiveAck *sack;  struct SCTP_transmitOnQueue *tp1,*tp2;  u_long cumAck,lastTSN,biggestTSNacked;  u_short numSeg;  long i, j;  int accumMoved = 0;  int markingAllowed = 1;  int a_rwnd;  struct SCTP_nets *netp = NULL;  j = 0;  sack = &(uh->sack);  cumAck = lastTSN = ntohl(sack->highestConseqTSN);  numSeg = ntohs(sack->numberOfdesc);  asoc->numberToRetran = 0;  /* update the Rwnd of the peer */  a_rwnd = ntohl(sack->updatedRwnd);  if(compare_with_wrap(asoc->t3timeoutHighestMarked,cumAck,MAX_TSN)){    /* we are not allowed to mark for FR */    markingAllowed = 0;  }  rwndarray[0][rwndat] = cumAck;  rwndarray[1][rwndat] = a_rwnd;  rwndarray[2][rwndat] = asoc->totalFlight;  rwndarray[3][rwndat] = asoc->nets[0].flightSize;  rwndarray[4][rwndat] = asoc->nets[1].flightSize;  rwndarray[5][rwndat] = asoc->outQueueCount;  rwndat++;  if(rwndat == 9999){    rwndat = 0;  }  /**********************/  /* 1) check the range */  /**********************/  if(compare_with_wrap(asoc->lastAckedSeq, lastTSN, MAX_TSN)) {    /* acking something behind */    SCTPdebugPrint(m,"TSN out of range (old)- "		   "newTSN:0x%x lastAckedTSN:0x%x sendingTSN:0x%x\n",		   lastTSN, asoc->lastAckedSeq, asoc->sendingSeq - 1);    return;  }  if(asoc->sendqueue == NULL){    /* nothing left on sendqueue.. consider done */    int i;    SCTPdebugPrint(m,"Hummm, I got a dup sack for 0x%x, my queue is empty now.\n",(u_int)cumAck);    /* DUPLICATE SACK which may just be a rwnd update. */    /* stop all timers */    SCTPdebugPrint(m,"we will -> RE-SYNC peers rwnd to %d\n",		   a_rwnd);    SCTPdebugPrint(m,"SYNC rwnd to %d - A\n",a_rwnd);    asoc->peersRwnd = a_rwnd;    /* stop any timers */    for(i=0;i<asoc->numnets;i++){      timerWork(m, asoc, SCTP_TIMER_STOP, SctpTimerTypeSend, i);      asoc->nets[i].partial_bytes_acked = 0;    }    for(i=0;i<asoc->numnets;i++){      asoc->nets[i].flightSize = 0;    }    asoc->totalFlight = 0;    SCTPdebugPrint(m,"All done processing duplicate sack\n");    return;  }  /* We init netAckSz and netAckSz2 to 0. These   * are used to track 2 things. The total byte   * count acked is tracked in netAckSz AND netAck2   * is used to track the total bytes acked that are un-amibguious   * and were never retransmitted. We track these on a   * per destination address basis.   */  for(i=0; i<asoc->numnets; i++){    asoc->nets[i].netAck = 0;    asoc->nets[i].netAck2 = 0;  }  /* process the new consecutive TSN first */  tp1 = asoc->sendqueue;  while(tp1){    if((compare_with_wrap(lastTSN,tp1->TSN_seq,MAX_TSN))  ||       (lastTSN == tp1->TSN_seq)){      if(tp1->sent != SCTP_DATAGRAM_UNSENT) {	SCTPdebugPrint(m,"1. cum acked moved past TSN %x\n",tp1->TSN_seq);	if(tp1->doingFastRetransmit){	  /* increment the fastRetransmitCompletes since this 	   * will put in effect the BURST limit	   */	  asoc->fastRetransmitCompletes++;	}	accumMoved = 1;  	if(tp1->sent < SCTP_DATAGRAM_ACKED){	  /* If it is less than ACKED, it is now no-longer in	   * flight. Higher values may occur during marking	   */	  asoc->nets[tp1->whichNet].flightSize -= tp1->sizeOfTmit;	  if(asoc->nets[tp1->whichNet].flightSize  < 0){	    asoc->nets[tp1->whichNet].flightSize = 0;	  }	  asoc->totalFlight -= tp1->sizeOfTmit;	  if(asoc->totalFlight < 0){	    asoc->totalFlight = 0;	  }	  asoc->nets[tp1->whichNet].netAck += tp1->sizeOfTmit;	  if(tp1->sndCount < 2){	    /* True non-retransmited chunk */	    asoc->nets[tp1->whichNet].netAck2 += tp1->sizeOfTmit;	    /* update RTO too? */	    if(tp1->sent_rcv_Time.tv_sec || tp1->sent_rcv_Time.tv_nsec) {	      asoc->nets[tp1->whichNet].RTO = 		calculateRTO(m, asoc,			     tp1->whichNet,			     tp1->sent_rcv_Time.tv_sec,			     tp1->sent_rcv_Time.tv_nsec);	      asoc->nets[tp1->whichNet].rtoPending = 0;	      tp1->sent_rcv_Time.tv_sec = tp1->sent_rcv_Time.tv_nsec = 0;	    }	  }	}  	tp1->sent = SCTP_DATAGRAM_ACKED;      }else{	SCTPdebugPrint(m,"ERROR: acking unsent TSN %x\n",tp1->TSN_seq);      }    }else{      break;    }    tp1 = tp1->next;  }  SCTPdebugPrint(m,"done process new consecutive TSN %x (j=%x)\n", 		 lastTSN, j);  /***************************************/  /* cancel T3-send timer if accum moved */  /***************************************/  if(accumMoved){    int i;    SCTPdebugPrint(m,"stopped SND timer accumMoved\n");    for(i=0;i<asoc->numnets;i++){      timerWork(m, asoc, SCTP_TIMER_STOP, SctpTimerTypeSend, i);    }  }   biggestTSNacked = lastTSN;#ifdef SCTP_NO_FR_UNLESS_SEGMENT_SMALLER  /* always set this up to cum-ack */  asoc->thisSackHighestGap = lastTSN;#endif  if(numSeg > 0) {    /* thisSackHigestGap will increase while handling NEW segments */    SCTP_handleSegments(m,asoc,uh,lastTSN,&biggestTSNacked,numSeg);  }  SCTPdebugPrint(m,"Done marking all acked. Biggest TSN acked is %x\n",		 (u_int)biggestTSNacked);  /*******************************************/  /* drop the acked chunks from the sendqueue */  /*******************************************/  asoc->lastAckedSeq = cumAck;  /* Drag along the t3 timeout point so we don't have   * a problem at wrap   */  if(markingAllowed){    asoc->t3timeoutHighestMarked = cumAck;  }  SCTPdebugPrint(m,"***INTO REMOVING QUEUEU IS %x\n",		 (u_int)asoc->sendqueue);  tp1 = asoc->sendqueue;  do {    if(compare_with_wrap(tp1->TSN_seq,cumAck,MAX_TSN)){      SCTPdebugPrint(m,"CumAck:%x TSN inqueue:%x .. break\n",		     cumAck,tp1->TSN_seq);      break;    }    if(tp1->sent == SCTP_DATAGRAM_UNSENT){      /* no more sent on list */      SCTPdebugPrint(m,"TSN inqueue:%x .. break unsent\n",		     tp1->TSN_seq);      break;    }    SCTPdebugPrint(m,"Take %x out of queue\n",		   tp1->TSN_seq);    tp2 = tp1->next;    /* de-queue tp1 */    /* cum TSN moved so we can add back to rwnd     * since the peer can deliver via the parial     * delivery api     */    /* PHIL CONRAD: RIGHT HERE IS WERE I would put     * subtraction of any fun stream outbound. It ha     * now been ack'd so you want to lower the stream     * the tp1 was sent to's outstanding count     * by the number ack'd     */    if(tp1->prev == NULL) {      /* at the head of queue */      SCTPdebugPrint(m,"Ok prev is null\n");      asoc->sendqueue = tp1->next;      if(asoc->sendqueue) {	asoc->sendqueue->prev = NULL;      }else{	/* got the last one, null the tail */	asoc->sendqueuetail = NULL;      }    }else{      tp1->prev->next = tp1->next;      if(tp1->next) {	tp1->next->prev = tp1->prev;      }else if(tp1 == asoc->sendqueuetail){	/* else means I am at the end */	asoc->sendqueuetail = tp1->prev;      }    }    w_free(m,(void *)tp1->data);    w_free(m,(void *)tp1);    /* subtract the list totals out */    asoc->outQueueCount--;    tp1 = tp2;  }while(tp1 != NULL);  /* Check revoke no matter whether this SACK has frag or not */  SCTP_checkForRevoked(m,asoc,cumAck);  /******************************/  /* update cwnd                */  /******************************/  SCTPdebugPrint(m,"NOW going to update CWND('s)\n");  for(i=0; i<asoc->numnets; i++) {    /* if nothing was acked on this destination      * skip it.     */    SCTPdebugPrint(m,"Look at net %d netAck:%d netAck2=%d\n",		   i,		   asoc->nets[i].netAck,		   asoc->nets[i].netAck2);    netp = &asoc->nets[i];    if(netp->netAck == 0)      continue;    if(netp->netAck2 > 0){      /* Karn's rule applies to clearing error count, this is optional. */      netp->errorCount = 0;      if((netp->intfRotationState&SCTP_ADDR_NOT_REACHABLE) == SCTP_ADDR_NOT_REACHABLE){	/* addr came good */	unsigned char addrFmt[SCTP_ADDRMAX];	SCTPmakeIntoSock(addrFmt,asoc,i);	netp->intfRotationState &= ~SCTP_ADDR_NOT_REACHABLE;	netp->intfRotationState |= SCTP_ADDR_REACHABLE;	SCTPupperLayerNotification(m,asoc,SCTP_NOTIFY_INTF_UP,(int)addrFmt);      }    }    if(accumMoved){      /* If the cumulative ack moved we can proceed */      if(netp->cwnd <= netp->ssthresh) {	/* We are in slow start */	if((netp->flightSize+netp->netAck) >= netp->cwnd) {	  if(netp->netAck > netp->MTU){	    netp->cwnd += netp->MTU;	  }else{	    netp->cwnd += netp->netAck;	  }	}      }else{	/* We are in congestion avoidance */	if((netp->flightSize+netp->netAck) >= netp->cwnd){	  /* add to pba only if we	   * had a cwnd's worth (or so) in flight	   */	  netp->partial_bytes_acked += netp->netAck;	}	/* Do we need to increase (if pba is > cwnd)? */	if((netp->partial_bytes_acked >= netp->cwnd) &&	   ((netp->flightSize+netp->netAck ) >= netp->cwnd)) {	  /* Yep, we had a full cwnd out */	  netp->partial_bytes_acked -= netp->cwnd;	  netp->cwnd += netp->MTU;	}      }    }    /* NOW, according to Karn's rule do we need to     * restore the RTO timer back? Check our     * netAck2. If not set then we have a     * ambiguity.. i.e. all data ack'd was     * sent to more than one place.     */    if(asoc->nets[i].netAck2){      /* restore any doubled timers */      updateRTOtime(m, asoc, i);    }  }  if(asoc->sendqueue == NULL){    /* nothing left on sendqueue.. consider done */    int i;    /* stop all timers */    SCTPdebugPrint(m,"RE-SYNC peers rwnd to %d - B\n",		   a_rwnd);    asoc->peersRwnd = a_rwnd;    /* stop any timers */    for(i=0;i<asoc->numnets;i++){      SCTPdebugPrint(m,"stopped SND timer NONE left!!\n");      timerWork(m, asoc, SCTP_TIMER_STOP, SctpTimerTypeSend, i);      asoc->nets[i].partial_bytes_acked = 0;    }    for(i=0;i<asoc->numnets;i++){      asoc->nets[i].flightSize = 0;    }    asoc->totalFlight = 0;    /* clean up */    if(asoc->state & SCTP_STATE_SHUTDOWN_PEND){      /* is shutdown pending? if so do it */      SCTPdebugPrint(m,"Ok queue is NOW empty send shutdown\n");      asoc->state = SCTP_STATE_SHUTDOWN;      SCTPdebugPrint(m,"STATE SET TO SHUTDOWN\n");      SCTPsendAShutdown(m,asoc,0);      clearAllTimers(m,asoc);      /* zap all timers running */      timerWork(m,asoc,SCTP_TIMER_START,SctpTimerTypeShutdown,0);    }    /* all done return */    return;  }  /* Now here we are going to recycle netAckSz for a different   * use... HEADS UP.    */  for(i=0; i<asoc->numnets; i++){     asoc->nets[i].netAck = 0;  }  if((numSeg > 0) && markingAllowed) {    SCTP_strikeGapAckChunks(m,asoc,biggestTSNacked);  }  /*********************************************/  /* Here we perform U-SCTP procedures (XIE)   */  /* (section 4.2)                             */  /*********************************************/  /* C1. update advancedPeerAckPoint */  if(compare_with_wrap(cumAck,asoc->advancedPeerAckPoint,MAX_TSN)) {    asoc->advancedPeerAckPoint = cumAck;  }  /* C2. try to further move advancedPeerAckPoint ahead */  SCTP_tryAdvancePeerAckPoint(m,asoc);  /* C3. See if we need to send a Fwd-TSN */  if(compare_with_wrap(asoc->advancedPeerAckPoint,cumAck,MAX_TSN)) {    sendForwardTSN(m,asoc,from);  }  /* Count the number pending retransmission, no limits    * we could take this out if instead of 0'ing the count   * we maintained it when we sent etc.   */  SCTP_countNumberOfResends(m,asoc);  for(i=0; i<asoc->numnets; i++) {    if(asoc->nets[i].netAck > 0) {      /* per section 7.2.3, are there       * any destinations that had a fast       * retransmit to them. If so what we       * need to do is adjust ssthresh and       * cwnd.       */      netp = &asoc->nets[i];      netp->ssthresh = netp->cwnd / 2;      if(netp->ssthresh < (netp->MTU*2))	netp->ssthresh = 2 * netp->MTU;      netp->cwnd = netp->ssthresh;    }    /* Start a timer if there are inflight data present and     * the timer is NOT running (timerWork will not start     * a timer that is already running).     */    if(asoc->nets[i].flightSize > 0){      SCTPdebugPrint(m,"starting timer on net:%d still outstanding\n",		     i);      timerWork(m, asoc, SCTP_TIMER_START, SctpTimerTypeSend, i);    }  }  if((asoc->state&SCTP_STATE_MASK) == SCTP_STATE_SHUTDOWN_RECV){    /* assure that we ack right away */    asoc->needToAck = 3;  }  /* Adjust and set the new rwnd value */  asoc->peersRwnd =  a_rwnd - asoc->totalFlight;  SCTPdebugPrint(m,"RWND update, a_rwnd:%d totalflight:%d newrwnd:%d\n",		 a_rwnd,asoc->totalFlight,asoc->peersRwnd);}/*  * This just queues the data * into the inqueue.  * reassembly and unordered handling */static unsigned short deliveryArray[10000];static unsigned short inqueueArray[3][10000];static unsigned short mappedArray[2][10000];static int mapped=0;static int delat=0;static int inqueueat=0;intSCTPinqueueData(struct SCTP *m,		struct SCTP_association *asoc,		struct sctpChunkDesc *dchk,		int sz,		int netNum,		int inadrIdx,		struct SCTP_transmitOnQueue *tmit){  u_short strmNum;  u_short tt;  struct sctpDataPart *dp;  struct SCTP_stream_in *strmIn = NULL;  struct SCTP_transmitOnQueue *tp1; /* temp variables */  /* All dp integers have already been unnetworked */  dp = (struct sctpDataPart *)((u_long)dchk + sizeof(struct sctpChunkDesc));  inqueueArray[0][inqueueat] = tmit->streamSeq;  /******************************/  /* 2) handle re-asm if needed */  /******************************/  if((tmit->rcvFlags & SCTP_DATA_FRAG_MASK) != SCTP_DATA_NOT_FRAG) {    /* oops, got a fragmented chunk */    /* insert it into the re-asm q, in the order of TSN */    int x;    x = tmit->sizeOfTmit;    if(asoc->reasmqueue == NULL) {      asoc->reasmqueue = tmit;    } else if(compare_with_wrap(asoc->reasmqueue->TSN_seq, tmit->TSN_seq, MAX_TSN)) {      /* insert at the beginning */      tmit->next = asoc->reasmqueue;      asoc->reasmqueue->prev = tmit;      /* now make it new head. */      asoc->reasmqueue = tmit;    } else {      tt = 0;      tp1 = asoc->reasmqueue;      while(compare_with_wrap(tmit->TSN_seq, tp1->TSN_seq, MAX_TSN)) {	if(tp1->next == NULL) {	  tt =1; break;	}	tp1 = tp1->next;      }      if(tt == 1) {	/* hit the end of the queue */	tp1->next = tmit;	tmit->prev = tp1;      } else {	/* insert before tp1 */	tp1->prev->next = tmit;	tmit->prev = tp1->prev;	tp1->prev = tmit;	tmit->next = tp1;      }    }    /* see if this chunk can be re-assembled */    tmit = SCTPreasmData(m,asoc);    /* this is a small hack to keep from     * having to do a partial deliver api.     * We lie, and pretend we did NOT deliver     * the dg if we can't reassmble.      */    if(tmit == NULL) {      /* nothing is re-asmed, done */      return(-1);    }else{      /* now the rest of our hack to keep       * the myRwnd from growing when I get       * a big message. X will be added later       * by the caller when a 0 is returned.       * This will boost are rwnd possibly into       * the negative range until the upper layer       * reads this message.       */      asoc->myRwnd -= (tmit->sizeOfTmit - x);    }  }  /***************************/  /* 3) get the stream       */  /***************************/  strmNum = tmit->streamNumber;  if(strmNum == 0) {    /* stream 0 is always open */    strmIn = &asoc->inbound;  } else {    if(strmNum < asoc->streamincnt) strmIn = &asoc->strmin[strmNum-1];  }  if(strmIn == NULL) {    /* can't find this stream open.. sorry */    /* Should send the stream data error msg */    sendStreamError(m,asoc,strmNum,netNum);    SCTPdebugPrint(m,"Stream %d not in range, discard data chunk\n", strmNum);    if(tmit->data != NULL)      free(tmit->data);    free(tmit);    return(-1);  }  SCTPdebugPrint(m,"data chunk to Stream:%d\n",strmNum);  /********************************/  /* 4) re-ordering and inserting */  /********************************/  if(tmit->rcvFlags & SCTP_DATA_UNORDERED) {    /* yep, it is a un-ordered     * dg ready for immediate delivery, (priority)     */    SCTPdebugPrint(m,"Special un-ordered case.. insert to m->inqueue\n");    if(m->inqueue == NULL) {      m->inqueue = tmit;      m->inqueueLast = tmit;    }else{      tmit->next = m->inqueue;      m->inqueue->prev = tmit;      m->inqueue = tmit;    }    m->numberInbound++;    SCTPdebugPrint(m,"Make from out of net:%d make to out of net:%d\n",		   tmit->whichNet,tmit->toAddr);    SCTPmakeIntoSock(tmit->from,asoc,tmit->whichNet);    SCTPmakeIntoLocalSock(tmit->to,asoc,tmit->toAddr);    /* no sense in continuing since none      * was added to the stream queue      * so nothing has changed      */    return(0);  } else {    /* ok it is ordered */    if(strmIn->inqueue == NULL) {      /* nothing on the inqueue */      SCTPdebugPrint(m,"Tivial case none on stream in queue\n");      strmIn->inqueue = tmit;      inqueueArray[1][inqueueat] = 0;      inqueueArray[2][inqueueat] = 0;      inqueueat++;      if(inqueueat > 9999){	inqueueat = 0;      }    } else if(compare_with_wrap(strmIn->inqueue->streamSeq, tmit->streamSeq, MAX_SEQ)) {      /* insert at the beginning */      SCTPdebugPrint(m,"Insert at beginning in:%d head:%d\n",		     tmit->streamSeq,strmIn->inqueue->streamSeq);      inqueueArray[1][inqueueat] = 0;      inqueueArray[2][inqueueat] = strmIn->inqueue->streamSeq;      inqueueat++;      if(inqueueat > 9999){	inqueueat = 0;      }      tmit->next = strmIn->inqueue;      /* put in back link */      strmIn->inqueue->prev = tmit;      /* now make it new head. */      strmIn->inqueue = tmit;    } else {      SCTPdebugPrint(m,"Insert in list in:%d head:%d\n",		     tmit->streamSeq,strmIn->inqueue->streamSeq);      tp1 = strmIn->inqueue;      while(tp1 != NULL) {	if(compare_with_wrap(tp1->streamSeq, tmit->streamSeq, MAX_SEQ)) {	  /* insert right behind tp1 since tp1's has a bigger 	   * sequence number than the one I want to insert.	   */	  SCTPdebugPrint(m,			 "Putting %d before %d and after %d\n",			 tmit->streamSeq,			 tp1->streamSeq,			 tp1->prev->streamSeq);	  inqueueArray[1][inqueueat] = tp1->prev->streamSeq;	  inqueueArray[2][inqueueat] = tp1->streamSeq;	  inqueueat++;	  if(inqueueat > 9999){	    inqueueat = 0;	  }	  tp1->prev->next = tmit;	  tmit->prev = tp1->prev;	  tp1->prev = tmit;	  tmit->next = tp1;	  break;	}else if(tp1->next == NULL) {	  /* append at the end */	  SCTPdebugPrint(m,"Tacking on %d to end of list (%d)\n",			 tmit->streamSeq,			 tp1->streamSeq);	  tp1->next = tmit;	  tmit->prev = tp1;	  inqueueArray[1][inqueueat] = tp1->streamSeq;	  inqueueArray[2][inqueueat] = 0;	  inqueueat++;	  if(inqueueat > 9999){	    inqueueat = 0;	  }	  break;	}	tp1 = tp1->next; /* moves on */      }    }  } /* ... ok it is ordered */  /*****************************************/  /* 5) move good data to the main inqueue */  /*****************************************/  SCTPdebugPrint(m,"Moving good data of the queue to in queue top:%x\n",		 (u_int)strmIn->inqueue);    while(1) {    tt = strmIn->lastSequenceDelivered + 1;    SCTPdebugPrint(m,"Next expected is %d\n",tt);    if(strmIn->inqueue == NULL) {      SCTPdebugPrint(m,"Ok none on list\n");      break;    }    SCTPdebugPrint(m,"Check Next:%d against expected:%d\n",		   strmIn->inqueue->streamSeq,tt);    if(tt == strmIn->inqueue->streamSeq) {      /* the top of the inqueue is ready to be delivered */      deliveryArray[delat] = tt;      delat++;      if(delat >= 9999){	delat = 0;      }      SCTPdebugPrint(m,"deliver this guy!!\n");      SCTPmakeIntoSock(strmIn->inqueue->from,asoc,strmIn->inqueue->whichNet);      SCTPmakeIntoLocalSock(strmIn->inqueue->to,asoc,strmIn->inqueue->toAddr);      SCTPdebugPrint(m,"Ok now for the insertion\n");      tp1 = strmIn->inqueue;      /* detach from stream inqueue first */      if(tp1->streamNumber > 3){	asoc->pegs[SCTP_STRMO_RCV]++;      }else{	asoc->pegs[(SCTP_STRM0_RCV+tp1->streamNumber)]++;      }      strmIn->inqueue = strmIn->inqueue->next;      if(strmIn->inqueue != NULL) {	strmIn->inqueue->prev = NULL;	SCTPdebugPrint(m,"Top of queue now %x:%d next:%x\n",		       (u_int)strmIn->inqueue,		       strmIn->inqueue->streamSeq,		       (u_int)strmIn->inqueue->next);      } else {	SCTPdebugPrint(m,"Top of queue now NULL\n");      }      tp1->prev= tp1->next = NULL;      SCTPdebugPrint(m,"Have detached from stream queue\n");      /* attach to the main inqueue */      if(m->inqueue == NULL) {	SCTPdebugPrint(m,"Trivial case..  m->inqueue is empty\n");	m->inqueue = tp1;	m->inqueueLast = tp1;      }else{	SCTPdebugPrint(m,"place m->inqueueLast to point to tp1\n");	m->inqueueLast->next = tp1;	tp1->prev = m->inqueueLast;	m->inqueueLast = tp1;      }      m->numberInbound++;      /* update index */      strmIn->lastSequenceDelivered = tt;    } else {      SCTPdebugPrint(m,"No delivery breaking\n");      break;    }  }  return(0);}struct SCTP_transmitOnQueue *SCTPreasmData(struct SCTP *m,	      struct SCTP_association *asoc){  /*    * This subroutine checks if there is a complete set   * of fragments on the re-asm queue, and perform the    * re-asm if one exists.   */  struct SCTP_transmitOnQueue *strtChnk, *endChnk, *tmit;  struct SCTP_transmitOnQueue *tp1, *tp2; /* temp vairables */  u_long lastTSN;  int totSz;  lastTSN = 0;  strtChnk = endChnk = tmit = NULL;  tp1 = asoc->reasmqueue;  while (tp1 != NULL) {    if((tp1->rcvFlags & SCTP_DATA_FRAG_MASK) == SCTP_DATA_FIRST_FRAG) {      /* found a first frag chunk */      strtChnk = tp1;      lastTSN = tp1->TSN_seq;      /*********************************/      /* added for U-SCTP              */       /*********************************/      /* check if we need to purge some incomplete messages for u-sctp support */      if(compare_with_wrap(asoc->mappingArrayHighestTSN, strtChnk->TSN_seq, MAX_TSN)) {	/* cumTSN is more advanced than this first frag. So, anything before	 * this first frag can be safely purged. They will never show up.	 */	while(asoc->reasmqueue &&	      asoc->reasmqueue != strtChnk) {	  tp2 = asoc->reasmqueue;	  SCTPdebugPrint(m,"U-SCTP: purge chunk from reasmqueue:TSN=%x,strm=%d,SSN=%x\n", 			 tp2->TSN_seq,tp2->streamNumber,tp2->streamSeq);	  asoc->reasmqueue = asoc->reasmqueue->next;	  if(asoc->reasmqueue == NULL) break;	  asoc->reasmqueue->prev = NULL;	  /* free the memory */	  w_free(m, tp2->data);	  w_free(m, tp2);	}      }    }    else if((tp1->rcvFlags & SCTP_DATA_FRAG_MASK) == SCTP_DATA_MIDDLE_FRAG) {      /* this is a middle frag chunk */      if(strtChnk != NULL) {	if(tp1->TSN_seq == lastTSN + 1) {	  lastTSN = tp1->TSN_seq;	} else {	  /* chunk missing */	  strtChnk = NULL;	}      }    }    else {      /* must be a last frag chunk */      if(strtChnk != NULL) {	if(tp1->TSN_seq == lastTSN + 1) {	  /* good, we got both, can do re-asm now */	  endChnk = tp1;	  /* de-queue the subsequence */	  if(strtChnk->prev == NULL) {	    if(endChnk->next == NULL) {	      /* everything is de-queued */	      asoc->reasmqueue = NULL;	    } else {	      /* from the beginning */	      asoc->reasmqueue = endChnk->next;	      endChnk->next->prev = NULL;	    }	  } else {	    if(endChnk->next == NULL) {	      /* up to the end */	      strtChnk->prev->next = NULL;	    } else {	      /* in the middle */	      strtChnk->prev->next = endChnk->next;	      endChnk->next->prev = strtChnk->prev;	    }	  }	  strtChnk->prev = endChnk->next = NULL;	  /* re-asm */	  totSz = 0;	  tp1 = strtChnk;	  do {	    totSz += tp1->sizeOfTmit;	  } while((tp1 = tp1->next));	  tmit = (struct SCTP_transmitOnQueue *) 	         malloc (sizeof(struct SCTP_transmitOnQueue));	  if(tmit == NULL) {	    printf("out of mem...\n");	    return(NULL);	  }	  memcpy((void *)tmit, (void *)strtChnk, 		 sizeof(struct SCTP_transmitOnQueue));	  /* Note the TSN of the re-assembled tmit now equals to 	   * the TSN of the beginning chunk. Very important.	   */	  tmit->next = tmit->prev = NULL;	  tmit->rcvFlags |= SCTP_DATA_NOT_FRAG;	  tmit->sizeOfTmit = totSz;	  if(tmit->sizeOfTmit>0) {	    	    if((tmit->data = w_malloc(m,tmit->sizeOfTmit)) == NULL) {	      printf("out of mem...\n");	      w_free(m,tmit);	      tp1 = strtChnk;	      do {		tp2 = tp1->next;		w_free(m,tp1);		tp1 = tp2;	      } while(tp1);	      return(NULL);	    }	    totSz = 0;	    tp1 = strtChnk;	    do {	      memcpy((void *)(tmit->data + totSz),		     (void *)tp1->data,		     tp1->sizeOfTmit);	      totSz += tp1->sizeOfTmit;	    } while((tp1 = tp1->next));	    tp1 = strtChnk;	    do {	      tp2 = tp1->next;	      w_free(m,tp1->data);	      w_free(m,tp1);	      tp1 = tp2;	    } while(tp1);	  }	  SCTPdebugPrint(m,"Ok re-asmbed data tmit to address %x (sz=%d)\n",			 (u_int)tmit, tmit->sizeOfTmit);	  return(tmit);	} else {	  /* chunk still missing */	  strtChnk = NULL;	}      }    }    tp1 = tp1->next; /* move to the next chunk */  } /* while (tp1 != NULL) */  return(NULL);}voidSCTPhandleFwdTsn(struct SCTP *m,		 struct sctpChunkDesc *desc,		 struct SCTP_association *asoc){  /* here we will perform all the data receiver side steps for    * processing FwdTSN, as required in by u-sctp draft:   *    * Assume we get FwdTAN(x):   *   * 1) update local cumTSN to x   * 2) try to further advance cumTSN to xx   * 3) examine and update re-ordering queue on unreliable in-streams   * 4) clean up re-assembly queue  */  u_long newCumTsn, gapSz, endOfUse, newCumTsn2;  int i, ret;  struct SCTP_stream_in *strmIn;  /*************************************************************/  /* 1. Here we update local cumTSN and shift the bitmap array */  /*************************************************************/  newCumTsn = ntohl(((struct sctpForwardTSN *)desc)->newCumulativeTSN);  if(compare_with_wrap(asoc->mappingArrayHighestTSN, newCumTsn, MAX_TSN)) {    /* this new cumTSN is too old, ignore it */    SCTPdebugPrint(m,"FwdTSN too old, ignored: fwdTSN=%x cumTSN=%x\n",		   newCumTsn, asoc->mappingArrayHighestTSN);    return;  }  /* now we know the new TSN is more advanced, let's find the actual gap */  if(newCumTsn >= asoc->mappingArrayHighestTSN) {    gapSz = newCumTsn - asoc->mappingArrayHighestTSN;  } else {    /* try to prevent underflow here */    gapSz = newCumTsn + (MAX_TSN - asoc->mappingArrayHighestTSN) + 1;  }  if(gapSz > asoc->mappingArraySz || gapSz <= 0) {    /* out of range, too questionable. better to drop it silently */    SCTPdebugPrint(m,"FwdTSN out of range (gapSz=%x), droped: cumTSN=%x fwdTSN=%x\n",		   gapSz, asoc->mappingArrayHighestTSN, newCumTsn);    return;  }  SCTPdebugPrint(m,"Got fwdTSN and adopting it: fwdTSN=%x old cumTSN=%x gapSz=0x%x\n",		 newCumTsn, asoc->mappingArrayHighestTSN, gapSz);  /* see if we can further advance the fwdTSN */  newCumTsn2 = newCumTsn;  while(asoc->mappingArray[gapSz] == 1 &&	gapSz <= asoc->mappingArraySz) {    gapSz++;    newCumTsn2++; /* don't worry if it wraps */  }  if(compare_with_wrap(newCumTsn2, newCumTsn, MAX_TSN)) {    SCTPdebugPrint(m,"FwdTSN further advanced: frm %x to %x, new gapSz=0x%x\n",		   newCumTsn, newCumTsn2, gapSz);    newCumTsn = newCumTsn2;  }  /* find the current end of use of the array */  if(asoc->highestTSNinside >= asoc->mappingArrayHighestTSN){    /* no wrap inside */    endOfUse = asoc->highestTSNinside - asoc->mappingArrayHighestTSN;  }else{    endOfUse = asoc->highestTSNinside + (MAX_TSN - asoc->mappingArrayHighestTSN) + 1;  }  SCTPdebugPrint(m,"Current end of use is %d\n", endOfUse);  /* advance the highest consecutive TSN */  asoc->mappingArrayHighestTSN = newCumTsn;  /* advance the highest received TSN */  if(compare_with_wrap(asoc->mappingArrayHighestTSN, 		       asoc->highestTSNinside, 		       MAX_TSN)) {    SCTPdebugPrint(m,"Updating highestTSNinside to fwdTSN (=%x) as well\n",		   asoc->highestTSNinside);    asoc->highestTSNinside = asoc->mappingArrayHighestTSN;  }  /* shift the array */  if(gapSz >= endOfUse) {    SCTPdebugPrint(m,"Got them all zap %d\n",endOfUse);    memset(asoc->mappingArray,0,endOfUse);  } else {    SCTPdebugPrint(m,"memmove %x <- %x sz=%d\n",		   (u_int)asoc->mappingArray,		   (u_int)&(asoc->mappingArray[gapSz]),		   (endOfUse-gapSz));    memmove((void *)asoc->mappingArray, 	    (void *)(&asoc->mappingArray[gapSz]), 	    (endOfUse - gapSz));    SCTPdebugPrint(m,"memset %x for %d\n",		   (u_int)(&asoc->mappingArray[gapSz]), 		   (endOfUse-gapSz));    memset((void *)(&asoc->mappingArray[gapSz]), 0, (endOfUse-gapSz));  }  /*************************************************************/  /* 2. Clear up re-assembly queue                             */  /*************************************************************/  /* this is done automatically every time SCTPreasmData() is    * called.   */  /*************************************************************/  /* 3. Update the unreliable re-ordering queues               */  /*************************************************************/  /* check stream 0 */  strmIn = &asoc->inbound;  if(strmIn->reliable == SCTP_STRM_UNRELIABLE) {    ret = SCTPkickUnrelReorderQueue(m,asoc,strmIn);    if(ret>0)      SCTPdebugPrint(m,"U-SCTP: force-delivered %d messages from strm 0\n", 		     ret);  }  /* do other streams */  for(i=0;i<asoc->streamincnt;i++) {    if(asoc->strmin[i].reliable == SCTP_STRM_UNRELIABLE) {      strmIn = &asoc->strmin[i];      ret = SCTPkickUnrelReorderQueue(m,asoc,strmIn);      if(ret>0)	SCTPdebugPrint(m,"U-SCTP: force-delivered %d messages from strm %d\n",		       ret, i+1);    }  }}intSCTPkickUnrelReorderQueue(struct SCTP *m,			  struct SCTP_association *asoc,			  struct SCTP_stream_in *strmIn){  /* this subroutine tries to deliver any ready msgs    * from the inqueue of an unreliable stream   */  struct SCTP_transmitOnQueue *tp1; /* temp variables */  int tt, ret;  if(strmIn->inqueue == NULL) return(0);  ret = 0;  tt = strmIn->lastSequenceDelivered + 1;  while(compare_with_wrap(asoc->mappingArrayHighestTSN, 			  strmIn->inqueue->TSN_seq, MAX_TSN) ||	(asoc->mappingArrayHighestTSN == strmIn->inqueue->TSN_seq) ||	(tt == strmIn->inqueue->streamSeq)) {    /* this is deliverable now, move it to the end of m->inqueue */    deliveryArray[delat] = strmIn->inqueue->streamSeq;    delat++;    if(delat >= 9999){      delat = 0;    }    SCTPdebugPrint(m,"deliver this guy: SSN=%d\n",		   strmIn->inqueue->streamSeq);    SCTPmakeIntoSock(strmIn->inqueue->from,asoc,strmIn->inqueue->whichNet);    SCTPmakeIntoLocalSock(strmIn->inqueue->to,asoc,strmIn->inqueue->toAddr);    tp1 = strmIn->inqueue;    /* detach from stream inqueue first */    strmIn->inqueue = strmIn->inqueue->next;    if(strmIn->inqueue != NULL) {      strmIn->inqueue->prev = NULL;      SCTPdebugPrint(m,"Top of queue now %x:%d next:%x\n",		     (u_int)strmIn->inqueue,		     strmIn->inqueue->streamSeq,		     (u_int)strmIn->inqueue->next);    } else {      SCTPdebugPrint(m,"Top of queue now NULL\n");    }    tp1->prev= tp1->next = NULL;    SCTPdebugPrint(m,"Have detached from stream queue\n");    /* attach to the main inqueue */    if(m->inqueue == NULL) {      SCTPdebugPrint(m,"Trivial case..  m->inqueue is empty\n");      m->inqueue = tp1;      m->inqueueLast = tp1;    }else{      SCTPdebugPrint(m,"place m->inqueueLast to point to tp1\n");      m->inqueueLast->next = tp1;      tp1->prev = m->inqueueLast;      m->inqueueLast = tp1;    }    m->numberInbound++;    ret++;    /* update index */    strmIn->lastSequenceDelivered = tp1->streamSeq;    if(strmIn->inqueue == NULL) break;    tt = strmIn->lastSequenceDelivered + 1;  } /* while (...) */  return(ret);}static unsigned long mapTarray[6][10000];static int mapTat = 0;void SCTP_handleDataPortion(struct SCTP *m,		       struct sctpChunkDesc *dchk,		       struct SCTP_association *asoc,		       int sz,		       int netNum,		       unsigned char tos,		       int inadrIdx){  /* This handles all the things associated with inbound   * data chunks.    */  int i,endOfUse;  u_long gapSz;  u_long tmp;  u_short stmp;  struct sctpDataPart *dp;  struct SCTP_transmitOnQueue *tmit;   /* This may be rash, depending on if in the shutdown   * state you want the peers datagrams, but in this   * implemenation once you go shutdown you don't care   * what your peer sends you. with a simple change   * this could be fixed.   */  if(((asoc->state&SCTP_STATE_MASK) != SCTP_STATE_OPEN) &&     ((asoc->state&SCTP_STATE_MASK) != SCTP_STATE_SHUTDOWN)     ){    /* data chunk is silently discarded.. */    SCTPdebugPrint(m,"El yucko. not open! state=%d\n",asoc->state);    return;  }else if((asoc->state&SCTP_STATE_MASK) == SCTP_STATE_SHUTDOWN){    /* setup to SACK if in the shutdown state */    asoc->needToAck = 2;      }  dp = (struct sctpDataPart *)((u_long)dchk + sizeof(struct sctpChunkDesc));  /* If it is NEW data and my rwnd is 0, don't let the data in */#ifdef STRICK_RWND_ENFORCEMENT  if((asoc->myRwnd == 0) &&      (compare_with_wrap(ntohl(dp->TSN),			asoc->highestTSNinside,			MAX_TSN))     ){    SCTPdebugPrint(m,"No room at the inn tsn:%x higest in array:%x\n",		   ntohl(dp->TSN),asoc->highestTSNinside);    return;  }#endif  /* un-network all integers */  stmp = (u_short)(ntohs(dchk->chunkLength));  dchk->chunkLength = stmp;  tmp = (u_long)(ntohl(dp->TSN));  dp->TSN = tmp;  stmp = (u_short)(ntohs(dp->streamId));  dp->streamId = stmp;  stmp = (u_short)(ntohs(dp->sequence));  dp->sequence = stmp;  tmp = (u_long)(ntohl(dp->payloadtype));  dp->payloadtype = tmp;  /* for tracing purpose only */  mappedArray[0][mapped] = dp->sequence;  SCTPdebugPrint(m,"data chunk - TSN:%x STRM:%x SEQ#:%x\n",		 dp->TSN,dp->streamId,dp->sequence);  /* process ECN staff */  if(asoc->ECN_Allowed){    if((tos & SCTP_CE_BIT) == SCTP_CE_BIT){      struct sctpECN_echo *echo;      /* tos shows a CE indication, save the TSN */      asoc->lastEcho_TSN = dp->TSN;      if(asoc->ECN_echo == NULL){	asoc->ECN_echo = w_calloc(m,1, sizeof(struct sctpECN_echo));	echo = (struct sctpECN_echo *)asoc->ECN_echo;	if(echo != NULL){	  /* fill it in */	  echo->uh.chunkID = SCTP_ECN_ECHO;	  echo->uh.chunkFlg = 0;	  echo->uh.chunkLength = htons(sizeof(struct sctpECN_echo));	  echo->Lowest_TSN = htonl(dp->TSN);	}      }else{	/* update the seq number */	echo = (struct sctpECN_echo *)asoc->ECN_echo;	echo->Lowest_TSN = htonl(dp->TSN);      }    }  }  /***********************************************************   * 1) check TSN range and update unacked TSN mapping array    *  - every TSN on the array is either missing or unacked   *  - I only need to update the status of the TSN in the array   *  - if the TSN is out of range, I simply drop it. this should   *    be a rare case and the sender will retrans anyway.   *  - the SACK sending routine will advance the mapping array   *  - not sure if this implemenationis robust enough to   *    handle sequence number wraps (hint hint :-)   ***********************************************************/  /* If the new data is equal to or behind the current cumTSN, it's dup.   * We record it here and will report the dup later.   */  if(compare_with_wrap(asoc->mappingArrayHighestTSN, dp->TSN, MAX_TSN) ||     (asoc->mappingArrayHighestTSN == dp->TSN)) {    asoc->pegs[SCTP_DUPTSN_RECVD]++;    if(asoc->numduptsns < SCTP_MAX_DUP_TSNS){      /* record it for the next sack */      asoc->dupTsns[asoc->numduptsns] = htonl(dp->TSN);      asoc->numduptsns++;    }    asoc->needToAck = 2;    SCTPdebugPrint(m,"Droped a dup TSN highest=%x TSN=%x\n",		   asoc->mappingArrayHighestTSN,dp->TSN);    /* for tracing purpose only */    mappedArray[1][mapped] = 2;    mapped++;    if(mapped == 9999){      mapped = 0;    }    return;  }  /* Find out if the dp is too far advanced from current cumTSN,    * if so, we will drop it too.   */  if(dp->TSN >= asoc->mappingArrayHighestTSN) {    gapSz = dp->TSN - asoc->mappingArrayHighestTSN;  } else {    /* try to prevent underflow here */    gapSz = dp->TSN + (MAX_TSN - asoc->mappingArrayHighestTSN) + 1;  }  if(gapSz > asoc->mappingArraySz) {    /* out of range, too questionable. better to drop it silently */    SCTPdebugPrint(m,"TSN out of range (gapSz=%x), droped highest=%x TSN=%x\n",		   gapSz,asoc->mappingArrayHighestTSN,dp->TSN);    /* for tracing purpose only */    mappedArray[1][mapped] = 1;    mapped++;    if(mapped == 9999){      mapped = 0;    }    return;  }  /* now gapSz must be btw 1 to arraySize */  /* check if this is a dup data in a received fragment */  if(asoc->mappingArray[gapSz-1] == 1) {    SCTPdebugPrint(m,"dup TSN in frag (gapSz=%x), droped highest=%x TSN=%x\n",		   gapSz,asoc->mappingArrayHighestTSN, dp->TSN);    asoc->pegs[SCTP_DUPTSN_RECVD]++;    if(asoc->numduptsns < SCTP_MAX_DUP_TSNS){      /* record it for the next sack */      asoc->dupTsns[asoc->numduptsns] = htonl(dp->TSN);      asoc->numduptsns++;    }    /* set this to 2 so that we will force out     * a SACK at the end of processing this DG     */    asoc->needToAck = 2;    /* for tracing purpose only */    mappedArray[1][mapped] = 5;    mapped++;    if(mapped == 9999){      mapped = 0;    }    return;  }  /* 1a) Allocate memory and copy in the data */  tmit = (struct SCTP_transmitOnQueue *)     malloc (sizeof(struct SCTP_transmitOnQueue));  if(tmit == NULL) {    printf("out of mem...\n");    /* for tracing purpose only */    mappedArray[1][mapped] = 3;    mapped++;    if(mapped == 9999){      mapped = 0;    }    return;  }  tmit->toAddr = inadrIdx;  tmit->next = tmit->prev = NULL;  tmit->doingFastRetransmit = 0;  tmit->streamNumber = dp->streamId;  tmit->streamSeq = dp->sequence;  tmit->asoc = asoc;  tmit->whichNet = netNum;  tmit->TSN_seq = dp->TSN;  tmit->payloadtype = dp->payloadtype;  tmit->sent = SCTP_DATAGRAM_INBOUND;  tmit->sndCount = 0;  tmit->sent_rcv_Time.tv_sec = 0;  tmit->sent_rcv_Time.tv_nsec = 0;  tmit->rcvFlags = dchk->chunkFlg;  tmit->toAddr = inadrIdx;  tmit->sizeOfTmit = dchk->chunkLength -    sizeof(struct sctpChunkDesc) -    sizeof(struct sctpDataPart);  if(tmit->sizeOfTmit> 0) {    if((tmit->data = w_malloc(m,tmit->sizeOfTmit)) == NULL) {      printf("out of mem...\n");      w_free(m,tmit);      /* for tracing purpose only */      mappedArray[1][mapped] = 4;      mapped++;      if(mapped == 9999){	mapped = 0;      }      return;    }    memcpy(tmit->data,	   (char *)((u_long)dp +sizeof(struct sctpDataPart)),	   tmit->sizeOfTmit);  }  SCTPdebugPrint(m,"Ok data chunk good and alloced tmit to address %x\n",		 (u_int)tmit);  SCTPdebugPrint(m,"Marking map[%d] to 1\n", gapSz-1);  asoc->mappingArray[gapSz-1] = 1;  SCTPdebugPrint(m,"(gapSz:%d + mappingArrayHigestTSN:0x%x) > highest:%x?\n",		 gapSz,asoc->mappingArrayHighestTSN,asoc->highestTSNinside);  if(compare_with_wrap((gapSz+asoc->mappingArrayHighestTSN),asoc->highestTSNinside,MAX_TSN)){    asoc->highestTSNinside = gapSz + asoc->mappingArrayHighestTSN;    SCTPdebugPrint(m,"Yep, set in the new highest is 0x%x\n",asoc->highestTSNinside);  }  /**************************************/  /* 3) slide the arrival bitmap array  */  /**************************************/  /*   * this can be done much more efficiently with   * some sort of a circular buffer if performace   * is a concerned, or maybe only once   * per inbound datagram.   */  if(asoc->highestTSNinside >= asoc->mappingArrayHighestTSN){    /* no wrap inside */    endOfUse = asoc->highestTSNinside - asoc->mappingArrayHighestTSN;  }else{    endOfUse = asoc->highestTSNinside + (MAX_TSN - asoc->mappingArrayHighestTSN) + 1;  }  SCTPdebugPrint(m,"End of use is %d\n",endOfUse);  /* for tracing purpose only */  mapTarray[1][mapTat] = asoc->mappingArrayHighestTSN;  /* advance the highest consecutive TSN */  for(i=0; i<asoc->mappingArraySz; i++){    if(asoc->mappingArray[i] == 0)       break;    ++(asoc->mappingArrayHighestTSN);  }  /* for tracing purpose only */  mapTarray[0][mapTat] = tmit->TSN_seq;  mapTarray[2][mapTat] = asoc->highestTSNinside;  mapTarray[3][mapTat] = endOfUse;  mapTarray[4][mapTat] = i;  mapTarray[5][mapTat] = asoc->mappingArrayHighestTSN;  mapTat++;  if(mapTat == 9999)    mapTat = 0;  SCTPdebugPrint(m,"Adjusted cumTSN is %x move map up:%d\n",		 (u_int)asoc->mappingArrayHighestTSN,i);  if(i>0) {    if(endOfUse == i){      SCTPdebugPrint(m,"Got them all zap %d\n",endOfUse);      memset(asoc->mappingArray,0,endOfUse);    }else if(i){      SCTPdebugPrint(m,"memmove %x to %x %d\n",		     (u_int)asoc->mappingArray,		     (u_int)&(asoc->mappingArray[i]),		     (endOfUse-i));      memmove((void *)asoc->mappingArray, (void *)(&asoc->mappingArray[i]), 	      (endOfUse - i));      SCTPdebugPrint(m,"memset %x for %d\n",		     (u_int)(&asoc->mappingArray[(endOfUse-i)]),i);      memset((void *)(&asoc->mappingArray[(endOfUse-i)]),0,i);    }else{      SCTPdebugPrint(m,"Nothing has changed in the map\n");    }  }  /* for tracing purpose only */  mappedArray[1][mapped] = 6;  SCTPdebugPrint(m,"mappingTSN:%x lastAcked:%x point a\n",		 (u_int)asoc->mappingArrayHighestTSN,		 (u_int)asoc->lastAckedSeq);  /********************************************/  /* 4) put the data to the appropriate place */  /********************************************/  SCTPdebugPrint(m,"Now inqueue the data for reading netnum:%d inadrIdx:%d\n",		 netNum,inadrIdx);  if(SCTPinqueueData(m, asoc, dchk, sz, netNum, inadrIdx,tmit) >= 0){    /* lower my buffer space for the inbound chunk */    asoc->myRwnd -= (sz-(sizeof(struct sctpChunkDesc)+sizeof(struct sctpDataPart)));    if(asoc->myRwnd < 0){      asoc->myRwnd = 0;    }    /* for tracing purpose only */    mappedArray[1][mapped] = 7;    mapped++;    if(mapped == 9999){      mapped = 0;    }  }else{    /* for tracing purpose only */    mapped++;    if(mapped == 9999){      mapped = 0;    }  }  SCTPdebugPrint(m,"mappingTSN:%x lastAcked:%x point b\n",		 (u_int)asoc->mappingArrayHighestTSN,		 (u_int)asoc->lastAckedSeq);  return;}voidprintMappedArrays(struct SCTP_association *asoc,char *file){  FILE *io;  int at,i;  io = fopen(file,"w+");  if(io == NULL){    perror("Can't open file");    return;  }  if(asoc != NULL){    struct SCTP_transmitOnQueue *tp1;    int i;    fprintf(io,	    "Assoc stream 0 last delivered is %d\n",	    asoc->inbound.lastSequenceDelivered);    tp1 = asoc->inbound.inqueue;    i = 0;    while(tp1 != NULL){      fprintf(io,"%d:TSN:%d StrSeq:%d ",	     i,	     (int)tp1->TSN_seq,	     tp1->streamSeq);      if((i % 2) == 0){	fprintf(io,"\n");      }      tp1 = tp1->next;      i++;    }    fprintf(io,"\n");  }  fprintf(io,"****************************************\n");  fprintf(io,"Mapped T array\n");  fprintf(io,"****************************************\n");  for(i=0;i<10000;i++){    fprintf(io,"->TSN:%d base:%d highest:%d end:%d markAt:%d newbase:%d\n",	    (int)mapTarray[0][i],	    (int)mapTarray[1][i],	    (int)mapTarray[2][i],	    (int)mapTarray[3][i],	    (int)mapTarray[4][i],	    (int)mapTarray[5][i]	    );  }  fprintf(io,"****************************************\n");  fprintf(io,"Mapped array\n");  fprintf(io,"****************************************\n");  for(i=0,at=0;i<1000;i++,at+=10){    fprintf(io,"%d:%d %d:%d %d:%d %d:%d %d:%d %d:%d %d:%d %d:%d %d:%d %d:%d\n",	    (int)mappedArray[0][at],(int)mappedArray[1][at],	    (int)mappedArray[0][at+1],(int)mappedArray[1][at+1],	    (int)mappedArray[0][at+2],(int)mappedArray[1][at+2],	    (int)mappedArray[0][at+3],(int)mappedArray[1][at+3],	    (int)mappedArray[0][at+4],(int)mappedArray[1][at+4],	    (int)mappedArray[0][at+5],(int)mappedArray[1][at+5],	    (int)mappedArray[0][at+6],(int)mappedArray[1][at+6],	    (int)mappedArray[0][at+7],(int)mappedArray[1][at+7],	    (int)mappedArray[0][at+8],(int)mappedArray[1][at+8],	    (int)mappedArray[0][at+9],(int)mappedArray[1][at+9]);  }  fprintf(io,"****************************************\n");  fprintf(io,"Inqueue array\n");  fprintf(io,"****************************************\n");  for(i=0,at=0;i<1000;i++,at+=10){    fprintf(io,"%d(%d:%d) %d(%d:%d) %d(%d:%d) %d(%d:%d) %d(%d:%d)\n",	    (int)inqueueArray[0][at],inqueueArray[1][at],inqueueArray[2][at],	    (int)inqueueArray[0][at+1],(int)inqueueArray[1][at+1],	    (int)inqueueArray[2][at+1],	    (int)inqueueArray[0][at+2],(int)inqueueArray[1][at+2],	    (int)inqueueArray[2][at+2],	    (int)inqueueArray[0][at+3],(int)inqueueArray[1][at+3],	    (int)inqueueArray[2][at+3],	    (int)inqueueArray[0][at+4],(int)inqueueArray[1][at+4],	    (int)inqueueArray[2][at+4]);    fprintf(io,"%d(%d:%d) %d(%d:%d) %d(%d:%d) %d(%d:%d) %d(%d:%d)\n",	    (int)inqueueArray[0][at+5],	    (int)inqueueArray[1][at+5],(int)inqueueArray[2][at+5],	    (int)inqueueArray[0][at+6],(int)inqueueArray[1][at+6],	    (int)inqueueArray[2][at+6],	    (int)inqueueArray[0][at+7],(int)inqueueArray[1][at+7],	    (int)inqueueArray[2][at+7],	    (int)inqueueArray[0][at+8],(int)inqueueArray[1][at+8],	    (int)inqueueArray[2][at+8],	    (int)inqueueArray[0][at+9],	    (int)inqueueArray[1][at+9],(int)inqueueArray[2][at+9]);  }  fprintf(io,"****************************************\n");  fprintf(io,"delivery array\n");  fprintf(io,"****************************************\n");  for(at=0;at<10000;at+=4){    fprintf(io,"Delivered:%d %d %d %d\n",	    (int)deliveryArray[at],	    (int)deliveryArray[at+1],	    (int)deliveryArray[at+2],	    (int)deliveryArray[at+3]);  }  fprintf(io,"****************************************\n");  fprintf(io,"rwnd array\n");  fprintf(io,"****************************************\n");  for(i=0,at=0;i<1000;i++,at+=10){    fprintf(io," %x:%d(t%d - f%d/%d q:%d) %x:%d(t%d - f%d/%d q:%d)\n",	    (u_int)rwndarray[0][at],	    (int)rwndarray[1][at],	    (int)rwndarray[2][at],	    (int)rwndarray[3][at],	    (int)rwndarray[4][at],	    (int)rwndarray[5][at],	    (u_int)rwndarray[0][at+1],	    (int)rwndarray[1][at+1],	    (int)rwndarray[2][at+1],	    (int)rwndarray[3][at+1],	    (int)rwndarray[4][at+1],	    (int)rwndarray[5][at+1]	    );    fprintf(io," %x:%d(t%d - f%d/%d q:%d) %x:%d(t%d - f%d/%d q:%d)\n",	    (u_int)rwndarray[0][at+2],	    (int)rwndarray[1][at+2],	    (int)rwndarray[2][at+2],	    (int)rwndarray[3][at+2],	    (int)rwndarray[4][at+2],	    (int)rwndarray[5][at+2],	    (u_int)rwndarray[0][at+3],	    (int)rwndarray[1][at+3],	    (int)rwndarray[2][at+3],	    (int)rwndarray[3][at+3],	    (int)rwndarray[4][at+3],	    (int)rwndarray[5][at+3]	    );    fprintf(io," %x:%d(t%d - f%d/%d q:%d) %x:%d(t%d - f%d/%d q:%d)\n", 	    (u_int)rwndarray[0][at+4],	    (int)rwndarray[1][at+4],	    (int)rwndarray[2][at+4],	    (int)rwndarray[3][at+4],	    (int)rwndarray[4][at+4],	    (int)rwndarray[5][at+4],	    (u_int)rwndarray[0][at+5],	    (int)rwndarray[1][at+5],	    (int)rwndarray[2][at+5],	    (int)rwndarray[3][at+5],	    (int)rwndarray[4][at+5],	    (int)rwndarray[5][at+5]	    );    fprintf(io," %x:%d(t%d - f%d/%d q:%d) %x:%d(t%d - f%d/%d q:%d)\n",	    (u_int)rwndarray[0][at+6],	    (int)rwndarray[1][at+6],	    (int)rwndarray[2][at+6],		    (int)rwndarray[3][at+6],	    (int)rwndarray[4][at+6],	    (int)rwndarray[5][at+6],	    (u_int)rwndarray[0][at+7],	    (int)rwndarray[1][at+7],	    (int)rwndarray[2][at+7],	    (int)rwndarray[3][at+7],	    (int)rwndarray[4][at+7],	    (int)rwndarray[5][at+7]	    );    fprintf(io," %x:%d(t%d - f%d/%d q:%d) %x:%d(t%d - f%d/%d q:%d)\n",	    (u_int)rwndarray[0][at+8],	    (int)rwndarray[1][at+8],	    (int)rwndarray[2][at+8],	    (int)rwndarray[3][at+8],	    (int)rwndarray[4][at+8],	    (int)rwndarray[5][at+8],	    (u_int)rwndarray[0][at+9],	    (int)rwndarray[1][at+9],	    (int)rwndarray[2][at+9],	    (int)rwndarray[3][at+9],	    (int)rwndarray[4][at+9],	    (int)rwndarray[5][at+9]	    );  }  for(i=0;i<10000;i++){    if(fretran[i]){      fprintf(io,"fretran[%d]:%d\n",	      i,(int)fretran[i]);    }  }  fclose(io);}