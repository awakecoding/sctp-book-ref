#include <sys/types.h>#ifdef FREEBSD#include <machine/endian.h>#endif/* for solaris */#ifdef SOLARIStypedef uint32_t u_int32_t;typedef uint8_t u_int8_t;#endif/* * Ethernet CRC32 polynomials (big- and little-endian verions). */#define	ETHER_CRC_POLY_LE	0xedb88320#define	ETHER_CRC_POLY_BE	0x04c11db6/* *  little-endian CRC-32 code,  table lookup, not unrolled. */u_int32_tether_crc32_le(const u_int8_t *buf, size_t len){	static const u_int32_t crctab[] = {		0x00000000, 0x1db71064, 0x3b6e20c8, 0x26d930ac,		0x76dc4190, 0x6b6b51f4, 0x4db26158, 0x5005713c,		0xedb88320, 0xf00f9344, 0xd6d6a3e8, 0xcb61b38c,		0x9b64c2b0, 0x86d3d2d4, 0xa00ae278, 0xbdbdf21c	};	u_int32_t crc;	int i;	crc = 0xffffffffU;	/* initial value */	for (i = 0; i < len; i++) {		crc ^= buf[i];		crc = (crc >> 4) ^ crctab[crc & 0xf];		crc = (crc >> 4) ^ crctab[crc & 0xf];	}	return (crc);}/* *  little-endian CRC-32 code,  table lookup, not unrolled. */u_int32_tether_crc32_le_fast(const u_int8_t *buf, size_t len){	static const u_int32_t crctab[] = {		0x00000000, 0x1db71064, 0x3b6e20c8, 0x26d930ac,		0x76dc4190, 0x6b6b51f4, 0x4db26158, 0x5005713c,		0xedb88320, 0xf00f9344, 0xd6d6a3e8, 0xcb61b38c,		0x9b64c2b0, 0x86d3d2d4, 0xa00ae278, 0xbdbdf21c	};	u_int32_t crc;	u_int32_t *bp;	int i;	crc = 0xffffffffU;	/* initial value */	/* align */	for (i =  0; ((u_int)(buf+i) & 0x03) != 0 && i < len; i++) {		crc ^= buf[i];		crc = (crc >> 4) ^ crctab[crc & 0xf];		crc = (crc >> 4) ^ crctab[crc & 0xf];	}	/* Process aligned 32-bit chunks, 4 bits at a time */	for (bp = (u_int32_t*) (buf+i); i+4 < len; i += 4) {		u_int32_t w = *bp++;		crc ^= (w & 0xFF);		crc = (crc >> 4) ^ crctab[crc & 0xf];		crc = (crc >> 4) ^ crctab[crc & 0xf];		crc ^= ((w >>8) & 0xFF);		crc = (crc >> 4) ^ crctab[crc & 0xf];		crc = (crc >> 4) ^ crctab[crc & 0xf];		crc ^= ((w >> 16) & 0xFF);		crc = (crc >> 4) ^ crctab[crc & 0xf];		crc = (crc >> 4) ^ crctab[crc & 0xf];		crc ^= ((w >> 24) & 0xFF);		crc = (crc >> 4) ^ crctab[crc & 0xf];		crc = (crc >> 4) ^ crctab[crc & 0xf];	}	/* handle any trailing bytes */	for (; i < len; i++) {		crc ^= buf[i];		crc = (crc >> 4) ^ crctab[crc & 0xf];		crc = (crc >> 4) ^ crctab[crc & 0xf];	}	return (crc);}/* *  big-endian CRC-32 code, no table lookup */u_int32_tether_crc32_be(const u_int8_t *buf, size_t len){	u_int32_t c, crc, carry;	size_t i, j;	crc = 0xffffffffU;	/* initial value */	for (i = 0; i < len; i++) {		c = buf[i];		for (j = 0; j < 8; j++) {			carry = ((crc & 0x80000000U) ? 1 : 0) ^ (c & 0x01);			crc <<= 1;			c >>= 1;			if (carry)				crc = (crc ^ ETHER_CRC_POLY_BE) | carry;		}	}	return (crc);}