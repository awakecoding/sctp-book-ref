/* SCTP reference Implementation Copyright (C) 2001 Cisco Systems Inc.This file is part of the SCTP reference ImplementationVersion:4.0.5$Header: /home/sourceTree/src/sctp/user/adler32.c,v 1.2 2001/07/24 11:52:39 randall Exp $The SCTP reference implementation  is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published bythe Free Software Foundation; either version 2, or (at your option)any later version.the SCTP reference implementation  is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of                ************************MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See theGNU Library General Public License for more details.You should have received a copy of the GNU Library General Public Licensealong with GNU CC; see the file COPYING.  If not, write tothe Free Software Foundation, 59 Temple Place - Suite 330,Boston, MA 02111-1307, USA.  Please send any bug reports or fixes you make to one of the following emailaddresses:rrs@cisco.comkmorneau@cisco.comqxie1@email.mot.comAny bugs reported given to us we will try to fix... any fixes shared willbe incorperated into the next SCTP release.There are still LOTS of bugs in this code... I always run on the motto"it is a wonder any code ever works :)"*/#include <sctp.h>#include <sctputil.h>/* This is an entry point for external calls * Define this function in the header file. This is * direct from rfc1950, ... * The following C code computes the Adler-32 checksum of a data buffer.   It is written for clarity, not for speed.  The sample code is in the   ANSI C programming language. Non C users may find it easier to read   with these hints:      &      Bitwise AND operator.      >>     Bitwise right shift operator. When applied to an             unsigned quantity, as here, right shift inserts zero bit(s)             at the left.      <<     Bitwise left shift operator. Left shift inserts zero             bit(s) at the right.      ++     "n++" increments the variable n.      %      modulo operator: a % b is the remainder of a divided by b. * Well, the above is a bit of a lie, I have optimized this a small * tad, but I have commented the original lines below */#define BASE 65521 /* largest prime smaller than 65536 *//* Performance work as shown this pig to be the * worst CPU wise guy. I have done what I could think * of on my flight to Austrialia but I am sure some * clever assembly could speed this up, but of * course this would require the dreaded #ifdef's for * architecture. If you can speed this up more, pass * it back and we will incorporate it :-) */unsigned int update_adler32(unsigned int adler,			     const unsigned char *buf, int len){  unsigned long s1 = adler & 0xffff;  unsigned long s2 = (adler >> 16) & 0xffff;  int n;  for (n = 0; n < len; n++,buf++) {    /* s1 = (s1 + buf[n]) % BASE */    /* first we add */    s1 = (s1 + *buf);    /* now if we need to, we do a mod by     * subtracting. It seems a bit faster     * since I really will only ever do     * one subtract at the MOST, since buf[n]     * is a max of 255.     */    if(s1 >= BASE){      s1 -= BASE;    }    /* s2 = (s2 + s1) % BASE */    /* first we add */    s2 = (s2 + s1);    /* again, it is more efficent (it seems) to      * subtract since the most s2 will ever be     * is (BASE-1 + BASE-1) in the worse case.     * This would then be (2 * BASE) - 2, which     * will still only do one subtract. On Intel     * this is much better to do this way and     * avoid the divide. Have not -pg'd on      * sparc.     */    if(s2 >= BASE){      /*      s2 %= BASE;*/      s2 -= BASE;    }  }  /* Return the adler32 of the bytes buf[0..len-1] */  return ((unsigned int)(s2 << 16) + s1);}unsigned int count_crc(const unsigned char *ptr,			unsigned short  count){  /*    Update a running Adler-32 checksum with the bytes buf[0..len-1]    and return the updated checksum. The Adler-32 checksum should be    initialized to 1.    */  unsigned int adler = 1L;  adler = update_adler32(adler, ptr, count);  return(adler);}