/* SCTP reference Implementation Copyright (C) 2001 Cisco And MotorolaThis file is part of the SCTP reference ImplementationVersion:4.0.5$Header: /home/sourceTree/src/sctp/user/sctp.c,v 1.67 2001/07/25 18:47:55 randall Exp $The SCTP reference implementation  is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published bythe Free Software Foundation; either version 2, or (at your option)any later version.the SCTP reference implementation  is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of                ************************MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See theGNU Library General Public License for more details.You should have received a copy of the GNU Library General Public Licensealong with GNU CC; see the file COPYING.  If not, write tothe Free Software Foundation, 59 Temple Place - Suite 330,Boston, MA 02111-1307, USA.  Please send any bug reports or fixes you make to one of the following emailaddresses:rrs@cisco.comkmorneau@cisco.comqxie1@email.mot.comAny bugs reported given to us we will try to fix... any fixes shared willbe incorperated into the next SCTP release.There are still LOTS of bugs in this code... I always run on the motto"it is a wonder any code ever works :)"*/#include <sctp.h>/* now get all the function declarations in */#include <sctputil.h>#include <sctpsenders.h>#include <sctpoutofblue.h>#include <sctpinitiate.h>#include <sctpinbound.h>#include <sctphandleto.h>#include <sctpaddipext.h>#include <sctpmtu.h>#include <sctprelreq.h>#include <stdio.h>#include <stdlib.h>#include <unistd.h>#include <sys/types.h>#include <netinet/in_systm.h>#include <netinet/in.h>#include <netinet/ip.h>#include <arpa/inet.h>#include <sys/ioctl.h>#include <sys/stat.h>#include <stdarg.h>#include <signal.h>#include <fcntl.h>#include <sys/socket.h>#if !(defined( LINUX ) || defined ( TRU64 ) || defined(AIX))#include <sys/sockio.h>#endif#include <time.h>#include <string.h>#ifdef LINUX#include <stropts.h>#endif#include <net/if.h>#include <errno.h>#include <netinet/ip_icmp.h>#include <adler32.h>#include <modAdler32.h>#include <crc32.h>#include <poll.h>struct SCTP *sctpINITIALIZE(void (*tmr)(struct SCTP *,void *,int,int,int),	       void (*changeEventMask)(int,int),	       void (*notification)(int,char*,int),	       void (*gettime)(struct timespec *),	       unsigned short port){  struct SCTP *m;  int i;#ifdef AIX  size_t length;#else  int length;#endif  struct timespec timenow;  long seed;  char *env;  seed = 0;  /* get the generic structure to track the   * raw IP socket and base timing info   */  m = malloc(sizeof(struct SCTP));  if(m == NULL){    errno = ENOMEM;    return(NULL);  }  memset(m,0,sizeof(struct SCTP));  /* try to turn on MTU discovery, this will   * fail if we are not ROOT on a unix machine.   */#ifdef DEBUG_ON  {    char fileNamebuf[200];    m->pid = getpid();    sprintf(fileNamebuf,"/usr/tmp/sctpclient.%d.dbg",m->pid);    m->debugfd = SCTPsafefopen(fileNamebuf);  }#else  m->debugfd = NULL;#endif  /* Gather addresses will change this but set it   * up high incase we support the probing via the   * getmtu ioctl.   */  m->max_mtu = SCTP_MAX_READBUFFER;  m->preferedRemPrimary = NULL;  m->usingTheDeamon = 1;  m->defCookieLife = SCTP_DEFAULT_COOKIE_LIFE;  m->disableV6 = 0;  m->hasV6 = 1;  env = getenv("RANDOMLOSS");  if(env != NULL){    m->randomLoss = (int)strtol(env,NULL,0);  }else{    m->randomLoss = 0;  }  /* open and bind a socket to    * the specified port if requesting   * a specific port verifiy.   */  m->fd = socket(AF_INET6, SOCK_DGRAM, IPPROTO_SCTP);  if(m->fd >= 0){    printf("WOW! The kernel SCTP socket V6 is present!\n");    m->usingTheDeamon = 0;  }else{    /* try no IPv6 */    m->hasV6 = 0;    m->fd = socket(AF_INET, SOCK_DGRAM, IPPROTO_SCTP);    if(m->fd >= 0){      printf("WOW! The kernel SCTP socket V4 only is present!\n");      m->usingTheDeamon = 0;    }  }  /* lets be optimistic */  if(m->usingTheDeamon){    m->fd = socket(AF_INET, SOCK_DGRAM, 0);    if(m->fd == -1){      free(m);      return(NULL);    }  }  if(m->hasV6){    struct sockaddr_in6 inAddr6,myAddr6;    memset(&inAddr6,0,sizeof(inAddr6));    memset(&myAddr6,0,sizeof(myAddr6));    inAddr6.sin6_port = htons(port);    myAddr6.sin6_port = 0;    inAddr6.sin6_family = AF_INET6;    myAddr6.sin6_family = AF_INET6;#ifdef USES_BSD_4_4_SOCKET    inAddr6.sin6_len = sizeof(struct sockaddr_in6);    myAddr6.sin6_len = sizeof(struct sockaddr_in6);#endif    if(bind(m->fd,(struct sockaddr *)&inAddr6, sizeof(inAddr6)) < 0){      close(m->fd);      return(NULL);    }    length = sizeof(myAddr6);    if(getsockname(m->fd,(struct sockaddr *)&myAddr6,&length) < 0){      close(m->fd);      free(m);      return(NULL);    }    if(port){      /* User wanted a specific port. Verify... */      if(htons(port) != myAddr6.sin6_port){	close(m->fd);	errno = EADDRINUSE;	free(m);	return(NULL);      }    }    printf("My port is %d\n",ntohs(myAddr6.sin6_port));    m->port = myAddr6.sin6_port;  }else{    struct sockaddr_in inAddr,myAddr;    memset(&inAddr,0,sizeof(inAddr));    memset(&myAddr,0,sizeof(myAddr));    inAddr.sin_port = htons(port);    myAddr.sin_port = 0;    inAddr.sin_family = AF_INET;    myAddr.sin_family = AF_INET;#ifdef USES_BSD_4_4_SOCKET    inAddr.sin_len = sizeof(struct sockaddr_in);    myAddr.sin_len = sizeof(struct sockaddr_in);#endif    if(bind(m->fd,(struct sockaddr *)&inAddr, sizeof(inAddr)) < 0){      close(m->fd);      return(NULL);    }    length = sizeof(myAddr);    if(getsockname(m->fd,(struct sockaddr *)&myAddr,&length) < 0){      close(m->fd);      free(m);      return(NULL);    }    if(port){      /* User wanted a specific port. Verify... */      if(htons(port) != myAddr.sin_port){	close(m->fd);	errno = EADDRINUSE;	free(m);	return(NULL);      }    }    printf("My port is %d\n",ntohs(myAddr.sin_port));    m->port = myAddr.sin_port;  }  /* put in fcn pointers */  m->timer =  tmr;  m->changeMask = changeEventMask;  m->notify = notification;  m->getTime = gettime;  m->lastDeamon = 0;  /* setup the base timeout information */  m->baseTimeoutSecs[SCTP_TIMER_SEND] = SCTP_SEND_SEC;  m->baseTimeoutNSecs[SCTP_TIMER_SEND] =SCTP_SEND_NSEC;  m->baseTimeoutSecs[SCTP_TIMER_INIT] = SCTP_INIT_SEC;  m->baseTimeoutNSecs[SCTP_TIMER_INIT] = SCTP_INIT_NSEC;  m->baseTimeoutSecs[SCTP_TIMER_RECV] = SCTP_RECV_SEC;  m->baseTimeoutNSecs[SCTP_TIMER_RECV] = SCTP_RECV_NSEC;  m->baseTimeoutSecs[SCTP_TIMER_SHUTDOWN] = SCTP_SHUTDOWN_SEC;  m->baseTimeoutNSecs[SCTP_TIMER_SHUTDOWN] = SCTP_SHUTDOWN_NSEC;  m->baseTimeoutSecs[SCTP_TIMER_HEARTBEAT] =SCTP_HB_SEC;   m->baseTimeoutNSecs[SCTP_TIMER_HEARTBEAT] =SCTP_HB_NSEC;   m->baseTimeoutSecs[SCTP_TIMER_PMTU] = SCTP_DEF_PMTU_RAISE;  m->baseTimeoutNSecs[SCTP_TIMER_PMTU] = 0;  /* Max times I will send before we consider someone dead */  m->maxInitTimes = SCTP_DEF_MAX_INIT;  m->maxSendTimes = SCTP_DEF_MAX_SEND;  m->maxBurst = SCTP_DEF_MAX_BURST;  m->preOpenStreamCount = 1;  for(i=0; i< MAX_UNRELSTREAM_SETS *2; i++) {    m->unrelStreamSets[i] = -1; /* all cleared */  }  /* this might need to change */  m->currentOut = 0;  m->maxWindow = 0;  m->maxMsgSiz = SCTP_DEFAULT_MAXMSGREASM;  m->ttl = 255;  m->tos = 0;  m->ipcounter = 1;  m->mtuList = NULL;  m->localNets = NULL;  m->maskList = NULL;  m->broadList = NULL;  m->numberOfNets = 0;    sctpSetRwindowSize(m,SCTP_DEFAULT_MAXWINDOW);  /* this function goes out and gets all the addresses I have */  if(SCTP_gatherAddresses(&m->localNets,			  &m->maskList,			  &m->broadList,			  &m->numberOfNets,			  &m->numberOfNetsAlloced,			  &m->max_mtu,			  &m->mtuList,			  m->fd,			  0)){	/* don't include loopback .. last flag */    /* this returns non-zero for failure */    printf("Gather addresses fails\n");    close(m->fd);    free(m);    return(NULL);  }  SCTPdebugPrint(m,"I received back %d networks that I will use\n",m->numberOfNets);  for(i=0;i<m->numberOfNets;i++){    SCTPdebugPrint(m,"Net[%d]\n",i);    SCTPdebugPrintAddress(m,m->localNets[i]);  }  /* seed random number generator */  m->randomCounter = 1;	  m->storeAt = SCTP_SIGNATURE_SIZE;  {    int rdres,irand;    m->fird = open(SCTP_USE_RANDOM_DEVICE,O_RDONLY);    if(m->fird != -1){       /* Fill the random number pool */       for(irand=0;irand<SCTP_SIGNATURE_SIZE;irand++){         rdres = read(m->fird,(char *)&m->randomNumbers[irand],1);	 if(rdres != 1){		 printf("Sleeping for random\n");		 irand--;		 sleep(10);	 }       }       SCTPdebugPrint(m,"Random Numbers are:\n");       SCTPdebugPrintArry(m,m->randomNumbers,sizeof(m->randomNumbers));    }else{      SCTPdebugPrint(m,		     "Warning:Insecure, can't open random device %d\n",		     errno);      (*m->getTime)(&timenow);      seed = (timenow.tv_sec + (timenow.tv_nsec >> 10)) + ntohs(m->port);      srand48(seed);    }    memset(m->randomStore,0,SCTP_SIGNATURE_SIZE);    SCTPfillRandomStore(m);  }  /* all ready to be read TSN's go in this queue */  m->inqueueLast = m->inqueue = NULL;  /* total number of dg's inqueued to be picked up i.e read */  m->numberInbound = 0;  /* secret key used with cookie */  for(i=0;i<SCTP_NUMBER_OF_SECRETS;i++){    m->secretKey[0][i] = SCTPselectInitialTSN(m);  }  m->lastSecretNumber = m->currentSecretNumber = 0;  m->timeOfSecretChange = timenow.tv_sec;  m->sizeOfACookie = sizeof(struct SCTP_association);  m->sizeOfACookie += SCTP_SIGNATURE_SIZE;  m->allAssoc = HashedTbl_create("All Associations",50);  /* If this fails we are headed for core land   * anyway :) I won't even test it ... let   * the cores fly....   */  m->cookieTime.timerType = SctpTimerTypeNewCookie;  m->cookieTime. running = SCTP_TIMER_IDLE;  m->cookieTime.countOf = 0;  m->cookieTime.timerinfo = NULL;  /* now schedule a timer for the cookie change */  (*m->timer)(m,(void *)&m->cookieTime,SCTP_TIMER_START,SCTP_HOW_LONG_COOKIE_LIVE,0);  /* now I must register with my local SCTP deamon */  if(m->usingTheDeamon){    struct sockaddr_in deamon,from;    int attempts,kapla,ret;#ifdef AIX    size_t lenfrm;#else    int lenfrm;#endif    struct pollfd fds[1];    struct deamonRegister dr;    attempts = 0;    kapla = 0;        fds[0].revents = 0;    fds[0].fd = m->fd;    fds[0].events = POLLIN | POLLPRI;        dr.ver_len = DEAMON_MAGIC_VER_LEN;    dr.tos = 0;    dr.msgType = DEAMON_REGISTER;    dr.pad = 0;    printf("in to register with deamon\n");    while(attempts < SCTP_MAX_ATTEMPTS_AT_DEAMON){      deamon.sin_port = htons(SCTP_DEAMON_PORT);      deamon.sin_family = AF_INET;      deamon.sin_addr.s_addr = htonl(0x7f000001);#ifdef USES_BSD_4_4_SOCKET      deamon.sin_len = sizeof(struct sockaddr_in);#endif      dr.ver_len = DEAMON_MAGIC_VER_LEN;      dr.msgType = DEAMON_REGISTER;      ret = sendto(m->fd,(char *)&dr,		   (sizeof(dr)),		   0,		   (struct sockaddr *)&deamon,		   sizeof(deamon));      ret = poll(fds,1,SCTP_TIMEOUT_IN_POLL_FOR_DEAMON);      if(ret == 0){	/* time-out no response */	attempts++;	continue;      }else if (ret == -1){	printf("got erro on poll errno:%d\n",	       errno);	continue;      }      lenfrm = sizeof(from);      ret = recvfrom(m->fd,(char *)&dr,sizeof(dr),0,		     (struct sockaddr *)&from,&lenfrm);      if(ret < 0){	/* huh */#ifdef LINUX	/* linux has this error concept to give you back a	 * failed read with errno set if the local peer	 * is not up. Use it to announce un-available deamon	 * and ask for correction, then sleep 20 seconds.	 */	if(errno == ECONNREFUSED){	  printf("Deamon is NOT up, please start it, I will wait 20 secs\n");	  ret = poll(fds,1,20000);	  continue;	}#endif	attempts++;	continue;      }      if(from.sin_family == AF_INET){	if(from.sin_port != deamon.sin_port){	  /* someone else sent me some garbage */	  printf("not from the deamon %d vs %d got:%d bytes errno:%d\n",		 from.sin_port,deamon.sin_port,ret,errno);	  SCTPdebugPrint(m,"not from the deamon %d vs %d got:%d bytes\n",			 from.sin_port,deamon.sin_port,ret);	  SCTPdebugPrintArry(m,(char *)&dr,sizeof(dr));	  continue;	}      }      if(dr.ver_len != DEAMON_MAGIC_VER_LEN){	/* deamon thinks I am up, but hang with it	 * since I do want a response 	 */	printf("no magic number\n");	continue;      }      if(dr.msgType == DEAMON_REGISTER_ACK){	/* got it */	kapla = 1;	printf("Got the response!!!\n");	break;      }    }    if(kapla == 0){	      printf("No deamon, or deamon not responding!\n");      close(m->fd);      exit(0);    }  }  return(m);}intsctpASSOCIATE(struct SCTP *m, struct sockaddr *to, int options){  /* here we need to open the association */  /* It would be nice to allow a list of   * sockaddress from the user that could   * and could not be sent to. With this   * implemenation the user must, after init   * do a add/remove from eligibility.   * If a list were present on would still need to   * record all of the peers addresses, but one could   * pre-set the NOT-AVAILABLE status.   */  int indx;  struct SCTP_association *asoc;  asoc = SCTPfindAssociation(m,to,&indx);  if(asoc != NULL){    errno = EALREADY;    return(-1);  }  SCTPdebugPrint(m,"Associate called to the following:\n");  SCTPdebugPrintAddress(m,to);  asoc = SCTPstartInit(m,to,options);  if(asoc == NULL){      return(-1);  }  return(0);}intsctpTERMINATE(struct SCTP *m, struct sockaddr *s){  /* gracefully terminate an association.   * send a acknowledged shutdown to    * free the association to this   * guy.   */  int indx;  struct SCTP_association *asoc;  SCTPdebugPrint(m,"Called SHUTDOWN ASSOC\n");  asoc = SCTPfindAssociation(m,s,&indx);  if(asoc == NULL){    SCTPdebugPrint(m,"Can't find assoc to SHUTDOWN\n");    errno = ENOENT;    return(-1);  }    /* ok now set the state to shutting down,   * this will prevent further sends.   */  SCTPdebugPrint(m,"Ok set to state shutdown from %d\n",		 asoc->state);  asoc->state |= SCTP_STATE_SHUTDOWN_PEND;  /* FIX:?We may want to add the check of   * the assoc to see if a rcv timer is running   * and we are going to send a E-Ack with gaps.. if   * so we probably should cancel it, and then send   * a Sack ahead of the shutdown below if the condtion   * is true that we will be sending the shutdown.   */  if((asoc->outQueueCount == 0) && (asoc->outqueue == NULL)){    /* all are sent so we can send the shutdown message     * so do so.     */    SCTPdebugPrint(m,"Ok queue is empty send shutdown\n");    SCTPsendAShutdown(m,asoc,0);    asoc->state = SCTP_STATE_SHUTDOWN;    SCTPdebugPrint(m,"STATE SET TO SHUTDOWN\n");    timerWork(m,asoc,SCTP_TIMER_START,SctpTimerTypeShutdown,0);  }else{    SCTPdebugPrint(m,"queue is not empty %d\n",asoc->outQueueCount);  }  /* if we have stuff outstanding we will let the   * normal sending/retran stuff do its   * job and then when the last ack comes in   * it must recognize to call the shutdownSCTP() function   * again by the fact that the state is SCTP_STATE_SHTUDOWN   */  return(0);}intsctpABORT(struct SCTP *m){  /* This ABORT all the existing associations, a little different to   * the ABORT in section 9. But the idea is the same.   * close up this sctp, freeing all   * alloced data.. sending out the   * abort message to all running	   * associations.. dumping any	   * in/out queued messages   */  int whichLan;  struct SCTP_association *asoc,*nasoc;  u_char addrFmt[SCTP_ADDRMAX];  asoc = m->assoc;   while(asoc != NULL){    if((asoc->state != SCTP_STATE_EMPTY) &&        (asoc->numnets) &&       (asoc->hisTag)       ){      /* send this guy a abort */      whichLan = SCTPselectNextLan(m,asoc);      SCTPmakeIntoSock(addrFmt,asoc,whichLan);      SCTPsendAAbort(m,		     asoc,		     (struct sockaddr *)addrFmt,		     asoc->hisTag,0,0);    }    nasoc = asoc->next;    if(asoc->state != SCTP_STATE_EMPTY) {      /* clean up if needed */      SCTPreportAllOutboundLost(m,asoc);      SCTPupperLayerNotification(m,asoc,SCTP_NOTIFY_ASSOC_DOWN,				 (int)addrFmt);      SCTPfreeAssociation(m,asoc);    }    asoc = nasoc;  }  /* de-register with the deamon */  if(m->usingTheDeamon){    struct sockaddr_in deamon,from;    int attempts,kapla,ret;#ifdef	AIX    size_t lenfrm;#else    int lenfrm;#endif    struct pollfd fds[1];    struct deamonRegister dr;    attempts = 0;    kapla = 0;        fds[0].revents = 0;    fds[0].fd = m->fd;    fds[0].events = POLLIN | POLLPRI;        dr.ver_len = DEAMON_MAGIC_VER_LEN;    dr.tos = 0;    dr.msgType = DEAMON_DEREGISTER;    dr.pad = 0;    while(attempts < SCTP_MAX_ATTEMPTS_AT_DEAMON){      deamon.sin_port = htons(SCTP_DEAMON_PORT);      deamon.sin_family = AF_INET;      deamon.sin_addr.s_addr = htonl(0x7f000001);      dr.ver_len = DEAMON_MAGIC_VER_LEN;      dr.msgType = DEAMON_DEREGISTER;      m->lastDeamon++;      if(m->lastDeamon >= m->numberOfNets){	m->lastDeamon = 0;      }      ret = sendto(m->fd,(char *)&dr,		   (sizeof(dr)),		   0,		   (struct sockaddr *)&deamon,		   sizeof(deamon));      ret = poll(fds,1,SCTP_TIMEOUT_IN_POLL_FOR_DEAMON);      if(ret == 0){	/* time-out no response */	attempts++;	continue;      }      if(ret < 0){	/* huh */	attempts++;	continue;      }      lenfrm = sizeof(from);      ret = recvfrom(m->fd,(char *)&dr,sizeof(dr),0,		     (struct sockaddr *)&from,&lenfrm);      if(from.sin_port != deamon.sin_port){	/* someone else sent me some garbage */	continue;      }      if(dr.ver_len != DEAMON_MAGIC_VER_LEN){	/* deamon thinks I am up, but hang with it	 * since I do want a response 	 */	continue;      }      if(dr.msgType == DEAMON_DEREGISTER_ACK){	/* got it */	kapla = 1;	break;      }    }  }  printf("Closing the fd %d\n",m->fd);  close(m->fd);  if(m->fird != -1){    /* close random number device */    close(m->fird);  }  free(m);  return(0);}int sctpGETNUMOUTSTREAMS(struct SCTP *m,struct sockaddr *to){  struct SCTP_association *asoc;  int indx;  asoc = SCTPfindAssociation(m,to,&indx);  if(asoc == NULL){    /* got to have a open association to send on a stream */    errno = ENOENT;    return(-1);  }  return(asoc->streamoutcnt);}int sctpGETNUMINSTREAMS(struct SCTP *m,struct sockaddr *to){  struct SCTP_association *asoc;  int indx;  asoc = SCTPfindAssociation(m,to,&indx);  if(asoc == NULL){    /* got to have a open association to send on a stream */    errno = ENOENT;    return(-1);  }  return(asoc->streamincnt);}intsctpSEND(struct SCTP *m,	 int streamNo,	 char *data, 	 int siz, 	 struct sockaddr *to,	 int options,	 int payloadtype,	 int numOfRetrans){  /* given the address whoto, send the specified data   * over the SCTP to the destination on the indicated   * stream. If no association we fail, since sends to   * non-stream 0 must have a open assoc.   */  struct SCTP_association *asoc;  struct SCTP_stream_out *str;  int indx,blast;  SCTPdebugPrint(m,"Send called\n");  if(streamNo == 0){    return(sendToStream0(m,data,siz,to,options,payloadtype,numOfRetrans));  }  asoc = SCTPfindAssociation(m,to,&indx);  if(asoc == NULL){    /* got to have a open association to send on a stream */    errno = ENOENT;    return(-1);  }  /* not allowed if we are shutting down */  if(((asoc->state&SCTP_STATE_MASK) == SCTP_STATE_SHUTDOWN) ||     ((asoc->state&SCTP_STATE_MASK) == SCTP_STATE_SHUTDOWN_RECV) ||     (asoc->state & SCTP_STATE_SHUTDOWN_PEND)     ){    errno = EBUSY;    return(-1);  }  str = NULL;  if(streamNo < asoc->streamoutcnt){    str = &asoc->strmout[(streamNo-1)];  }  if(options & SCTP_DO_CRC16){    /* once crc16 has started the only way     * to turn off for this association     * is to shut it down. This could     * be changed by adding a option SCTP_NO_CRC16 but     * then it would need to be protected if MTU_DISCOVERY     * is on since we MUST have crc16 in this mode.     */    asoc->sendMode |= SCTP_DO_CRC16;  }  if(options & SCTP_MY_ADDRESS_ONLY){    /* request that only the specifed address be used */    asoc->sendMode |= SCTP_MY_ADDRESS_ONLY;  }  if(options & SCTP_FLEXIBLE_ADDRESS){    /* SCTP can override address */    asoc->sendMode &= ~SCTP_MY_ADDRESS_ONLY;  }  if(str == NULL){    /* can't find the open stream */    errno = ENOENT;    return(-2);  }  if(asoc->outQueueCount > SCTP_MAX_OUTSTANDING_DG){    errno = ENOSPC;    return(-1);  }      if(SCTPaddOutboundData(m,asoc,str,data,siz,options,			 indx,streamNo,payloadtype,numOfRetrans)){    /* can't add it to the outbound queue no memory? */    return(-1);  }  if(streamNo > 3){    asoc->pegs[SCTP_STRMO_SND]++;  }else{    asoc->pegs[(SCTP_STRM0_SND+streamNo)]++;  }  SCTPdebugPrint(m,"Added to outbound, now send what we can\n");  if((blast = SCTPsendAnyWeCan(m,asoc,0))){    while(blast && (asoc->numberUnsent > 0)){      /* blast away util we fill the window */      /* or have nothing to send */      blast = SCTPsendAnyWeCan(m,asoc,0);    }  }  return(0);}intsctpGETPRIMARY(struct SCTP *m, struct sockaddr *s){  struct SCTP_association *asoc;  int indx;  asoc = SCTPfindAssociation(m,s,&indx);  if(asoc == NULL){    errno = ENOENT;    return(-1);  }  return(asoc->primary_destination);}intsctpSETPRIMARY(struct SCTP *m, struct sockaddr *s){  struct SCTP_association *asoc;  int indx;  asoc = SCTPfindAssociation(m,s,&indx);  if(asoc == NULL){    errno = ENOENT;    return(-1);  }  asoc->primary_destination = indx;  return(0);}int /* return -1 if error, otherwise the size of date received */sctpRECEIVE(struct SCTP *m,	    char *readbuf, 	    int siz,	    int *strmNum,	    int *seqNum,	    struct sockaddr *from,	    struct sockaddr *to,	    int *payload,	    u_int *tsn){  /* read a datagram that is queued up from the interface   * and copy to the user side.   * populate from with who sent the dg (always use the   * place it came from)   */  struct SCTP_transmitOnQueue *tp1;  int netNum, dsz;  errno = 0;  if(m->numberInbound == 0) {    /* nothing to be read */    return(0);  }  if(m->inqueue == NULL) {    errno = EAGAIN;    return(-1);  }  /* de-queue the tmit */  tp1 = m->inqueue;  if(tp1 == NULL){    /* none left */    return(0);  }  /* now just copy out the data etc */  dsz = tp1->sizeOfTmit;  if(siz < dsz) {    /* if there is not enough room we truncate the     * data, it would be nice to NOT do this, but instead     * return a indication to the user, move up the pointer,     * subtract down the size, and leave it on queue      */    dsz = siz;  }  memcpy((void *)readbuf, (void *)tp1->data, dsz);  netNum = tp1->whichNet;  if(((struct sockaddr *)tp1->from)->sa_family == AF_INET){    memcpy((char *)from,tp1->from,sizeof(struct sockaddr_in));  }else if(((struct sockaddr *)tp1->from)->sa_family == AF_INET6){    memcpy((char *)from,tp1->from,sizeof(struct sockaddr_in6));  }  /* ok now reset the llist */  m->inqueue = tp1->next;  if(m->inqueue){    m->inqueue->prev = NULL;  }else{    m->inqueueLast = NULL;  }  /* purge it all the way out */  tp1->next = tp1->prev = NULL;  /* drop down the number in queue and   * setup the seq/strm number for the user.   */  m->numberInbound--;  *strmNum = tp1->streamNumber;  *seqNum = tp1->streamSeq;  *payload = tp1->payloadtype;  *tsn = (u_int)tp1->TSN_seq;  /* free up the rwnd buffer space on my side */  tp1->asoc->myRwnd += dsz;  tp1->asoc->pegs[SCTP_PEG_TSNS_READ]++;  /* clean up and return the size */  if(to != NULL){    if(((struct sockaddr *)tp1->to)->sa_family == AF_INET){      memcpy((char *)to,tp1->to,sizeof(struct sockaddr_in));    }else if(((struct sockaddr *)tp1->to)->sa_family == AF_INET6){      memcpy((char *)to,tp1->to,sizeof(struct sockaddr_in6));    }  }  w_free(m,tp1->data);  w_free(m,tp1);  return(dsz);}voidsctptimerExpires(struct SCTP *m,void *a){  struct SCTP_association *asoc;  struct SCTP_TimerInfo *tm;  /* Process the Timeout on the given SCTP   * for the association passed in the arg.   */ SCTPdebugPrint(m, "-------------------- Timer expiry --------------------\n");  tm = (struct SCTP_TimerInfo *)a;  asoc = (struct SCTP_association *)tm->timerinfo;  tm->running = SCTP_TIMER_EXPIRED;  SCTPdebugPrint(m,"Timer type %d expires\n",tm->timerType);  switch(tm->timerType){  case SctpTimerTypeShutdownAck:    SCTPhandleShutdownAckTimerUp(m,asoc,tm);    break;  case SctpTimerTypePathMtuRaise:    SCTPhandlePathMtuRaise(m,asoc,tm);    break;  case SctpTimerTypeInit:    SCTPhandleInitTimerUp(m,asoc,tm);    break;  case SctpTimerTypeRecv:    SCTPhandleRecvTimerUp(m,asoc,tm);    break;  case SctpTimerTypeSend:    SCTPhandleSendTimerUp(m,asoc,tm);    break;  case SctpTimerTypeShutdown:    SCTPhandleShutdownTimerUp(m,asoc,tm);    break;  case SctpTimerTypeHeartbeat:    SCTPhandleHeartBeatTimerUp(m,asoc,tm);    break;  case SctpTimerTypeCookie:    SCTPhandleCookieTimerUp(m,asoc,tm);    break;  case SctpTimerTypeRelReq:    SCTPhandleRelReqTimerUp(m,asoc,tm);    break;  case SctpTimerTypeNewCookie:    {      /* we do this right here */      int i;      struct timespec timenow;      (*m->getTime)(&timenow);      m->lastSecretNumber = m->currentSecretNumber;      m->currentSecretNumber++;      if(m->currentSecretNumber >= SCTP_HOW_MANY_SECRETS){	m->currentSecretNumber= 0;      }      for(i=0;i<SCTP_NUMBER_OF_SECRETS;i++){	m->secretKey[m->currentSecretNumber][i] = SCTPselectInitialTSN(m);      }      m->timeOfSecretChange = timenow.tv_sec;      m->cookieTime.timerType = SctpTimerTypeNewCookie;      m->cookieTime. running = SCTP_TIMER_IDLE;      /* now schedule another timer for the cookie change */      (*m->timer)(m,(void *)&m->cookieTime,SCTP_TIMER_START,SCTP_HOW_LONG_COOKIE_LIVE,0);    }    break;  default:    break;  };}int *getSCTPfileDescriptor(struct SCTP *m,int *eventMask,int *numfds){  /* Return the fd array and that we want to read plus   * the size. If MTU_DISCOVERY we have 3 fd's else 1.   */  *eventMask = SCTP_EVENT_READ;  *numfds = 1;  return(&m->fd);}intSCTPprocessInbound(struct SCTP *m,		   struct sctpHeader *uh,		   int siz,		   struct sockaddr *from,		   unsigned char tos,		   struct sockaddr *toAddr){  int netnumfnd;  int retVal,gotCookie;  int left;  struct sctpChunkDesc *desc,*tmpdesc;  struct SCTP_association *asoc;  int inadrIdx;  int cntOfDChk,blast;  u_long cmp,val;  if(siz <= sizeof(struct sctpHeader)){    errno = EFAULT;    return(-1);  }  inadrIdx = -1;  cntOfDChk = netnumfnd = 0;  gotCookie = 0;  /* screen out any of the junk that   * is not protocol data   */  asoc = NULL;  left = siz;  /* save crc and then   * init to 0   */  cmp = ntohl(uh->adler32);  SCTPdebugPrint(m,"Saved adler value is %8.8x size:%d\n",cmp,siz);  uh->adler32 = 0L;#ifdef SCTP_USECRC_CRC16  val = crc16_tbl((u_char *)uh,siz);#endif#ifdef SCTP_USECRC_SSHCRC32  val = ssh_crc32((u_char *)uh,siz);#endif#ifdef SCTP_USECRC_MODADLER  val = count_mcrc((u_char *)uh,siz);#endif#ifdef SCTP_USECRC_FASTCRC32  val = ether_crc32_le_fast((u_char *)uh,siz);#endif#ifdef SCTP_USECRC_CRC16SMAL  val = crc16((u_char *)uh,siz);#endif#ifdef SCTP_USECRC_CRC32  val = ether_crc32_le((u_char *)uh,siz);#endif#ifdef SCTP_USECRC_TCP32  val = tcp32((u_char *)uh,siz);#endif#ifdef SCTP_USECRC_FLETCHER  val = fletcher((u_char *)uh,siz);#endif#ifdef SCTP_USECRC_RFC2960  val = count_crc((u_char *)uh,siz);#endif  SCTPdebugPrint(m,"Result of check is %4.4x\n",val);  if(val != cmp){    /* Crc failure, dump it.     */    SCTPdebugPrint(m,"Failed ALDER in:%x calc:%x\n",		   cmp,val);    return(0);  }  SCTPdebugPrint(m,"Ok we must find the assoc\n");    retVal = 0;  asoc = SCTPfindAssociation(m,from,&netnumfnd);  if(asoc != NULL){    /* mark in where I last got a dg from      */    if(SCTPisToAddressInAssociation(m,asoc,toAddr,&inadrIdx,0) == 0){      /* This address is not part of the association       */      SCTPdebugPrint(m,"To address is NOT part of the association\n");      SCTP_handleOutOfBlue(m,from,uh,siz,toAddr);      return(m->numberInbound);    }    asoc->lastNetRcvdFrom = netnumfnd;    asoc->pegs[SCTP_DATAGRAMS_RCVD]++;  }else{    SCTPdebugPrint(m,"Assoc is NULL\n");  }  SCTPdebugPrint(m,"On to process the message\n");  desc = (struct sctpChunkDesc *)((u_long)uh + sizeof(struct sctpHeader));  if(isSCTPControl(desc)){    /* munge through and process the control portion of     * the datagram     */    SCTPdebugPrint(m,"Processing control portion\n");    asoc = SCTP_handleControlPortion(m,				     uh,				     asoc,				     from,				     siz,				     &desc,				     &netnumfnd,				     &gotCookie,				     &left,				     toAddr);  }else{    /* validate tag, since it has no control     * in it.     */    left -= sizeof(struct sctpHeader);    if(asoc == NULL){      /* ignore dg, no assoc */      SCTP_handleOutOfBlue(m,from,uh,siz,toAddr);      return(m->numberInbound);          }    if(asoc->curTag != ntohl(uh->verificationTag)){      /* bad dg, tag mis-match */      SCTPdebugPrint(m,"Tag mis-match ignore dg\n");      return(m->numberInbound);    }  }  SCTPdebugPrint(m,"Control finished\n");  if(asoc == NULL){    SCTPdebugPrint(m,"Returning %d\n",m->numberInbound);    return(m->numberInbound);  }  /* manage error stuff */  SCTPdebugPrint(m,"Clearing asoc's error count:%d left:%d desc:%x\n",		 asoc->overallErrorCount,left,(u_int)desc);  asoc->overallErrorCount = 0;  SCTPdebugPrint(m,"Check for data portion asoc:%x desc:%x basemg:%x\n",		 (u_int)asoc,(u_int)desc,(u_int)uh);  while(left > 0){    /* handleDataPortion should fill     * in the numberInbound so it can     * be returned and caller will     * know to do a rcv()     */    int sizeOf;    SCTPdebugPrint(m,"Processing a data chunk left:%d desc:%x\n",left,(u_long)desc);    sizeOf = (int)(ntohs(desc->chunkLength));    if(left < sizeOf){      /* error impossible chunk left */      SCTPdebugPrint(m,"Chunk shows %d left, calculate only %d left\n",		     sizeOf,left);      break;    }    if(desc->chunkID != SCTP_DATA){      /* should not have data/control/data ever at this point since       * handleControl will not return until all control is processed       * and it hits a data type chunk.       */      SCTPdebugPrint(m,"Chunk shows %d type during data processing\n",		     desc->chunkID);      break;    }    if(inadrIdx == -1){      /* don't care about result just want index */      inadrIdx = 0;      SCTPisToAddressInAssociation(m,asoc,toAddr,&inadrIdx,0);    }    cntOfDChk++;    SCTPdebugPrint(m,"I have now seen %d data chunks\n",cntOfDChk);    /* run through and process this data chunk */    if(sizeOf <= sizeof(struct sctpUnifiedDatagram)){      /* Zero length data chunk, abort */      SCTPdebugPrint(m,"Size is 0 length? ABORT\n");      SCTPsendAAbort(m,asoc,from,0,SCTP_OP_ERROR_INV_PARAM,0);          SCTPreportAllOutboundLost(m,asoc);      SCTPupperLayerNotification(m,asoc,SCTP_NOTIFY_ASSOC_DOWN,				 (int)from);      SCTPfreeAssociation(m,asoc);      return(m->numberInbound);    }    SCTPdebugPrint(m,"Call handle data portion netnumfnd is %d\n",netnumfnd);    SCTP_handleDataPortion(m,desc,asoc,sizeOf,netnumfnd,tos,inadrIdx);    if(asoc->ECN_Allowed){      if((tos & SCTP_CE_BIT) == SCTP_CE_BIT){	/* tos shows a CE turn it off now */	tos &= ~SCTP_CE_BIT;      }    }    /* ok now update the pointers rounded to a 32 bit boundary */    tmpdesc = (struct sctpChunkDesc *)((((u_long)desc + sizeOf + 3) >> 2) << 2);    left -= ((u_long)tmpdesc - (u_long)desc);    SCTPdebugPrint(m,"tmpdesc:%x desc:%x left:%d\n",		   (u_long)tmpdesc,(u_long)desc,left);    if(tmpdesc == desc){      SCTPdebugPrint(m,"Input packet error old addr:%x new addr same:%x\n",		       (u_long)desc,(u_long)tmpdesc);      break;    }    desc = tmpdesc;    if(left <= 0){      SCTPdebugPrint(m,"Bail none left\n");      break;    }  }  /* ok now that all data is processed show the new cong control   * stats.   */  asoc->pegs[SCTP_PEG_TSNS_RCVD] += cntOfDChk;  if(cntOfDChk){    asoc->pegs[SCTP_DATA_DG_RECV]++;  }  SCTPdisplayCongestionStats(m,asoc,"New");  SCTPdebugPrint(m,"Transmit time\n");  if(cntOfDChk){    /* ok data recieved do we need a sack? */    if(asoc->needToAck == 0){      /* not ready to ack yet, start the timer */      SCTPdebugPrint(m,"No SACK timer up it is 0\n");      timerWork(m,asoc,SCTP_TIMER_START,SctpTimerTypeRecv,0);    }    /* bump count */    asoc->needToAck++;    SCTPdebugPrint(m,"NeedToAck=%d\n",asoc->needToAck);  }  /* first out up to one MTU of retrans. */  if((gotCookie == 0) && (asoc->numberToRetran > 0)){    SCTPdebugPrint(m,"Got cookie is 0 and %d to retran\n",asoc->numberToRetran);    SCTPsendRetransmits(m,asoc);  }  /* now send out a dg. If the cookie is out, then   * try to fill a window's worth.    */  else if((asoc->outqueue != NULL) && (asoc->numberUnsent > 0)){    int blastCount;    SCTPdebugPrint(m,"Now to send what we can\n");    blastCount = 0;    if(((blast = SCTPsendAnyWeCan(m,asoc,1)) > 0) && (asoc->cookie == NULL)){      SCTPdebugPrint(m,"Going for multiple sends\n");      blastCount++;      while(blast && (asoc->numberUnsent > 0)){	/* blast out all to fill the window */	blast = SCTPsendAnyWeCan(m,asoc,1);	SCTPdebugPrint(m,"Another one bites the dust\n");	if(blast > 0){	  blastCount++;	  if(asoc->fastRetransmitCompletes && (blastCount >= asoc->maxBurst)){	    asoc->fastRetransmitCompletes = 0;	    break;	  }	}      }    }    asoc->fastRetransmitCompletes = 0;    SCTPdebugPrint(m,"Done sending\n");  }else if((gotCookie) || (asoc->opErr != NULL)){    /* ok lets push out the cookie */    SCTPsendAnyWeCan(m,asoc,1);  }  /* now if we need to ack i.e. larger than 2 or we   * have a gap, or we are have sent a Shutdown, or   * we received the first data element,  send a SACK.   */  if((asoc->needToAck > 1) ||                                        /* every other ack */     SCTPisThereAGap(m,asoc) ||                                      /* gap condtion */     ((asoc->state & SCTP_STATE_MASK) == SCTP_STATE_SHUTDOWN) ||     /* in shutdown */     ((asoc->needToAck == 1) && (asoc->firstAckUp))                  /* first data in */     ){    SCTPdebugPrint(m,"NeedToAck=%d so build SACK now\n",asoc->needToAck);    SCTPsendSackFlag(m,asoc);    asoc->needToAck = 0;    asoc->firstAckUp = 0;    timerWork(m,asoc,SCTP_TIMER_STOP,SctpTimerTypeRecv,0);  }  SCTPdebugPrint(m,"ret from  sending %d\n",m->numberInbound);  return(m->numberInbound);}intSCTPisItABroadcast(struct SCTP *m,struct in_addr *addr){  /* search through all broadcast masks and see if   * they are this address?   */  int i;  for(i=0;i<m->numberOfNets;i++){    /* skip non ipv4 addresses */    if(m->localNets[i]->sa_family != AF_INET)      continue;    if((addr->s_addr & m->maskList[i].sin_addr.s_addr) ==        (m->broadList[i].sin_addr.s_addr)){      SCTPdebugPrint(m,"address:(%x & %x) matches broadcast:%x\n",		     addr->s_addr,		     m->maskList[i].sin_addr.s_addr,		     m->broadList[i].sin_addr.s_addr);      return(1);    }  }  return(0);}intsctpfdEvent(struct SCTP *m,int event,int ifd){  /* This fcn will read in the data from the   * interface if that is what is wanted.   * If it is a write then I must dequeue and send   * anything in the outbound queue (not yet implemented).   */  struct sctpHeader *sch;  struct SCTP_association *asoc;  int hl;  int totlen;  int retval;  retval = 0;  /* huh, if we have a -1 in the fd somthing is very wrong */  if(m->fd == -1){    errno = EBADF;    return(-1);  }  /* if we reach here it must be a read/write from the IP socket */  if(event & SCTP_EVENT_READ){    char readBuff[SCTP_MAX_READBUFFER];    unsigned char tos;    unsigned char frmaddr[SCTP_ADDRMAX];    struct sockaddr_in from,to;    struct sockaddr_in6 from6,to6;    int ret;#ifdef AIX    size_t lenfrm;#else    int lenfrm;#endif    struct ip *iph;    struct ip6_hdr *ip6h;    /* handle the read portion of the event */    memset(frmaddr,0,sizeof(frmaddr));    lenfrm = sizeof(frmaddr);    ret = recvfrom(ifd,readBuff,SCTP_MAX_READBUFFER,		   0,(struct sockaddr *)frmaddr,&lenfrm);    if(ret >= (sizeof(struct sctpHeader)+sizeof(struct ip))){      /* process the data if the min is present */      SCTPdebugPrint(m,"Just got a total of %d bytes\n",ret);      SCTPdebugPrintArry(m,readBuff,ret);      SCTPdebugPrintAddress(m,(struct sockaddr *)frmaddr);      if(m->randomLoss){	int ranlos;	ranlos = rand();	if((ranlos &  m->randomLoss) == 0x3){	  printf("drop a dg\n");	  SCTPdebugPrint(m,"Random loss value:%d thresh:%d Packet LOST\n",			 ranlos,m->randomLoss);	  return(retval);	}      }      iph = (struct ip *)readBuff;      ip6h = (struct ip6_hdr *)readBuff;      if(iph->ip_v == IPVERSION){	if(iph->ip_p == IPPROTO_SCTP){	  u_long tmpto;	  hl     = iph->ip_hl << 2;#if (defined (FREEBSD) || defined (TRU64  ) || defined(AIX))	  /* When using the direct FreeBSD kernel patch	   * the IP size has the header size subtracted	   * from it. Fix this.	   */	  if(m->usingTheDeamon == 0){	    int x;	    x = iph->ip_len;	    if (x != ret){	      if ((x + hl) == ret){		/* fix */		/* BLA */		iph->ip_len = x + hl; 	      }	    }	  }#endif#if (defined(FREEBSD) || defined (TRU64))	  /* SCTP_PB_3 */	  totlen = iph->ip_len - hl;	  SCTPdebugPrint(m, "Total data length is %d with IP header length = %d \n",			 totlen, hl);#else	  totlen = (int)(ntohs(iph->ip_len) - hl);	  SCTPdebugPrint(m,"Total len is calculated %d - %d\n",			 ntohs(iph->ip_len),hl);#endif	  /* Prepare address structures */	  memset(&from,0,sizeof(from));	  memset(&to,0,sizeof(to));	  to.sin_family = from.sin_family = AF_INET;	  to.sin_addr.s_addr = iph->ip_dst.s_addr;	  from.sin_addr.s_addr = iph->ip_src.s_addr;#ifdef USES_BSD_4_4_SOCKET	  from.sin_len = to.sin_len = sizeof(struct sockaddr_in);#endif	  sch = (struct sctpHeader *)((caddr_t)readBuff + hl);	  from.sin_port = sch->source;	  to.sin_port = sch->destination;	  tos = iph->ip_tos;	  /* check for broadcast or multi-cast address and ignore, if	   * it is one 	   */	  tmpto = ntohl(iph->ip_dst.s_addr);	  if(IN_MULTICAST(tmpto)){	    SCTPdebugPrint(m,"Address 0x%x is a multicast address - discard\n",			   tmpto);	    /* It is multicast skip it */	    return(0);	  }	  /* here we use the wire address format since	   * the gather addresses should be returning things	   * in network order (I hope :>, may need a ifdef here	   * since I think some don't do this)	   */	  if(SCTPisItABroadcast(m,&iph->ip_dst)){	    /* It is broadcast, skip it */	    SCTPdebugPrint(m,"Address 0x%x is a broadcast - discard\n",			   iph->ip_dst.s_addr);	    return(0);	  }	  SCTPdebugPrint(m,"Address I came up with is\n");	  SCTPdebugPrintAddress(m,(struct sockaddr *)&from);	  	  retval = SCTPprocessInbound(m,sch,totlen,(struct sockaddr *)&from,				      tos,(struct sockaddr *)&to);	}else if(iph->ip_p == IPPROTO_ICMP){	  asoc = SCTPhandleICMP(m,iph);	  if(asoc){	    SCTPsendRetransmits(m,asoc);	  }	}      }else if((ip6h->ip6_vfc & IPV6_VERSION_MASK) == IPV6_VERSION){	sch = (struct sctpHeader *)((caddr_t)readBuff + sizeof(struct ip6_hdr));	if(ip6h->ip6_nxt == IPPROTO_ICMPV6){	  asoc = SCTPhandleICMP6(m,ip6h);	  if(asoc){	    SCTPsendRetransmits(m,asoc);	  }	}else if(ip6h->ip6_nxt == IPPROTO_SCTP){	  if(IN6_IS_ADDR_MULTICAST(&ip6h->ip6_dst)){	    SCTPdebugPrint(m,"Destination is a IPv6 multicast, drop\n");	    return(0);	  }	  /* prepare the addresses */	  memset(&from6,0,sizeof(from6));	  memset(&to6,0,sizeof(to6));	  to6.sin6_family = from6.sin6_family = AF_INET6;#ifdef USES_BSD_4_4_SOCKET	  from6.sin6_len = to6.sin6_len = sizeof(struct sockaddr_in6);#endif	  from6.sin6_addr = ip6h->ip6_src;	  to6.sin6_addr = ip6h->ip6_dst;	  from6.sin6_port = sch->source;	  to6.sin6_port = sch->destination;	  if((IN6_IS_ADDR_LINKLOCAL(&from6.sin6_addr)) &&	      *(u_short *)&from6.sin6_addr.s6_addr[2] != 0){	      /* KAME HACK: to pull out embedded link local scope */	    u_short index;	    index = *(u_short *)&from6.sin6_addr.s6_addr[2];	    *(u_short *)&from6.sin6_addr.s6_addr[2] = 0;	    if (from6.sin6_scope_id == 0){	      from6.sin6_scope_id = ntohs(index);	    }	    to6.sin6_scope_id = from6.sin6_scope_id;	    *(u_short *)&ip6h->ip6_src.s6_addr[2] = 0;	    *(u_short *)&ip6h->ip6_dst.s6_addr[2] = 0;	    *(u_short *)&to6.sin6_addr.s6_addr[2] = 0;	    SCTPdebugPrint(m,"Scope id's set to %d\n",		from6.sin6_scope_id);	  }	  tos = ip6h->ip6_vfc & (~IPV6_VERSION_MASK);	  /* Ipv6 includes the payload len only */	  totlen = ntohs(ip6h->ip6_plen);	  /*#endif*/	  retval = SCTPprocessInbound(m,sch,totlen,(struct sockaddr *)&from6,				      tos,(struct sockaddr *)&to6);	  	}      }else{	SCTPdebugPrint(m,"Unknown protocol type %x\n",ip6h->ip6_vfc);      }    }  }  if(event & SCTP_EVENT_WRITE){    /* handle the write portion of the event */    /* Yet to be implemented */    /* Must fix if we allow TFLOW out */    /* otherwise we won't ever select for write */    /* for now since we do not use     * TLI we will declare this a error      */    errno = EFAULT;    return(-1);  }  if(event & SCTP_EVENT_EXCEPT){    /* handle the exception part?     * not sure we get these yet but     * we put this here for     * completeness.     */    errno = EFAULT;    return(-1);  }  if(m == NULL){    printf("At return m went NULL!!\n");  }  return(retval);}intsendToStream0(struct SCTP *m,	      char *data, 	      int siz, 	      struct sockaddr *to,	      int options,int payload,	      int numOfRetrans){  /* given the address whoto, send the specified data   * over the SCTP to the destination. If no association   * exists we will need to queue up the data after   * calling the init function which returns to us   * the association.   */  struct SCTP_association *asoc;  int doTheSend;  int indx,blast;  doTheSend = 1;  asoc = SCTPfindAssociation(m,to,&indx);  if(asoc == NULL){    /* this is a implicit send to stream 0, w/ implicit     * open of the association     * send of the first if we can and get     * a association.     */    asoc = SCTPstartInit(m,to,options);    if(asoc == NULL){      return(-1);    }    doTheSend = 0;  }else{    if(((asoc->state&SCTP_STATE_MASK) == SCTP_STATE_SHUTDOWN) ||       ((asoc->state&SCTP_STATE_MASK) == SCTP_STATE_SHUTDOWN_RECV) ||       (asoc->state & SCTP_STATE_SHUTDOWN_PEND)       ){      /* we are shutting this guy down, can't send there */      errno = EBUSY;      return(-1);    }  }  if(options & SCTP_DO_CRC16){    /* once crc16 has started the only way     * to turn off for this association     * is to shut it down. This could     * be changed by adding a option SCTP_NO_CRC16, however     * if mtu discovery is on we NEED CRC16 so probably     * it is best to be a sticky option.     */    asoc->sendMode |= SCTP_DO_CRC16;  }  if(options & SCTP_MY_ADDRESS_ONLY){    /* Please send it to the address specified no the primary */    asoc->sendMode |= SCTP_MY_ADDRESS_ONLY;  }  if(options & SCTP_FLEXIBLE_ADDRESS){    /* SCTP can override address to the primary */    asoc->sendMode &= ~SCTP_MY_ADDRESS_ONLY;  }  /* now we must alocate the stuff for    * the users send and put it   * on the list. If doTheSend is   * true we call the sending routing   */  if(asoc->outQueueCount > SCTP_MAX_OUTSTANDING_DG){    errno = ENOSPC;    return(-1);  }  if(SCTPaddOutboundData(m,asoc,&asoc->outbound,data,siz,options,			 indx,0,payload,numOfRetrans)){    /* can't add it to the outbound queue memory problem */    return(-1);  }  asoc->pegs[SCTP_STRM0_SND]++;  if((asoc->state == SCTP_STATE_COOKIE_SENT) ||	     (asoc->state == SCTP_STATE_COOKIE_WAIT)){    /* another send and I have not got     * I-A back yet     */    doTheSend = 0;  }  if(doTheSend){    if((blast = SCTPsendAnyWeCan(m,asoc,0))){      while(blast && (asoc->numberUnsent > 0)){	/* blast away util we fill the window */	/* or have nothing to send */	blast = SCTPsendAnyWeCan(m,asoc,0);      }    }  }  return(0);}intsetSCTPtimer(struct SCTP *m, int type, int sec, int nsec){  if((sec == 0) && (nsec < 10000000)){    /* 10ms is the minium a timer can     * be since we are probably on a     * posix type clock.. This should be     * changed for other o/s's with better resolution     * clocks.     */    errno = EINVAL;    return(-1);  }  if((type < SCTP_TIMER_INIT) ||      (type > SCTP_TIMER_PMTU)){    errno = EFAULT;    return(-1);  }  m->baseTimeoutSecs[type] = sec;  m->baseTimeoutNSecs[type] = nsec;  return(0);}intgetSCTPtimer(struct SCTP *m, int type, int *sec, int *nsec){  if((type < SCTP_TIMER_INIT) ||      (type > SCTP_TIMER_PMTU)){    errno = EFAULT;    return(-1);  }  *sec = (int)m->baseTimeoutSecs[type];  *nsec = (int)m->baseTimeoutNSecs[type];  return(0);}intsctpSetRetryCount(struct SCTP *m, int type, int retryCount){  if((type !=  SCTP_MAXATTEMPT_INIT) && (type != SCTP_MAXATTEMPT_SEND)){    errno = EFAULT;    return(-1);  }  if(type == SCTP_MAXATTEMPT_INIT){    m->maxInitTimes = retryCount;  }else if(type == SCTP_MAXATTEMPT_SEND){    m->maxSendTimes = retryCount;  }  return(0);}intsctpGetRetryCount(struct SCTP *m, int type){  if((type != SCTP_MAXATTEMPT_INIT) && (type != SCTP_MAXATTEMPT_SEND)){    errno = EFAULT;    return(-1);  }  if(type == SCTP_MAXATTEMPT_INIT){    return(m->maxInitTimes);  }else if(type == SCTP_MAXATTEMPT_SEND){    return(m->maxSendTimes);  }  errno = EFAULT;  return(-1);}intsctpSetRwindowSize(struct SCTP *m,int sz){  int tmpWindow;  if((sz < SCTP_WINDOW_MIN) ||      (sz > SCTP_WINDOW_MAX)){    errno = EFAULT;    return(-1);  }  m->maxWindow = sz;  tmpWindow = m->maxWindow + (m->maxWindow/2);  if(setsockopt(m->fd,SOL_SOCKET,SO_RCVBUF,(char*)&tmpWindow,		sizeof(tmpWindow))<0){    return(-1);  }  if(setsockopt(m->fd,SOL_SOCKET,SO_SNDBUF,		(char*)&tmpWindow,sizeof(tmpWindow))< 0){    return(-1);  }  return(0);}intsctpSetOutStream(struct SCTP *m, int value){ m->preOpenStreamCount = value; return(value);}intsctpMarkUnrelStreams(struct SCTP *m, char *ms){  /* e.g., "1-5,8,20-400,6" */  char lbuf[256];  char *ss1, *ss2, *pp1, *pp2;  int i, kk;  for(i=0;i<MAX_UNRELSTREAM_SETS*2;i++)     m->unrelStreamSets[i] = -1; /* clean up first */  strncpy(lbuf, ms, 256);  lbuf[255] = 0;  i = 0;  ss1 = strtok_r(lbuf, ",", &pp1);  while(ss1) {    /* now ss1 is either "a" or "a-b" */    ss2 = strtok_r(ss1, "-", &pp2); /* get "a" */    kk = atoi(ss2);    if((kk = atoi(ss2)) < 0)       return(-1);    m->unrelStreamSets[i] = kk;    i++;    ss2 = strtok_r(NULL, "-", &pp2); /* get "b" */    if(ss2) {      kk = atoi(ss2);      if(kk < 0) {	m->unrelStreamSets[i-1] = -1;	return(-1);      } else {	m->unrelStreamSets[i] = atoi(ss2);      }    } else {      m->unrelStreamSets[i] = m->unrelStreamSets[i-1];    }    i++;    if(i >= MAX_UNRELSTREAM_SETS*2) break;    ss1 = strtok_r(NULL, ",", &pp1);  }  return(0);}intsctpSetSendOptions(struct SCTP *m, int value){  m->sendOptionsDef = value;  return(value);}voidsctpCHANGEHEARTBEAT(struct SCTP *m,		    struct sockaddr *s, 		    int delay){  /* Set the HB delay on   * destination network address.   */  int indx;  struct SCTP_association *asoc;  asoc = SCTPfindAssociation(m,s,&indx);  if(asoc == NULL){    /* got to have a open association to open a stream */    SCTPdebugPrint(m,"Can't find assoc to set HB on\n");    return;  }  asoc->heartBeatDelay = delay;}int sctpGETRTTREPORT(struct SCTP *m,		 struct sockaddr *s){  int indx;  struct SCTP_association *asoc;  asoc = SCTPfindAssociation(m,s,&indx);  if(asoc == NULL){    /* got to have a open association to open a stream */    return(-1);  }    if(indx > asoc->numnets){    return(-1);  }  return(asoc->nets[indx].RTO);}int sctpGETHEARTBEATDELAY(struct SCTP *m,		      struct sockaddr *s){  /* Set the HB delay on   * destination network address.   */  int indx;  struct SCTP_association *asoc;  asoc = SCTPfindAssociation(m,s,&indx);  if(asoc == NULL){    /* got to have a open association to open a stream */    SCTPdebugPrint(m,"Can't find assoc to get HB delay\n");    return(-1);  }  return(asoc->heartBeatDelay);}voidsctpSETHB(struct SCTP *m, struct sockaddr *s, int on){  /* Set the HB state on a specified   * destination network address.   */  int indx,i;  int old;  int onatstart,onatend;  int offatstart,offatend;  struct SCTP_association *asoc;  asoc = SCTPfindAssociation(m,s,&indx);  if(asoc == NULL){    /* got to have a open association to open a stream */    SCTPdebugPrint(m,"Can't find assoc to set HB on\n");    return;  }    offatstart = onatstart = 0;  for(i=0;i< asoc->numnets;i++){    if(asoc->nets[i].intfRotationState & SCTP_ADDR_NOHB){      offatstart++;    }else{      onatstart++;    }  }  if(on == 0){    old = asoc->nets[indx].intfRotationState;    asoc->nets[indx].intfRotationState |= SCTP_ADDR_NOHB;  }else{    old = asoc->nets[indx].intfRotationState;    asoc->nets[indx].intfRotationState &= (~SCTP_ADDR_NOHB);  }  printf("Set indx:%d interface rotation state to %x (old state:%x)\n",	 indx,	 (u_int)asoc->nets[indx].intfRotationState,	 (u_int)old);  SCTPPrintAnAddress(asoc->nets[indx].ina);  /* how many are left on */  offatend = onatend = 0;  for(i=0;i< asoc->numnets;i++){    if(asoc->nets[i].intfRotationState & SCTP_ADDR_NOHB){      offatend++;    }else{      onatend++;    }  }  if(on == 0){    /* turning off, if we are all off now, stop HB timer */    if(onatend == 0){      printf("stopping all HB timers\n");      timerWork(m,asoc,SCTP_TIMER_STOP,SctpTimerTypeHeartbeat,0);      }  }else{    /* turning on, and none on at start, start HB on new net */    if(onatstart == 0){      /* start timer on one we set on */      printf("restarting HB timer\n");      timerWork(m,asoc,SCTP_TIMER_START,SctpTimerTypeHeartbeat,indx);      }  }}voidsctpSETFAILURETHRESHOLD(struct SCTP *m, struct sockaddr *s, int num){  int indx;  struct SCTP_association *asoc;  asoc = SCTPfindAssociation(m,s,&indx);  if(asoc == NULL){    /* got to have a open association to open a stream */    SCTPdebugPrint(m,"Can't find assoc to set failure threshold on\n");    return;  }    asoc->nets[indx].failureThreshold = num;}intsctpHOWMANYINQUEUE(struct SCTP *m,struct sockaddr *s){  int indx;  struct SCTP_association *asoc;  asoc = SCTPfindAssociation(m,s,&indx);  if(asoc == NULL){    /* got to have a open association to open a stream */    return(0);  }    return(asoc->outQueueCount);}intsctpHOWMANYINBOUND(struct SCTP *m){  return(m->numberInbound);}u_int *sctpGETPEGS(struct SCTP *m, struct sockaddr *s){  int indx;  struct SCTP_association *asoc;  asoc = SCTPfindAssociation(m,s,&indx);  if(asoc == NULL){    /* got to have a open association to open a stream */    return((u_int *)NULL);  }    return(asoc->pegs);}voidsctpCLEARPEGS(struct SCTP *m, struct sockaddr *s){  int indx,i;  struct SCTP_association *asoc;  asoc = SCTPfindAssociation(m,s,&indx);  if(asoc == NULL){    /* got to have a open association to open a stream */    return;  }    for(i=0;i<SCTP_NUMBER_OF_PEGS;i++){    asoc->pegs[i] = 0;  }}intsctpHOWMANYNETS(struct SCTP *m, struct sockaddr *s){  int indx;  struct SCTP_association *asoc;  asoc = SCTPfindAssociation(m,s,&indx);  if(asoc == NULL){    /* got to have a open association to open a stream */    return(0);  }    return(asoc->numnets);}struct SCTP_nets *sctpGETNET(struct SCTP *m, struct sockaddr *s, int idx){  int indx;  struct SCTP_association *asoc;  asoc = SCTPfindAssociation(m,s,&indx);  if(asoc == NULL){    /* got to have a open association to open a stream */    return(NULL);  }    if(idx > asoc->numnets){    return(NULL);  }  return(&asoc->nets[idx]);}intsctpRWND(struct SCTP *m, struct sockaddr *s){  int indx;  struct SCTP_association *asoc;  asoc = SCTPfindAssociation(m,s,&indx);  if(asoc == NULL){    /* got to have a open association to open a stream */    return(-1);  }    return(asoc->peersRwnd);}intsctpREQUESTHEARTBEAT(struct SCTP *m,		     struct sockaddr *s){  int indx;  struct SCTP_association *asoc;  SCTPdebugPrint(m,"Doing DEMAND HEART BEAT!!\n");  asoc = SCTPfindAssociation(m,s,&indx);  if(asoc == NULL){    /* got to have a open association to open a stream */    return(-1);  }    return(SCTPSendHBReq(m,asoc,indx));}voidsctpSET_ASOC_ERR_THRESH(struct SCTP *m, struct sockaddr *s, int val){  int indx;  struct SCTP_association *asoc;  asoc = SCTPfindAssociation(m,s,&indx);  if(asoc == NULL){    /* got to have a open association to open a stream */    return;  }    asoc->maxSendTimes = val;}int *sctpGETFSID(struct SCTP *m,struct sockaddr *s,int which){  int indx;  struct SCTP_association *asoc;  int *xx;  asoc = SCTPfindAssociation(m,s,&indx);  if(asoc == NULL){    /* got to have a open association to open a stream */    return(NULL);  }    switch(which){  case 0:    xx = asoc->fsp1;    break;  case 1:    xx = asoc->fsp2;    break;  case 2:    xx = asoc->fsp3;    break;  case 3:    xx = asoc->fsp4;    break;  case 4:    xx = asoc->fsp5;    break;  default:    xx = NULL;    break;  }  return(xx);}voidsctpSET_NET_ERR_THRESH(struct SCTP *m, struct sockaddr *s, 		       int idx, int val){  int indx;  struct SCTP_association *asoc;  asoc = SCTPfindAssociation(m,s,&indx);  if(asoc == NULL){    /* got to have a open association to open a stream */    return;  }    if(idx > asoc->numnets){    return;  }  asoc->nets[idx].failureThreshold = val;}intsctpGET_MY_RWND(struct SCTP *m, struct sockaddr *s){  int indx;  struct SCTP_association *asoc;  asoc = SCTPfindAssociation(m,s,&indx);  if(asoc == NULL){    /* got to have a open association to open a stream */    return(-1);  }    return(asoc->myRwnd);}intsctpGET_PEERS_RWND(struct SCTP *m, struct sockaddr *s){  int indx;  struct SCTP_association *asoc;  asoc = SCTPfindAssociation(m,s,&indx);  if(asoc == NULL){    /* got to have a open association to open a stream */    return(-1);  }   return(asoc->peersRwnd);}intsctpGET_CURCOOKIELIFE(struct SCTP *m, struct sockaddr *s){  int indx;  struct SCTP_association *asoc;  asoc = SCTPfindAssociation(m,s,&indx);  if(asoc == NULL){    /* got to have a open association to open a stream */    return(-1);  }   return(asoc->cookieLife);}intsctpCHANGE_COOKIELIFE(struct SCTP *m, struct sockaddr *s, int val){  int indx,oldval;  struct SCTP_association *asoc;  if(val <= 0){    return(-1);  }  asoc = SCTPfindAssociation(m,s,&indx);  if(asoc == NULL){    /* got to have a open association to open a stream */    return(-2);  }   oldval = asoc->cookieLife;  asoc->cookieLife = val;  return(oldval);}intsctpABORT2(struct SCTP *m, struct sockaddr *s ){  struct SCTP_association *asoc;  int indx;  SCTPdebugPrint(m,"Called ABORT ASSOC\n");  asoc = SCTPfindAssociation(m,s,&indx);  if(asoc == NULL){    SCTPdebugPrint(m,"Can't find assoc to ABORT\n");    errno = ENOENT;    return(-1);  }  if((asoc->state != SCTP_STATE_EMPTY) &&     (asoc->numnets) &&     (asoc->hisTag)     ){    SCTPsendAAbort(m,asoc,s,asoc->hisTag,0,0);  }  if(asoc->state != SCTP_STATE_EMPTY) {    /* clean up if needed */    SCTPreportAllOutboundLost(m,asoc);    SCTPupperLayerNotification(m,asoc,SCTP_NOTIFY_ASSOC_DOWN,	        	       (int)s);    SCTPfreeAssociation(m,asoc);  }  return(0);}voidSCTP_kickTheDeamon(struct SCTP *m){  struct deamonRegister dr;  struct sockaddr_in deamon;  int ret;  if(m->usingTheDeamon == 0){    /* not around to kick */    return;  }  dr.ver_len = DEAMON_MAGIC_VER_LEN;  dr.tos = 0;  dr.msgType = DEAMON_CHECKADDR_LIST;  dr.ver_len = DEAMON_MAGIC_VER_LEN;  dr.pad = 0;  memset(&deamon,0,sizeof(deamon));#ifdef USES_BSD_4_4_SOCKET  deamon.sin_len = sizeof(struct sockaddr_in);#endif  deamon.sin_port = htons(SCTP_DEAMON_PORT);  deamon.sin_family = AF_INET;  deamon.sin_addr.s_addr = htonl(0x7f000001);  ret = sendto(m->fd,(char *)&dr,(sizeof(dr)),0,	       (struct sockaddr *)&deamon, sizeof(deamon));  SCTPdebugPrint(m,"Return from kicking the deamon is %d \n",ret);}intsctpEXECUTEAllAddDel(struct SCTP *m){  int cnt;  struct SCTP_association *asoc;  asoc = m->assoc;  cnt = 0;  SCTPdebugPrint(m,"Executing all queued ADD/DEL's\n");  while(asoc != NULL){    cnt++;    SCTPdequeueRelReq(m,asoc);    asoc = asoc->next;  }  SCTPdebugPrint(m,"Invoked %d associatioins\n",cnt);  return(0);}intsctpEXECUTEAddDel(struct SCTP *m,		  struct sockaddr *to_ip){  int whichNet;  struct SCTP_association *asoc;  asoc = SCTPfindAssociation(m,to_ip,&whichNet);  if(asoc == NULL){    return(-1);  }  SCTPdequeueRelReq(m,asoc);  return(0);}intsctpADDIPADDRESS(struct SCTP *m, 		         /* SCTP endpoint */		 struct sockaddr *mynewaddress,		 /* Address to add - must exist */		 struct sockaddr *to_ip,		 /* Association address */		 int action			         /* action to take */		 ){  struct SCTP_association *asoc;  struct sockaddr_in fillMask,fillBroad;  int fndInOS,i,fndInEndpoint,delay,addrIdx;  int siteScope,locScope,ipv4scope;  /* First question: Does it already exist in the   * endpoint?   */  if(action & SCTP_ACTION_QUEUE_REQUEST_ONLY){    delay = 1;  }else{    delay = 0;  }  siteScope = locScope = ipv4scope = 0;  if(mynewaddress->sa_family == AF_INET){    struct sockaddr_in *min;    min = (struct sockaddr_in *)mynewaddress;    /*    if(IN4_ISPRIVATE_ADDRESS(&min->sin_addr))*/      ipv4scope = 1;  }else if(mynewaddress->sa_family == AF_INET6){    struct sockaddr_in6 *min6;    min6 = (struct sockaddr_in6 *)mynewaddress;    if(IN6_IS_ADDR_SITELOCAL(&min6->sin6_addr)){      siteScope = 1;    }    if(IN6_IS_ADDR_LINKLOCAL(&min6->sin6_addr)){      siteScope = 1;      locScope = 1;    }  }  fndInOS = fndInEndpoint = 0;  SCTPdebugPrint(m,"ADD IP ADDRESS CALLED !!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");  SCTPdebugPrintAddress(m,mynewaddress);  fndInEndpoint = SCTPisToAddressInEndpoint(m,mynewaddress,&addrIdx);  if(action & SCTP_ACTION_UPDATE_ENDPOINT){    SCTPdebugPrint(m,"Updating endpoint\n");    if(fndInEndpoint == 0){      /* nop, we don't know about the address so lets see if the       * o/s knows about it.       */      SCTPdebugPrint(m,"Ok, we will see if the address exist in the world\n");      fndInOS = SCTP_doesAddressExist(m,mynewaddress,&fillMask,&fillBroad);      SCTPdebugPrint(m,"Address look at kernel returns %d\n",fndInOS);      /* ret == -1 if an error occurs */      /* ret == 0 if it is loopback or not present */      /* ret == 1 if it is present now */      if(fndInOS == 1){	/* Ok, we must add this dude to the base SCTP endpoint. */	struct sockaddr **newlist;	int szEst;	SCTPdebugPrint(m,"Ok, It was in the OS we need to grow the list\n");	if(m->numberOfNets >= m->numberOfNetsAlloced){	  struct sockaddr_in *anewlist;	  newlist = (struct sockaddr **)w_calloc(m,(m->numberOfNets+1),						 sizeof(struct sockaddr *));	  if(newlist == NULL){	    /* deep trouble */	    return(-2);	  }	  szEst = (sizeof(struct sockaddr) * m->numberOfNets);	  /* copy the old in */	  for(i=0;i<m->numberOfNets;i++){	    newlist[i] = m->localNets[i];	    m->localNets[i] = NULL;	  }	  w_free(m,m->localNets);	  m->localNets = newlist;	  /* Now increase the mask list size too */	  anewlist = w_calloc(m,(m->numberOfNets+1),sizeof(struct sockaddr_in));	  if(anewlist == NULL){	    /* deep trouble */	    return(-2);	  }	  /* copy the old */	  memcpy(anewlist,m->maskList,szEst);	  w_free(m,m->maskList);	  m->maskList = anewlist;	  /* now the broadcast list */	  anewlist = w_calloc(m,(m->numberOfNets+1),sizeof(struct sockaddr_in));	  if(anewlist == NULL){	    /* deep trouble */	    return(-2);	  }	  /* copy the old */	  memcpy(anewlist,m->broadList,szEst);	  w_free(m,m->broadList);	  m->broadList = anewlist;	  m->numberOfNetsAlloced = m->numberOfNets + 1;	}	if(mynewaddress->sa_family == AF_INET){	  /* if the calloc fails let the cores fly :) */	  m->localNets[m->numberOfNets] = w_calloc(m,1,sizeof(struct sockaddr_in));	  memset(m->localNets[m->numberOfNets],0,sizeof(struct sockaddr_in));	  ((struct sockaddr_in *)(m->localNets[m->numberOfNets]))->sin_port = m->port;	  ((struct sockaddr_in *)(m->localNets[m->numberOfNets]))->sin_family = AF_INET;	  ((struct sockaddr_in *)(m->localNets[m->numberOfNets]))->sin_addr = 	    ((struct sockaddr_in *)mynewaddress)->sin_addr;	}else if(mynewaddress->sa_family == AF_INET6){	  m->localNets[m->numberOfNets] = w_calloc(m,1,sizeof(struct sockaddr_in6));	  memset(m->localNets[m->numberOfNets],0,sizeof(struct sockaddr_in6));	  ((struct sockaddr_in6 *)(m->localNets[m->numberOfNets]))->sin6_port = m->port;	  ((struct sockaddr_in6 *)(m->localNets[m->numberOfNets]))->sin6_family = AF_INET6;	  ((struct sockaddr_in6 *)(m->localNets[m->numberOfNets]))->sin6_addr = 	    ((struct sockaddr_in6 *)mynewaddress)->sin6_addr;	}else{	  m->localNets[m->numberOfNets] = NULL;	}	/* now the netmask list */	if(mynewaddress->sa_family == AF_INET){	  /* copy the new */	  memcpy((char *)&m->maskList[m->numberOfNets],		 (char *)&fillMask,sizeof(struct sockaddr_in));	  /* copy the new */	  memcpy((char *)&m->broadList[m->numberOfNets],		 (char *)&fillBroad,sizeof(struct sockaddr_in));	}	/* kick the deamon, we must do this before	 * we increment the network count, so the 	 * deamon does not get a message from a unknown	 * address.	 */	if(m->usingTheDeamon){	  SCTPdebugPrint(m,"Kick that deamon!\n");	  SCTP_kickTheDeamon(m);	}	/* increment the count of networks */	m->numberOfNets++;	/* now for every association, we have just spun them into a inconsistent	 * world. This means the dreaded source address selection will	 * kick in.	 */	asoc = m->assoc;	SCTPdebugPrint(m,		       "Inconsistent siteScope:%d loc:%d v4:%d,!\n",		       siteScope,locScope,ipv4scope);	while(asoc != NULL){	  /* turn off consistency flag for the appropriate scopes */	  if((siteScope) && (asoc->siteScope == 1)){	    asoc->listConsistent = 0;	  }else if((ipv4scope) && (asoc->ipv4Scope)){	    asoc->listConsistent = 0;	  }else if((siteScope == 0) && (ipv4scope == 0) && (locScope == 0)){	    asoc->listConsistent = 0;	  }	  asoc = asoc->next;	}	/* ok, its now in our endpoint */	fndInEndpoint = 1;      }    }  }  if(fndInEndpoint == 0){    /* Must exist in the SCTP endpoint, sorry */    SCTPdebugPrint(m,"NOT in endpoint!!\n");    return(-1);  }  if(action & SCTP_ACTION_UPDATE_ONLY_ASSOC){    /* Find the association and schedule an add if     * it needs it.     */    int whichNet,fndLocal;    SCTPdebugPrint(m,"Looking in ASSOCIATION only\n");    asoc = SCTPfindAssociation(m,to_ip,&whichNet);    if(asoc == NULL){      /* Hmm can't find the association */      return(0);    }    if(asoc->supportsDynamicAddress == 0){      /* Endpoint does not support it */      return(-2);    }    fndLocal = SCTPisToAddressInAssociation(m,asoc,mynewaddress,NULL,1);    if(fndLocal == 0){      int sz;      struct sctpParamDesc *param;      /* add one to the local association */      if(mynewaddress->sa_family == AF_INET){	struct sctpV4IpAddress *ipv4;	sz = sizeof(struct sctpV4IpAddress) + sizeof(struct sctpParamDesc);	param = (struct sctpParamDesc *)w_calloc(m,1,sz);	ipv4 = (struct sctpV4IpAddress *)((caddr_t)param + sizeof(struct sctpParamDesc));	param->paramType = htons(SCTP_ADD_IP_ADDRESS);	param->paramLength = ntohs(sz);	ipv4->p.paramType = htons(SCTP_IPV4_PARAM_TYPE);	ipv4->p.paramLength = htons(sizeof(struct sctpV4IpAddress));	ipv4->ipAddress = ((struct sockaddr_in *)mynewaddress)->sin_addr.s_addr;      }else if(mynewaddress->sa_family == AF_INET6){	struct sctpV6IpAddress *ipv6;	sz = sizeof(struct sctpV6IpAddress) + sizeof(struct sctpParamDesc);	param = (struct sctpParamDesc *)w_calloc(m,1,sz);	ipv6 = (struct sctpV6IpAddress *)((caddr_t)param + sizeof(struct sctpParamDesc));	param->paramType = htons(SCTP_ADD_IP_ADDRESS);	param->paramLength = ntohs(sz);	ipv6->p.paramType = htons(SCTP_IPV6_PARAM_TYPE);	ipv6->p.paramLength = htons(sizeof(struct sctpV6IpAddress));	memcpy(ipv6->ipAddress,((struct sockaddr_in6 *)mynewaddress)->sin6_addr.s6_addr,	       sizeof(ipv6->ipAddress));      }else{	param = NULL;      }      if(param != NULL)	SCTPqueueARelReq(m,asoc,param,delay);    }  }else if(action & SCTP_ACTION_UPDATE_ALL_ASSOC){    /* Ok, we need to update every association that     * is inconsistent, and lacks the address.     */    SCTPdebugPrint(m,"Looking at ALL ASSOCIATION's\n");    asoc = m->assoc;    while(asoc != NULL){      if(asoc->supportsDynamicAddress == 0){	/* does not support it, just check its consistency and continue */	SCTPdebugPrint(m,"No dynamic support\n");	asoc->listConsistent = SCTPcheckListConsistency(m,							asoc,							asoc->localNets,							asoc->numberOfNets);	continue;      }      SCTPdebugPrint(m,"List consistent is %d\n",asoc->listConsistent);      if((asoc->listConsistent == 0) && 	 (SCTPisToAddressInAssociation(m,asoc,mynewaddress,NULL,1) == 0)){	int sz;	struct sctpParamDesc *param;		SCTPdebugPrint(m,"Add queued here!\n");	if(mynewaddress->sa_family == AF_INET){	  struct sctpV4IpAddress *ipv4;	  sz = sizeof(struct sctpV4IpAddress) + sizeof(struct sctpParamDesc);	  param = (struct sctpParamDesc *)w_calloc(m,1,sz);	  ipv4 = (struct sctpV4IpAddress *)((caddr_t)param + sizeof(struct sctpParamDesc));	  param->paramType = htons(SCTP_ADD_IP_ADDRESS);	  param->paramLength = ntohs(sz);	  ipv4->p.paramType = htons(SCTP_IPV4_PARAM_TYPE);	  ipv4->p.paramLength = htons(sizeof(struct sctpV4IpAddress));	  ipv4->ipAddress = ((struct sockaddr_in *)mynewaddress)->sin_addr.s_addr;	}else if(mynewaddress->sa_family == AF_INET6){	  struct sctpV6IpAddress *ipv6;	  sz = sizeof(struct sctpV6IpAddress) + sizeof(struct sctpParamDesc);	  param = (struct sctpParamDesc *)w_calloc(m,1,sz);	  ipv6 = (struct sctpV6IpAddress *)((caddr_t)param + sizeof(struct sctpParamDesc));	  param->paramType = htons(SCTP_ADD_IP_ADDRESS);	  param->paramLength = ntohs(sz);	  ipv6->p.paramType = htons(SCTP_IPV6_PARAM_TYPE);	  ipv6->p.paramLength = htons(sizeof(struct sctpV6IpAddress));	  memcpy(ipv6->ipAddress,((struct sockaddr_in6 *)mynewaddress)->sin6_addr.s6_addr,		 sizeof(ipv6->ipAddress));	}else{	  param = NULL;	}	if(param != NULL)	  SCTPqueueARelReq(m,asoc,param,delay);      }      asoc = asoc->next;    }  }      SCTPdebugPrint(m,"All done, back comes a 1\n");  return(1);}intsctpDELIPADDRESS(struct SCTP *m, 		   /* SCTP endpoint */		 struct sockaddr *addresstodel, /* Address to delete - must exist */		 struct sockaddr *to_ip,	   /* Association address */		 int action			   /* action to take */		 ){  struct SCTP_association *asoc;  struct sockaddr_in fillMask,fillBroad;  int fndInOS,fndInEndpoint,delay,addrIndx;    /* First question: Does it already exist in the   * endpoint?   */  if(action & SCTP_ACTION_QUEUE_REQUEST_ONLY){    delay = 1;  }else{    delay = 0;  }  SCTPdebugPrint(m,"DELETE IP ADDRESS CALLED!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");  SCTPdebugPrintAddress(m,addresstodel);  fndInEndpoint = SCTPisToAddressInEndpoint(m,addresstodel,&addrIndx);  /* second question is it in the O/S */  fndInOS = SCTP_doesAddressExist(m,addresstodel,&fillMask,&fillBroad);  if(action & SCTP_ACTION_UPDATE_ENDPOINT){    if(fndInEndpoint){      int lastidx;      /* It is still in the O/S and in the endpoint */      /*             OR                             */      /* Was NO LONGER in the O/S but it IS still in the endpoint */      /* ok, this means we are removing an address that       * is out of the O/S. Kick the deamon after marking all       * endpoints to inconsistent AND removing the address from       * the association list.       */      SCTPdebugPrint(m,"Ok, its in the endpoint\n");      /* swap the addresses around */      SCTPdebugPrint(m,"Swap it out of the last spot\n");      lastidx = m->numberOfNets-1;      /* see if we need to remove the remote primary */      if(m->localNets[addrIndx] == m->preferedRemPrimary)	m->preferedRemPrimary = NULL;      /* free the memory */      w_free(m,m->localNets[addrIndx]);      /* bring the last one up */      m->localNets[addrIndx] = m->localNets[lastidx];      /* copy in the mask, even in IPv6 this will just blast 0's       * in so it should be ok       */      m->maskList[addrIndx].sin_addr.s_addr = m->maskList[lastidx].sin_addr.s_addr;      m->broadList[addrIndx].sin_addr.s_addr = m->broadList[lastidx].sin_addr.s_addr;      /* lower the count of addresses */      SCTPdebugPrint(m,"Reduce the count\n");      m->numberOfNets--;      /* Now that we have done all that, lets go through and        * find each association and possibly mark it inconsistent AND       * flag the address NOT to use.       */      SCTPdebugPrint(m,"Ok, now lets take a look at each association\n");      asoc = m->assoc;      while(asoc != NULL){	int fndLocal,indx;	/* turn off consistency flag */	fndLocal = SCTPisToAddressInAssociation(m,asoc,addresstodel,&indx,1);	if(fndLocal){	  asoc->addrStats[indx] = SCTP_ADDR_BEING_DELETED;	  asoc->listConsistent = 0;	}else{	  /* Audit consistency, since it may be the guy	   * did a local delete before the overall delete was done.	   */	  asoc->listConsistent = SCTPcheckListConsistency(m,							  asoc,							  asoc->localNets,							  asoc->numberOfNets);	  SCTPdebugPrint(m,"Ok assoc set consistency to %d\n",			 asoc->listConsistent);	}	asoc = asoc->next;      }      /* Now kick the deamon since we have lost a network and it may not know */      if(m->usingTheDeamon){	if(fndInOS == 0){	  SCTPdebugPrint(m,"Kick the deamon\n");	  SCTP_kickTheDeamon(m);	}      }    }else{      /* It is in the O/S and NOT in the endpoint */      /* nop, since he already has what he wants */      /*               OR                      */      /* It is NOT in the O/S and it is NOT in the Endpoint */      /* nop */      return(0);    }  }  if(action & SCTP_ACTION_UPDATE_ONLY_ASSOC){    int idxx,whichNet,fndLocal;    SCTPdebugPrint(m,"Now do association level delete\n");    asoc = SCTPfindAssociation(m,to_ip,&whichNet);    if(asoc == NULL){      /* Hmm can't find the association */      return(0);    }    if(asoc->supportsDynamicAddress == 0){      /* Endpoint does not support it */      return(-2);    }    fndLocal = SCTPisToAddressInAssociation(m,asoc,addresstodel,&idxx,1);    if(fndLocal == 0){      int sz;      struct sctpParamDesc *param;      /* add one to the local association */      if(addresstodel->sa_family == AF_INET){	struct sctpV4IpAddress *ipv4;	sz = sizeof(struct sctpV4IpAddress) + sizeof(struct sctpParamDesc);	param = (struct sctpParamDesc *)w_calloc(m,1,sz);	ipv4 = (struct sctpV4IpAddress *)((caddr_t)param + sizeof(struct sctpParamDesc));	param->paramType = htons(SCTP_DEL_IP_ADDRESS);	param->paramLength = ntohs(sz);	ipv4->p.paramType = htons(SCTP_IPV4_PARAM_TYPE);	ipv4->p.paramLength = htons(sizeof(struct sctpV4IpAddress));	ipv4->ipAddress = ((struct sockaddr_in *)addresstodel)->sin_addr.s_addr;      }else if(addresstodel->sa_family == AF_INET6){	struct sctpV6IpAddress *ipv6;	sz = sizeof(struct sctpV6IpAddress) + sizeof(struct sctpParamDesc);	param = (struct sctpParamDesc *)w_calloc(m,1,sz);	ipv6 = (struct sctpV6IpAddress *)((caddr_t)param + sizeof(struct sctpParamDesc));	param->paramType = htons(SCTP_DEL_IP_ADDRESS);	param->paramLength = ntohs(sz);	ipv6->p.paramType = htons(SCTP_IPV6_PARAM_TYPE);	ipv6->p.paramLength = htons(sizeof(struct sctpV6IpAddress));	memcpy(ipv6->ipAddress,((struct sockaddr_in6 *)addresstodel)->sin6_addr.s6_addr,	       sizeof(ipv6->ipAddress));      }else{	param = NULL;      }      if(param != NULL)	SCTPqueueARelReq(m,asoc,param,delay);    }  }else if(action & SCTP_ACTION_UPDATE_ALL_ASSOC){    int idxx;    SCTPdebugPrint(m,"Now do ALL association's delete\n");    SCTPdebugPrint(m,"Looking at ALL ASSOCIATION's\n");    asoc = m->assoc;    while(asoc != NULL){      if(asoc->supportsDynamicAddress == 0){	/* does not support it, just check its consistency and continue */	SCTPdebugPrint(m,"No dynamic support\n");	asoc->listConsistent = SCTPcheckListConsistency(m,							asoc,							asoc->localNets,asoc->numberOfNets);	continue;      }      if((asoc->listConsistent == 0) && (SCTPisToAddressInAssociation(m,asoc,addresstodel,								      &idxx,1) == 1)){	int sz;	struct sctpParamDesc *param;	SCTPdebugPrint(m,"Delete queued here idxx:%d!\n",idxx);	asoc->listConsistent = 0;      	asoc->addrStats[idxx] = SCTP_ADDR_BEING_DELETED;	if(addresstodel->sa_family == AF_INET){	  struct sctpV4IpAddress *ipv4;	  sz = sizeof(struct sctpV4IpAddress) + sizeof(struct sctpParamDesc);	  param = (struct sctpParamDesc *)w_calloc(m,1,sz);	  ipv4 = (struct sctpV4IpAddress *)((caddr_t)param + sizeof(struct sctpParamDesc));	  param->paramType = htons(SCTP_DEL_IP_ADDRESS);	  param->paramLength = ntohs(sz);	  ipv4->p.paramType = htons(SCTP_IPV4_PARAM_TYPE);	  ipv4->p.paramLength = htons(sizeof(struct sctpV4IpAddress));	  ipv4->ipAddress = ((struct sockaddr_in *)addresstodel)->sin_addr.s_addr;	}else if(addresstodel->sa_family == AF_INET6){	  struct sctpV6IpAddress *ipv6;	  sz = sizeof(struct sctpV6IpAddress) + sizeof(struct sctpParamDesc);	  param = (struct sctpParamDesc *)w_calloc(m,1,sz);	  ipv6 = (struct sctpV6IpAddress *)((caddr_t)param + sizeof(struct sctpParamDesc));	  param->paramType = htons(SCTP_DEL_IP_ADDRESS);	  param->paramLength = ntohs(sz);	  ipv6->p.paramType = htons(SCTP_IPV6_PARAM_TYPE);	  ipv6->p.paramLength = htons(sizeof(struct sctpV6IpAddress));	  memcpy(ipv6->ipAddress,((struct sockaddr_in6 *)addresstodel)->sin6_addr.s6_addr,		 sizeof(ipv6->ipAddress));	}else{	  param = NULL;	}	if(param != NULL)	  SCTPqueueARelReq(m,asoc,param,delay);      }      asoc = asoc->next;    }  }  return(1);}intsctpActionREMOTESETPRIMARY(struct SCTP *m,			   struct sockaddr *myaddress,			   struct SCTP_association *asoc,			   int action){  int fndLocal;  int delay;  /* First question: Does it already exist in the   * endpoint?   */  SCTPdebugPrint(m,"SET REMOTE PRIMARY!!!!!!!!!!!!!!!!!!!!!!!\n");  if(action & SCTP_ACTION_QUEUE_REQUEST_ONLY){    SCTPdebugPrint(m,"Delay ON!\n");    delay = 1;  }else{    SCTPdebugPrint(m,"Delay Off!\n");    delay = 0;  }  if(asoc->supportsDynamicSetPrim == 0){    /* peer does not support it */    SCTPdebugPrint(m,"No support sorry :<\n");    return(-2);  }  SCTPdebugPrint(m,"Is this a valid address in the assoc?\n");  fndLocal = SCTPisToAddressInAssociation(m,asoc,myaddress,NULL,0);  if(fndLocal == 1){    int sz;    struct sctpParamDesc *param;    if(myaddress->sa_family == AF_INET){      struct sctpV4IpAddress *ipv4;      SCTPdebugPrint(m,"Yep, activate set primary now!\n");      sz = sizeof(struct sctpV4IpAddress) + sizeof(struct sctpParamDesc);      param = (struct sctpParamDesc *)w_calloc(m,1,sz);      ipv4 = (struct sctpV4IpAddress *)((caddr_t)param + sizeof(struct sctpParamDesc));      param->paramType = htons(SCTP_SETADDRESS_PRIMARY);      param->paramLength = ntohs(sz);      ipv4->p.paramType = htons(SCTP_IPV4_PARAM_TYPE);      ipv4->p.paramLength = htons(sizeof(struct sctpV4IpAddress));      ipv4->ipAddress = ((struct sockaddr_in *)myaddress)->sin_addr.s_addr;    }else if(myaddress->sa_family == AF_INET6){      struct sctpV6IpAddress *ipv6;      sz = sizeof(struct sctpV6IpAddress) + sizeof(struct sctpParamDesc);      param = (struct sctpParamDesc *)w_calloc(m,1,sz);      ipv6 = (struct sctpV6IpAddress *)((caddr_t)param + sizeof(struct sctpParamDesc));      param->paramType = htons(SCTP_SETADDRESS_PRIMARY);      param->paramLength = ntohs(sz);      ipv6->p.paramType = htons(SCTP_IPV6_PARAM_TYPE);      ipv6->p.paramLength = htons(sizeof(struct sctpV6IpAddress));      memcpy(ipv6->ipAddress,	     ((struct sockaddr_in6 *)myaddress)->sin6_addr.s6_addr,	     sizeof(ipv6->ipAddress));    }else{      param = NULL;    }    if(param != NULL)      SCTPqueueARelReq(m,asoc,param,delay);    return(0);  }  /* address not found in association */  return(-3);}intsctpREMOTESETPRIMARYALL(struct SCTP *m,			struct sockaddr *myaddress,			int action){  int cnt;  struct SCTP_association *asoc;  int adrIndx;  asoc = m->assoc;  cnt = 0;  /* set myaddress in has the preferedRemPrimary too */  if(SCTPisToAddressInEndpoint(m,myaddress,&adrIndx) == 0)    /* myaddress does not exist */    return(-1);  SCTPdebugPrint(m,"Prefered remote primary is %d (%x)\n",		 adrIndx,(u_int)m->localNets[adrIndx]);  m->preferedRemPrimary = m->localNets[adrIndx];  SCTPdebugPrint(m,"setremote primary on all\n");  while(asoc != NULL){    cnt++;    sctpActionREMOTESETPRIMARY(m,myaddress,asoc,action);    asoc = asoc->next;  }  SCTPdebugPrint(m,"Invoked remsetprimary on %d associations\n",cnt);  return(0);}intsctpREMOTESETPRIMARY(struct SCTP *m,		     struct sockaddr *myaddress,		     struct sockaddr *to_ip,		     int action){  int whichNet;  struct SCTP_association *asoc;  asoc = SCTPfindAssociation(m,to_ip,&whichNet);  if(asoc == NULL){    /* Hmm can't find the association */    return(-1);  }  SCTPdebugPrint(m,"Found association\n");  return(sctpActionREMOTESETPRIMARY(m,myaddress,asoc,action));}intsctpSETV6DISABLE(struct SCTP *m,		 int val){  int old;  old = (int)m->disableV6;  m->disableV6 = (char)val;  return(old);}intsctpSET_DEFCOOKIELIFE(struct SCTP *m,		 int val){  int old;  old = m->defCookieLife;  m->defCookieLife = val;  return(old);}intsctpGET_DEFCOOKIELIFE(struct SCTP *m){  return(m->defCookieLife);}voidsctpPrintMappings(struct SCTP *m,struct sockaddr *to_ip,char *file){  int whichNet;  struct SCTP_association *asoc;  asoc = SCTPfindAssociation(m,to_ip,&whichNet);  printMappedArrays(asoc,file);}