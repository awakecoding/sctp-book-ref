/* SCTP reference Implementation Copyright (C) 2001 Cisco And MotorolaThis file is part of the SCTP reference ImplementationVersion:4.0.5$Header: /home/sourceTree/src/sctp/apps/sctpDeamon.c,v 1.22 2001/07/24 11:50:37 randall Exp $The SCTP reference implementation  is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published bythe Free Software Foundation; either version 2, or (at your option)any later version.the SCTP reference implementation  is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of                ************************MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See theGNU Library General Public License for more details.You should have received a copy of the GNU Library General Public Licensealong with GNU CC; see the file COPYING.  If not, write tothe Free Software Foundation, 59 Temple Place - Suite 330,Boston, MA 02111-1307, USA.  Please send any bug reports or fixes you make to one of the following emailaddresses:rrs@cisco.comkmorneau@cisco.comqxie1@email.mot.comAny bugs reported given to us we will try to fix... any fixes shared willbe incorperated into the next SCTP release.There are still LOTS of bugs in this code... I always run on the motto"it is a wonder any code ever works :)"*/#include <sctp.h>#include <sctputil.h>/* now get all the function declarations in */#include <stdio.h>#include <stdlib.h>#include <unistd.h>#include <sys/types.h>#include <netinet/in_systm.h>#include <netinet/in.h>#include <netinet/ip.h>#include <arpa/inet.h>#include <sys/ioctl.h>#include <sys/stat.h>#include <stdarg.h>#include <signal.h>#include <fcntl.h>#include <sys/socket.h>#if ! ( defined(LINUX) || defined(TRU64) || defined(AIX))#include <sys/sockio.h>#endif#include <time.h>#include <string.h>#ifdef LINUX#include <stropts.h>#endif#include <net/if.h>#include <errno.h>#include <netinet/ip_icmp.h>#include <sctpDeamonUtil.h>#include <poll.h>/* This is the RAW IP deamon. It has a very very * simple job to do. It listens to its three sockets * and reacts to them. No timers or anything fancy * is needed here. It does maintain a table of UDP * ports open on this machine that are accepting/expecting * SCTP. During the INITIALIZE() primitive in the library * there is a exchange that will happen between this deamon * and the UDP side. If a restart occurs of this deamon all * that state information is lost and things go south real * fast. To enhance this one might want to either * A) Have the deamon hold this state in shm. *   or * B) Have a re-registration ping between the deamon and the client *    happen every so often.  */char portSpace[65535];int icmpFd;	/* port open for ICMP messages */int ipFd; 	/* port open for RAW IP - the writer port */int ipFd6;	/* IPv6 socket */int ipRdFd;	/* port bound to SCTP protocol, the reader port */int ipRdFd6;int udpFd;	/* client access port, where UDP datagrams, come-go to *//* array of my networks and masks for each */int numberOfNets;int numberOfNetsAloced;struct sockaddr **localNets;struct sockaddr_in *maskList;int NOipV6;struct sockaddr_in *broadList;int max_mtu;intgetUDPport(){  /* First lets get the udp port in order. This is a well known   * udp port    */#ifdef AIX  size_t length;#else  int length;#endif  struct sockaddr_in inAddr,myAddr;  /* First lets check if we have the SCTP support in the kernel */  udpFd = socket(AF_INET, SOCK_DGRAM, IPPROTO_SCTP);  if(udpFd >= 0){    printf("SCTP deamon is not needed on this machine, kernel supports SCTP directly\n");    return(-1);  }  udpFd = socket(AF_INET, SOCK_DGRAM, 0);  if(udpFd < 0){    printf("Tragic error, can't open udp socket\n");    printf("You should either retry or check to see if a deamon is up?");    return(-1);  }  /* bind it to the deamon port of SCTP for UDP */  inAddr.sin_port = htons(SCTP_DEAMON_PORT);  inAddr.sin_family = AF_INET;  inAddr.sin_addr.s_addr = 0;  if(bind(udpFd,(struct sockaddr *)&inAddr, sizeof(inAddr)) < 0){    close(udpFd);    printf("Tragic error, can't bind udp socket\n");    printf("You should either retry or check to see if a deamon is up?");    return(-1);  }    /* now check to see if we got the port */  myAddr.sin_family = AF_INET;  length = sizeof(myAddr);  if(getsockname(udpFd,(struct sockaddr *)&myAddr,&length) < 0){    printf("Can't get the socket name errno:%d\n",errno);    printf("You should either retry or check to see if a deamon is up?");    close(udpFd);    return(-1);  }  if(SCTP_DEAMON_PORT != ntohs(myAddr.sin_port)){    close(udpFd);    printf("Can't get the deamon SCTP port:%d is another deamon up?\n",	   SCTP_DEAMON_PORT);    printf("You should either retry or check to see if a deamon is up?");    return(-1);  }  return(0);}/* Open 3 raw sockets:  * ipFd,   proto RAW (or SCTP) for writing, and set the send and receive buf to 32KB * icmp,   proto ICMP          for ICMP * ipRdFd, proto SCTP          for reading */intgetLoweLevelIP(){#if (defined(TRU64) || defined (FREEBSD) || defined(AIX))#ifdef WITH_IP_HDRINCL  int on = 1, tmpInt;#endif#endif  /* now the RAW IP socket */  /* SCTP_PB_6 */#ifdef WITH_IP_HDRINCL  ipFd = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);#else   ipFd = socket(AF_INET, SOCK_RAW, IPPROTO_SCTP);#endif    if(ipFd == -1){    close(udpFd);    return(-1);  }    NOipV6 = 0;  ipFd6 = socket(AF_INET6, SOCK_RAW, IPPROTO_RAW);  if(ipFd6 == -1){    NOipV6 = 1;  }  ipRdFd6 = socket(AF_INET6, SOCK_RAW, IPPROTO_SCTP);  if(ipRdFd6 == -1){    close(ipFd6);    ipFd6 = -1;    NOipV6 = 1;#ifdef LINUX  }else{    int onnow;    onnow = 1;    setsockopt(ipRdFd6,SOL_RAW,IP_HDRINCL,(char*)&onnow,sizeof(onnow));#endif  }#if (defined (TRU64) || defined (FREEBSD) || defined(AIX))  /* SCTP_PB_1 */  /* SCTP_PB_6 */#ifdef WITH_IP_HDRINCL  {      tmpInt = (32 * 1024);      if(setsockopt(ipFd,SOL_SOCKET,SO_RCVBUF,(char*)&tmpInt,sizeof(tmpInt))<0){	close(udpFd);	close(ipFd);	return(-1);      }      tmpInt = (32 * 1024);      if(setsockopt(ipFd,SOL_SOCKET,SO_SNDBUF,(char*)&tmpInt,sizeof(tmpInt))< 0){	close(udpFd);	close(ipFd);	return(-1);      }      if(setsockopt(ipFd,IPPROTO_IP,IP_HDRINCL,(char*)&on,sizeof(on))<0){	close(udpFd);	close(ipFd);	return(-1);      }    }#else #endif#endif  /* Now the ICMP socket please */  icmpFd = socket(AF_INET,SOCK_RAW,IPPROTO_ICMP);  if(icmpFd == -1){    printf("Strange, now I can't get the ICMP but I did get raw IP err:%d\n",errno);    close(udpFd);    close(ipFd);    return(-1);  }  /* Now lets get a IP socket bound to the SCTP protocol for reading */  ipRdFd = socket(AF_INET,SOCK_RAW,IPPROTO_SCTP);  if(ipRdFd == -1){    printf("Can't get SCTP socket? err:%d\n",errno);    close(udpFd);    close(ipFd);    close(icmpFd);    return(-1);  }  #if (defined(TRU64) || defined (FREEBSD) || defined(AIX))  {    /* SCTP_PB_1 */    /* SCTP_PB_6 */#ifdef WITH_IP_HDRINCL    {      if(setsockopt(ipRdFd,IPPROTO_IP,IP_HDRINCL,(char*)&on,sizeof(on))<0){	close(udpFd);	close(ipFd);	close(icmpFd);	return(-1);      }    }#else#endif  }#endif  return(0);}/* some systems, linux in particular do not define INFTIM i.e. -1 */#ifndef INFTIM#define INFTIM -1#endif/* This program must be run by root or suid root in order to open raw sockets. * We are using the root privileges _only_ when opening the raw sockets, and  * dropping them when not needed in order to avoid security problems. * Please be careful in the sequencing of lowerPrivileges()/raisePrivileges() * and other code. */intmain(){  int retVal,i;  struct pollfd fds[6];  int numFds;  if (checkPrivileges() < 0)      return(-1);  if (lowerPrivileges() < 0)      return(-1);  /* clear the port space */  memset(portSpace,0,sizeof(portSpace));  numberOfNets = 0;  localNets = NULL;  maskList = NULL;  if (DEAMONinitDebug() < 0)      printf("Warning: DEAMONinitDebug failed\n");  /* init the UDP port */  if(getUDPport()){    return(-1);  }  /* now get all the low level ip/icmp fd's */  if (raisePrivileges() < 0)      return(-1);  if(getLoweLevelIP()){    printf("Can't init low level IP, check to see if this is suid?\n");    return(-1);  }  if (lowerPrivileges() < 0)      return(-1);  if(NOipV6){    numFds = 4;  }else{    numFds = 6;  }  /* now we must gather all the address information */  if(SCTP_gatherAddresses(&localNets,&maskList,&broadList,			  &numberOfNets,			  &numberOfNetsAloced,			  &max_mtu,(int **)NULL,udpFd,1)){    printf("Sorry, no addresses no-worky\n");    close(udpFd);    close(ipFd);    close(icmpFd);    close(ipRdFd);    return(-1);  }  printf("Deamon finds %d networks that it will work on\n",numberOfNets);  for(i=0;i<numberOfNets;i++){    SCTPPrintAnAddress(localNets[i]);  }  /* setup the poll array */  fds[0].revents = 0;  fds[0].fd = udpFd;  fds[0].events = POLLIN | POLLPRI;  fds[1].revents = 0;  fds[1].fd = ipFd;  fds[1].events = POLLIN | POLLPRI;  fds[2].revents = 0;  fds[2].fd = icmpFd;  fds[2].events = POLLIN | POLLPRI;  fds[3].revents = 0;  fds[3].fd = ipRdFd;  fds[3].events = POLLIN | POLLPRI;  if(NOipV6){    fds[4].revents = 0;    fds[4].fd = -1;    fds[4].events = 0;    fds[5].revents = 0;    fds[5].fd = -1;    fds[5].events = 0;  }else{    fds[4].revents = 0;    fds[4].fd = ipFd6;    fds[4].events = POLLIN | POLLPRI;    fds[5].revents = 0;    fds[5].fd = ipRdFd6;    fds[5].events = POLLIN | POLLPRI;  }  /* ok all internal structures are setup lets go to our    * infinite loop.   */  while(1){    /* Forever poll on a input */    retVal = poll(fds, numFds, INFTIM);    if(fds[0].revents){      /* a client is either registering or sending        * if registering we respond, otherwise the       * datgram is sent to the IP side (ipFd).       */      DeamonHandleClient(udpFd,fds[0].revents);      fds[0].revents = 0;    }    if(fds[1].revents){      /* a RAW IP read happened ? maybe write? */      DeamonHandleipFd(ipFd,fds[1].revents);      fds[1].revents = 0;    }    if(fds[2].revents){      /* A icmp event occured, this may be sent to       * the UDP socket (udpFd)       */      DeamonHandleicmpFd(icmpFd,fds[2].revents);      fds[2].revents = 0;    }    if(fds[3].revents){      /* a IP read occured on the SCTP IP socket              * this will cross write to the UDP socket maybe        * (udpIp).       */      DeamonHandleRdIpFd(ipRdFd,fds[3].revents);      fds[3].revents = 0;    }    if(fds[4].revents){      DeamonHandleRdIp6Fd(ipFd6,fds[4].revents);      fds[4].revents = 0;    }    if(fds[5].revents){      DeamonHandleRdIp6Fd(ipRdFd6,fds[4].revents);      fds[5].revents = 0;    }  }    DEAMONcloseDebug();}