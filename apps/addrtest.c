/* SCTP reference Implementation Copyright (C) 2001 Cisco And MotorolaThis file is part of the SCTP reference ImplementationVersion:4.0.5$Header: /home/sourceTree/src/sctp/apps/addrtest.c,v 1.11 2001/07/24 11:50:36 randall Exp $The SCTP reference implementation  is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published bythe Free Software Foundation; either version 2, or (at your option)any later version.the SCTP reference implementation  is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of                ************************MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See theGNU Library General Public License for more details.You should have received a copy of the GNU Library General Public Licensealong with GNU CC; see the file COPYING.  If not, write tothe Free Software Foundation, 59 Temple Place - Suite 330,Boston, MA 02111-1307, USA.  Please send any bug reports or fixes you make to one of the following emailaddresses:rrs@cisco.comkmorneau@cisco.comqxie1@email.mot.comAny bugs reported given to us we will try to fix... any fixes shared willbe incorperated into the next SCTP release.There are still LOTS of bugs in this code... I always run on the motto"it is a wonder any code ever works :)"*/#include <sctp.h>#include <sctpinbound.h>#include <md5driver.h>#include <sctpsenders.h>#include <sctpHeader.h>#include <sys/time.h>#include <netdb.h>#include <sctpinitiate.h>#include <dlist.h>#include <unistd.h>#include <sctputil.h>#ifdef SOLARIS/* Solaris does not define the MTU macro so we will */#define	ifr_mtu		ifr_ifru.ifru_index	/* mtu			*/#endifintMY_gatherAddresses(struct sockaddr ***localNets1,		     struct sockaddr_in **maskList1,		     struct sockaddr_in **broadList1,		     int *numberOfNets1,		     int *numberOfNetsAloc,		     int *max_mtu,		     int **mtuList1,		     int fd1,		     int includeLoopback		     ){#ifdef LINUX#define LINUX_PROC_IPV6_FILE "/proc/net/if_inet6"  int addedNets;  char addrBuffer[256];  char addrBuffer2[64];  FILE *v6list;#endif  unsigned short intf_flags;  struct ifconf cf;  int at,copSiz,i;  char buffer[8192];  struct sockaddr **localNets;  struct sockaddr_in *maskList;  struct sockaddr_in *broadList;  struct sockaddr *toUse;  int *mtuList,oldnumnet;  int numberOfNets,saveMTU;#ifdef HAS_SIOCGLIFADDR  struct if_laddrreq lifaddr;#endif  struct ifreq local;  struct ifreq *ifrequest,*nextif;  int numAlocAddr,ii;  cf.ifc_buf = buffer;  cf.ifc_len = 8192;  *max_mtu = 0;  at = 0;  /* First copy into local variables things */  localNets = *localNets1;  maskList = *maskList1;  broadList = *broadList1;  if(mtuList1 != NULL)    mtuList = *mtuList1;  else    mtuList = NULL;  /* free up anything that was allocated before, this   * module is designed to be called multiple times   */  oldnumnet = *numberOfNets1;  if(localNets != NULL){    for(i=0;i<oldnumnet;i++){      if(localNets[i] != NULL){	free(localNets[i]);      }    }    free(localNets);    *localNets1 = localNets = NULL;  }  if(maskList != NULL){    free(maskList);    *maskList1 = maskList = NULL;  }  if(broadList != NULL){    free(broadList);    *broadList1 = broadList = NULL;  }  if(mtuList != NULL){    free(mtuList);    *mtuList1 = mtuList = NULL;  }  numberOfNets = 0;  saveMTU = DEFAULT_MTU_CEILING;  /* Now gather the master address information */  if(ioctl(fd1, SIOCGIFCONF, (char *)&cf) == -1){    return(-1);  }  /* Here we must count the acutal number of used struct's since   * we can't just do a calculation   */  numAlocAddr = 0;#ifdef USES_BSD_4_4_SOCKET  for(at=0;at < cf.ifc_len;){    ifrequest = (struct ifreq *)&buffer[at];    at += (ifrequest->ifr_addr.sa_len + sizeof(ifrequest->ifr_name));    if(ifrequest->ifr_addr.sa_len == 0){      /* if the interface has no address then you must       * skip at a minium a sockaddr structure       */      at += sizeof(struct sockaddr);    }    numAlocAddr++;  }#else  numAlocAddr = cf.ifc_len / sizeof(struct ifreq);  numAlocAddr++;  ifrequest = cf.ifc_req;#endif#ifdef LINUX  addedNets = 0;  v6list = fopen(LINUX_PROC_IPV6_FILE,"r");  if(v6list != NULL){    while(fgets(addrBuffer,sizeof(addrBuffer),v6list) != NULL){      addedNets++;    }    fclose(v6list);  }  numAlocAddr += addedNets;#endif  /* now allocate the appropreate memory */  localNets = calloc(numAlocAddr,sizeof(struct sockaddr *));  if(localNets == NULL){    errno = ENOMEM;    return(-2);  }  for(i=0;i<numAlocAddr;i++){    localNets[i] = NULL;  }  maskList = calloc(numAlocAddr,sizeof(struct sockaddr_in));  if(maskList == NULL){    errno = ENOMEM;    free(localNets);    localNets = NULL;    return(-3);  }  broadList = calloc(numAlocAddr,sizeof(struct sockaddr_in));  if(broadList == NULL){    errno = ENOMEM;    free(localNets);    free(maskList);    localNets = NULL;    maskList = NULL;    return(-1);  }  if(mtuList1 != NULL){    mtuList = calloc(numAlocAddr,sizeof(int));  }  at = 0;  /* Now we go through and pull each one */#ifdef LINUX  v6list = fopen(LINUX_PROC_IPV6_FILE,"r");  if(v6list != NULL){    struct sockaddr_in6 sin6;    memset((char *)&sin6,0,sizeof(sin6));          sin6.sin6_family = AF_INET6;    while(fgets(addrBuffer,sizeof(addrBuffer),v6list) != NULL){      /* skip loopback */      if(strncmp(addrBuffer,"00000000000000000000",20) == 0)	continue;      memset(addrBuffer2,0,sizeof(addrBuffer2));      strncpy(addrBuffer2,addrBuffer,4);      addrBuffer2[4] = ':';      strncpy(&addrBuffer2[5],&addrBuffer[4],4);      addrBuffer2[9] = ':';      strncpy(&addrBuffer2[10],&addrBuffer[8],4);      addrBuffer2[14] = ':';      strncpy(&addrBuffer2[15],&addrBuffer[12],4);      addrBuffer2[19] = ':';      strncpy(&addrBuffer2[20],&addrBuffer[16],4);      addrBuffer2[24] = ':';      strncpy(&addrBuffer2[25],&addrBuffer[20],4);      addrBuffer2[29] = ':';      strncpy(&addrBuffer2[30],&addrBuffer[24],4);      addrBuffer2[34] = ':';      strncpy(&addrBuffer2[35],&addrBuffer[28],4);      if(inet_pton(AF_INET6,addrBuffer2,(void *)&sin6.sin6_addr)){	localNets[numberOfNets] = calloc(1,sizeof(struct sockaddr_in6));	if(localNets[numberOfNets] != NULL){	  memcpy(localNets[numberOfNets],&sin6,sizeof(sin6));	  numberOfNets++;	}      }else{	printf("Could not translate string %s",addrBuffer2);      }    }    fclose(v6list);  }#endif  /* set to the start, i.e. buffer[0] */  ifrequest = (struct ifreq *)&buffer[at];  for(ii=0;ii<numAlocAddr;ii++,ifrequest=nextif){    /* use the sa_len to calculate where the next one will be */#ifdef USES_BSD_4_4_SOCKET    at += (ifrequest->ifr_addr.sa_len + sizeof(ifrequest->ifr_name));    if(ifrequest->ifr_addr.sa_len == 0){      /* if the interface has no address then you must       * skip at a minium a sockaddr structure       */      at += sizeof(struct sockaddr);    }    nextif = (struct ifreq *)&buffer[at];#else    nextif = ifrequest + 1;#endif#ifdef _NO_SIOCGIFMTU_    *max_mtu = DEFAULT_MTU_CEILING;#else    memset(&local,0,sizeof(local));    memcpy(local.ifr_name,ifrequest->ifr_name,IFNAMSIZ);    if(ioctl(fd1, SIOCGIFMTU, (char *)&local) == -1){      /* cant get the flags? */      continue;    }    saveMTU = local.ifr_mtu;#endif    toUse = &ifrequest->ifr_addr;    memset(&local,0,sizeof(local));    memcpy(local.ifr_name,ifrequest->ifr_name,IFNAMSIZ);    if(ioctl(fd1, SIOCGIFFLAGS, (char *)&local) == -1){      /* can't get the flags, skip this guy */      return(-1);    }    /* Ok get the address and save the flags */    intf_flags = local.ifr_flags;    if(includeLoopback == 0){      if((intf_flags & IFF_LOOPBACK) == IFF_LOOPBACK){	/* skip the loopback */	continue;      }    }    if(toUse->sa_family == AF_INET6){      if(IN6_IS_ADDR_LOOPBACK(&((struct sockaddr_in6 *)(toUse))->sin6_addr)){	continue;      }      if(IN6_IS_ADDR_UNSPECIFIED(&((struct sockaddr_in6 *)(toUse))->sin6_addr)){	continue;      }    }#if ! (defined (LINUX))    if(toUse->sa_family == AF_LINK){      printf("Saw link layer address for %s type:%d\n",	     ifrequest->ifr_name,toUse->sa_family);      SCTPPrintAnAddress(toUse);    }#endif    if((toUse->sa_family != AF_INET) &&       (toUse->sa_family != AF_INET6)){      /* nop, must be some other protocol */      continue;    }    if(toUse->sa_family == AF_INET){      if(((struct sockaddr_in *)(toUse))->sin_addr.s_addr == 0){	/* if it does not have a IP address set in, we will skip it */	continue;      }      localNets[numberOfNets] = calloc(1,sizeof(struct sockaddr_in));      copSiz = sizeof(struct sockaddr_in);    }else if(toUse->sa_family == AF_INET6){      if(IN6_IS_ADDR_UNSPECIFIED(&(((struct sockaddr_in6 *)(toUse))->sin6_addr))){	continue;      }      localNets[numberOfNets] = calloc(1,sizeof(struct sockaddr_in6));      copSiz = sizeof(struct sockaddr_in6);    }    /* Now, we may have already gathered this address, if so skip     * it     */    if(*max_mtu < saveMTU){      *max_mtu = saveMTU;    }    if(numberOfNets){      int dup,xxx;      dup = 0;      /* scan for the dup */      for(xxx=0;xxx<numberOfNets;xxx++){	/* family's must match */	if(localNets[xxx]->sa_family != toUse->sa_family)	  continue;	if(localNets[xxx]->sa_family == AF_INET){	  if(((struct sockaddr_in *)(toUse))->sin_addr.s_addr == 	     ((struct sockaddr_in *)localNets[xxx])->sin_addr.s_addr){	    /* set the flag and break, it is a dup */	    dup = 1;	    break;	  }	}else{	  if(IN6_ARE_ADDR_EQUAL(&(((struct sockaddr_in6 *)(toUse))->sin6_addr),				&(((struct sockaddr_in6 *)localNets[xxx])->sin6_addr))){	    /* set the flag and break, it is a dup */	    dup = 1;	    break;	  }	}      }      if(dup){	/* skip the duplicate name/address we already have it*/	free(localNets[numberOfNets]);	localNets[numberOfNets] = NULL;	continue;      }    }    /* copy address */    memcpy(localNets[numberOfNets],(char *)toUse,copSiz);    if(mtuList1 != NULL){      if(mtuList != NULL)	mtuList[numberOfNets] = saveMTU;    }    /* set family */    localNets[numberOfNets]->sa_family = toUse->sa_family;#ifdef USES_BSD_4_4_SOCKET    /* copy the length */    localNets[numberOfNets]->sa_len = toUse->sa_len;#endif    if(localNets[numberOfNets]->sa_family == AF_INET){      int localfd;      localfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);      memset(&local,0,sizeof(local));      memcpy(&local,ifrequest,sizeof(local));      if(ioctl(localfd, SIOCGIFNETMASK, (char *)&local) == -1){	/* no netmask, sigh oh well we keep the address anyway */	numberOfNets++;	close(localfd);	continue;      }      /* copy the address */      memset(maskList[numberOfNets].sin_zero,	     0,sizeof(maskList[numberOfNets].sin_zero));      maskList[numberOfNets].sin_addr.s_addr = ((struct sockaddr_in *)&local.ifr_addr)->sin_addr.s_addr;      /* zero the port */      maskList[numberOfNets].sin_port = 0;      /* zero the zero area */#ifdef USES_BSD_4_4_SOCKET      /* copy the length */      maskList[numberOfNets].sin_len = local.ifr_addr.sa_len;#endif      /* set the family type */      maskList[numberOfNets].sin_family = AF_INET;      /* Get the broadcast address */      memset(&local,0,sizeof(local));      memcpy(local.ifr_name,ifrequest->ifr_name,IFNAMSIZ);      if(ioctl(localfd,SIOCGIFBRDADDR,(char *)&local) == -1){	numberOfNets++;	close(localfd);	continue;      }      close(localfd);      memset(broadList[numberOfNets].sin_zero,	     0,sizeof(broadList[numberOfNets].sin_zero));      broadList[numberOfNets].sin_addr.s_addr = ((struct sockaddr_in *)&local.ifr_addr)->sin_addr.s_addr;      broadList[numberOfNets].sin_port = 0;#ifdef USES_BSD_4_4_SOCKET      /* copy the length */      broadList[numberOfNets].sin_len = local.ifr_addr.sa_len;#endif      /* ok we are done, increment the number of addresses */      numberOfNets++;    }else{      /* AF_INET6 has no mask or broadcast addr, at least that we care about */	    struct sockaddr_in6 *s6;	    memset(&maskList[numberOfNets],0,sizeof(struct sockaddr_in));	    memset(&broadList[numberOfNets],0,sizeof(struct sockaddr_in));	    s6 = (struct sockaddr_in6 *)localNets[numberOfNets];	    if((IN6_IS_ADDR_LINKLOCAL(&s6->sin6_addr) &&		*(u_short *)&s6->sin6_addr.s6_addr[2] != 0)){		    /* KAME HACK: to pull out embedded link local scope */		    u_short index;		    index = *(u_short *)&s6->sin6_addr.s6_addr[2];		    *(u_short *)&s6->sin6_addr.s6_addr[2] = 0;		    if (s6->sin6_scope_id == 0)			    s6->sin6_scope_id = ntohs(index);	    }	    numberOfNets++;    }  }  /* copy the new values back in */  *localNets1 = localNets;  *maskList1 = maskList;  *broadList1 = broadList;  *numberOfNets1 = numberOfNets;  *numberOfNetsAloc = numAlocAddr;  if(mtuList1 != NULL){    *mtuList1 = mtuList;  }  return(0);}extern char *optarg;extern int optind;extern int optopt;extern int opterr;extern int optreset;intmain(int argc, char **argv){  struct sockaddr **list;  int num,numaloc,maxmtu,*mtulist;  struct sockaddr_in *mask,*broad;  int fd,c;  int includeloop;  includeloop = 0;  mask = broad = NULL;  mtulist = NULL;  list = NULL;  fd = -1;  while((c = getopt(argc,argv,"suSUl?")) != -1){    switch(c){    case 's':      if(fd != -1)	close(fd);      fd = socket(AF_INET6, SOCK_DGRAM, IPPROTO_SCTP);      break;    case 'u':      if(fd != -1)	close(fd);      fd = socket(AF_INET6, SOCK_DGRAM, IPPROTO_UDP);      break;    case 'U':      if(fd != -1)	close(fd);      fd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);      break;    case 'S':      if(fd != -1)	close(fd);      fd = socket(AF_INET6, SOCK_DGRAM, IPPROTO_SCTP);      break;    case 'l':      includeloop = 1;      break;    case '?':    default:      printf("Use %s one of -s | -u | -S | -U [-l]\n",argv[0]);      return(0);    };  }  if(fd == -1){    printf("Use %s one of -s | -u | -S | -U [-l]\n",argv[0]);    return(-1);  }  MY_gatherAddresses(&list,&mask,&broad,&num,&numaloc,&maxmtu,&mtulist,fd,includeloop);  printf("I got %d addresses (aloc'd %d)\n",num,numaloc);  for(c=0;c<numaloc;c++){    if(list[c] != NULL){      printf("list[%d]=",c);      SCTPPrintAnAddress(list[c]);    }else{      printf("list[%d]=<NULL>\n",c);    }  }  return(0);}