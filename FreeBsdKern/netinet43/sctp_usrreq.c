/* * Copyright (c) 2001 Cisco Systems Inc. * Copyright (c) 1982, 1986, 1989, 1993 *	The Regents of the University of California.  All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in the *    documentation and/or other materials provided with the distribution. * 3. All advertising materials mentioning features or use of this software *    must display the following acknowledgement: *	This product includes software developed by the University of *	California, Berkeley and its contributors. * 4. Neither the name of the University nor the names of its contributors *    may be used to endorse or promote products derived from this software *    without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * * $Header: /home/sourceTree/src/sctp/FreeBsdKern/netinet43/sctp_usrreq.c,v 1.4 2001/04/30 17:57:10 randall Exp $ */#include "opt_ipsec.h"#include "opt_inet6.h"#include <stddef.h>#include <sys/param.h>#include <sys/systm.h>#include <sys/kernel.h>#include <sys/malloc.h>#include <sys/mbuf.h>#include <sys/domain.h>#include <sys/proc.h>#include <sys/protosw.h>#include <sys/socket.h>#include <sys/socketvar.h>#include <sys/sysctl.h>#include <sys/syslog.h>#include <vm/vm_zone.h>#include <net/if.h>#include <net/route.h>#include <netinet/in.h>#include <netinet/in_systm.h>#include <netinet/ip.h>#ifdef INET6#include <netinet/ip6.h>#endif#include <netinet/in_pcb.h>#include <netinet/in_var.h>#include <netinet/ip_var.h>#ifdef INET6#include <netinet6/ip6_var.h>#endif#include <netinet/ip_icmp.h>#include <netinet/icmp_var.h>#include <netinet/sctp.h>#include <netinet/sctp_var.h>#ifdef IPSEC#include <netinet6/ipsec.h>#endif /*IPSEC*/#include <machine/in_cksum.h>/* * SCTP protocol implementation. * This is the a small amount of the * actual implementation. Most is in * a user library in the application space. */struct	inpcbhead sctpdb;#define	udb6	udb  /* for KAME src sync over BSD*'s */struct	inpcbinfo sctpinfo;#ifndef SCTPHASHSIZE#define SCTPHASHSIZE 16#endifstruct	sctpstat sctpstat;int sctpSwitch=0;SYSCTL_STRUCT(_net_inet_sctp, SCTPCTL_STATS, stats, CTLFLAG_RD,    &sctpstat, sctpstat,	      "SCTP statistics (struct sctpstat, netinet/sctp_var.h)");static struct	sockaddr_in sctp_in = { sizeof(sctp_in), AF_INET };#ifdef INET6struct sctp_in6 {	struct sockaddr_in6	sin6_sin;	u_char			sin6_init_done : 1;} sctp_in6 = {	{ sizeof(sctp_in6.sin6_sin), AF_INET6 },	0};struct sctp_ip6 {	struct ip6_hdr		sip6_ip6;	u_char			sip6_init_done : 1;} sctp_ip6;#endif /* INET6 */#ifdef INET6static void ip_2_ip6_hdr __P((struct ip6_hdr *ip6, struct ip *ip));#endifstatic int sctp_detach __P((struct socket *so));static	int sctp_output __P((struct inpcb *, struct mbuf *, struct sockaddr *,			    struct mbuf *, struct proc *));voidsctp_init(){	LIST_INIT(&sctpdb);	sctpSwitch = 0;	sctpinfo.listhead = &sctpdb;	sctpinfo.hashbase = hashinit(SCTPHASHSIZE, M_PCB, &sctpinfo.hashmask);	sctpinfo.porthashbase = hashinit(SCTPHASHSIZE, M_PCB,					&sctpinfo.porthashmask);	sctpinfo.ipi_zone = zinit("sctppcb", sizeof(struct inpcb), maxsockets,				 ZONE_INTERRUPT, 0);}staticunsigned long sctp_update_adler32(unsigned long adler,				  unsigned char *buf, int len){  unsigned long s1 = adler & 0xffff;  unsigned long s2 = (adler >> 16) & 0xffff;  int n;  for (n = 0; n < len; n++,buf++) {    s1 = (s1 + *buf);    if(s1 >= SCTP_ADLER32_BASE){      s1 -= SCTP_ADLER32_BASE;    }    s2 = (s2 + s1);    if(s2 >= SCTP_ADLER32_BASE){      s2 -= SCTP_ADLER32_BASE;    }  }  return (s2 << 16) + s1;}unsigned int sctp_calc_alder32(unsigned char *ptr,			       unsigned short  count){  unsigned int adler = 1L;  adler = sctp_update_adler32(adler, ptr, count);  return(adler);}intSCTPisThereAnAbortHere(struct mbuf *m,int off){  /* check the inbound datagram to make sure there   * is not an abort inside it, if there is return 1   * else return 0.   */  struct sctpChk desc;  int at,x;  at = off + sizeof(struct sctphdr);  while((at+sizeof(struct sctpChk)) < m->m_pkthdr.len){    m_copydata(m, at, sizeof(struct sctpChk),(caddr_t)&desc);    x = desc.chunkLength;    NTOHS(x);    /* Is it to small? */    if(x < sizeof(struct sctpChk)){      /* packet is probably corrupt */      printf("Gak, possible corrupt packet with chk len:%d\n",x);      break;    }    /* is it to large? */    if((x+at) > m->m_pkthdr.len){      /* packet is probably corrupt */      printf("Gak, possible corrupt packet with chk len:%d max:%d (at:%d)\n",	     x,	     m->m_pkthdr.len,	     at);      break;    }    /* we seem to be ok, is it an abort? */    if(desc.chunkID == SCTP_ABORT_ASSOCIATION){      /* yep, tell them */      printf("Found an ABORT, don't reply!!\n");      return(1);    }    /* Nope, move to the next chunk */    at += x;  }  return(0);}static voidsctp_send_abort(struct mbuf *m,		struct ip *oip,		struct sctphdr *osh,		int off){  /*   * Formulate the abort message, and send it back down.   */  register struct mbuf *mout;  register struct sctpAbort *abm;  register struct ip *iph;  struct route ro;  int abtlen;  unsigned int val;  if(SCTPisThereAnAbortHere(m,off)){    return;  }  mout = m_gethdr(M_DONTWAIT, MT_HEADER);  if (mout == NULL){    m_freem(m);    return;  }  abtlen = sizeof(struct sctpAbort) + sizeof(struct ip);  mout->m_len = abtlen;  iph = mtod(mout, struct ip *);  /* Fill in the IP header for the ABORT */  iph->ip_hl = (sizeof(struct ip)/4);  iph->ip_v = IPVERSION;  iph->ip_tos = (u_char)0;  iph->ip_len = sizeof(struct ip) + sizeof(struct sctpAbort);  iph->ip_id = 0;  iph->ip_off = 0;  iph->ip_ttl = MAXTTL;  iph->ip_p = IPPROTO_SCTP;  iph->ip_src.s_addr = oip->ip_dst.s_addr;  iph->ip_dst.s_addr = oip->ip_src.s_addr;  /* let IP layer calculate this */  iph->ip_sum = 0;  /* Now copy in and fill in the ABORT tags etc. */  /*  osh = (struct sctphdr *) ((caddr_t)oip + (oip->ip_hl << 2));*/  abm = (struct sctpAbort *) ((caddr_t)iph + (iph->ip_hl << 2));  abm->mh.source = osh->destination;  abm->mh.destination = osh->source;  abm->mh.adler32 = 0;  abm->mh.verificationTag = osh->verificationTag;  abm->uh.chunkID = SCTP_ABORT_ASSOCIATION;  abm->uh.chunkFlg = SCTP_HAD_NO_TCB;  abm->uh.chunkLength = 4;  HTONS(abm->uh.chunkLength);  val = sctp_calc_alder32((unsigned char *)abm,sizeof(struct sctpAbort));  abm->mh.adler32 = HTONL(val);  /* zap the rcvif, it should be null */  mout->m_pkthdr.len = mout->m_len;  mout->m_pkthdr.rcvif = 0;  /* zap the stack pointer to the route */  bzero(&ro, sizeof ro);  /* out it goes */  (void) ip_output(mout, 0, &ro, IP_RAWOUTPUT, NULL);  /* Free the route if we got one back */  if (ro.ro_rt)    RTFREE(ro.ro_rt);  m_freem(m);}voidsctp_input(m, off, proto)	register struct mbuf *m;	int off, proto;{	int iphlen = off;	register struct ip *ip;	register struct sctphdr *sh;	register struct inpcb *inp;	struct mbuf *opts = 0;	struct sockaddr *append_sa;	sctpstat.sctp_ipackets++;	/*	 * Strip IP options, we don't allow any in or out.	 */	if (iphlen > sizeof (struct ip)) {		ip_stripoptions(m, (struct mbuf *)0);		iphlen = sizeof(struct ip);	}	/*	 * Get IP and SCTP header together in first mbuf.	 */	ip = mtod(m, struct ip *);	if (m->m_len < iphlen + sizeof(struct sctphdr)) {		if ((m = m_pullup(m, iphlen + sizeof(struct sctphdr))) == 0) {			sctpstat.sctp_hdrops++;			return;		}		ip = mtod(m, struct ip *);	}	sh = (struct sctphdr *)((caddr_t)ip + iphlen);	/* destination port of 0 is illegal, based on RFC2960. */	if (sh->destination == 0)		goto bad;	if (IN_MULTICAST(ntohl(ip->ip_dst.s_addr)) ||	    in_broadcast(ip->ip_dst, m->m_pkthdr.rcvif)) {	  /* SCTP does not allow broadcasts or Multi-casts */	  sctpstat.sctp_bcastmcast++;	  	  goto bad;	}	/*	 * Locate pcb for datagram.	 */	inp = in_pcblookup_hash(&sctpinfo, ip->ip_src, sh->source,	    ip->ip_dst, sh->destination, 1, m->m_pkthdr.rcvif);	if (inp == NULL){		sctpstat.sctp_noport++;#ifdef ICMP_BANDLIM		/* we use the bandwidth limiting to protect		 * against sending to many ABORTS all at once.		 * In this case these count the same as a 		 * icmp message.		 */		if (badport_bandlim(0) < 0)			goto bad;#endif		sctp_send_abort(m,ip,sh,off);		return;	}#ifdef IPSEC	/* I very much doubt any of the IPSEC stuff will	 * work but I have no idea, so I will leave it	 * in place.	 */	if (ipsec4_in_reject_so(m, inp->inp_socket)) {		ipsecstat.in_polvio++;		goto bad;	}#endif /*IPSEC*/	/*	 * Construct sockaddr format source address.	 * Stuff source address and datagram in user buffer.	 */	sctp_in.sin_port = sh->source;	sctp_in.sin_addr = ip->ip_src;	if (inp->inp_flags & INP_CONTROLOPTS	    || inp->inp_socket->so_options & SO_TIMESTAMP) {#ifdef INET6		if (inp->inp_vflag & INP_IPV6) {			int savedflags;			ip_2_ip6_hdr(&sctp_ip6.sip6_ip6, ip);			savedflags = inp->inp_flags;			inp->inp_flags &= ~INP_UNMAPPABLEOPTS;			ip6_savecontrol(inp, &opts, &sctp_ip6.sip6_ip6, m);			inp->inp_flags = savedflags;		} else#endif		ip_savecontrol(inp, &opts, ip, m);	}#ifdef INET6	if (inp->inp_vflag & INP_IPV6) {		in6_sin_2_v4mapsin6(&sctp_in, &sctp_in6.sin6_sin);		append_sa = (struct sockaddr *)&sctp_in6;	} else#endif	append_sa = (struct sockaddr *)&sctp_in;	if (sbappendaddr(&inp->inp_socket->so_rcv, append_sa, m, opts) == 0) {		sctpstat.sctp_fullsock++;		goto bad;	}	sorwakeup(inp->inp_socket);	return;bad:	m_freem(m);	if (opts)		m_freem(opts);	return;}#ifdef INET6static voidip_2_ip6_hdr(ip6, ip)	struct ip6_hdr *ip6;	struct ip *ip;{	bzero(ip6, sizeof(*ip6));	ip6->ip6_vfc = IPV6_VERSION;	ip6->ip6_plen = ip->ip_len;	ip6->ip6_nxt = ip->ip_p;	ip6->ip6_hlim = ip->ip_ttl;	ip6->ip6_src.s6_addr32[2] = ip6->ip6_dst.s6_addr32[2] =		IPV6_ADDR_INT32_SMP;	ip6->ip6_src.s6_addr32[3] = ip->ip_src.s_addr;	ip6->ip6_dst.s6_addr32[3] = ip->ip_dst.s_addr;}#endifvoidsctp_notify_mbuf(register struct inpcb *inp,		 register struct ip *ip,		 struct sockaddr *sa){  struct mbuf *mout;  struct ip *hin;  struct icmp *icmph,*icmpin;  u_short hlen;  /* This is gross and ugly, since ip_icmp.c   * does not do a m_pullup() on the icmp   * message I have no way to clone the   * full ICMP message. Instead I must   * generate one from what I have.   */  MGETHDR(mout, M_DONTWAIT, MT_HEADER);  if(mout == NULL){    /* gak nothing we can do */    return;  }  /* IP points to the portion of the ICMP that   * was my bad packet. Back up from this by   * the size of the other ICMP union will get   * the pointer to the icmp.   */  icmpin = (struct icmp *)((caddr_t)ip - (sizeof(struct icmp) -					  sizeof(struct ip)));  hin = mtod(mout,struct ip *);  icmph = (struct icmp *)((caddr_t)hin + sizeof(struct ip));    /* First we fabricate the IP header of the in IP, since   * we can't just backup over this since we have no   * idea how long the actual IP header is (with options) */  hin->ip_v = IPVERSION;  hin->ip_hl = (sizeof(struct ip) >> 2);  hin->ip_id = 0;  hin->ip_tos = 0;  hin->ip_off = 0;  hin->ip_ttl = 255;  hin->ip_p = IPPROTO_ICMP;  hin->ip_sum = 0;  hin->ip_src = ip->ip_dst;  hin->ip_dst = ip->ip_src;  /* This should be a total of 56 bytes + the residual header len */  /* For BSD ip_len is set to the actual packet size minus   * the header length, so we don't add the 20 bytes of the   * hin header and its all kept in host byte order.   */  /* calculate the actual size of bad IP header */  hlen = ip->ip_hl << 2;  /* hlen should reduce to 0 */  hlen -= sizeof(struct ip);  hin->ip_len = sizeof(struct icmp) + 8 + hlen;    /* Now that the IP header is filled in, we cacluate   * copy in from icmpin to icmph. hin->ip_len bytes.   */  memcpy(icmph,icmpin,hin->ip_len);  /* set in the mbuf lengths */  mout->m_len = (sizeof(struct ip) + 		 sizeof(struct icmp) + 8 + hlen);  mout->m_pkthdr.len = mout->m_len;  mout->m_pkthdr.rcvif = 0;  /* The address is setup in the sctp_ctlinput() routine */  if(sbappendaddr(&inp->inp_socket->so_rcv, sa, mout,		  (struct mbuf *)NULL) == 0) {    sctpstat.sctp_fullsock++;    m_freem(mout);    return;  }  sorwakeup(inp->inp_socket);}voidsctp_notify(inp, errno)	register struct inpcb *inp;	int errno;{  inp->inp_socket->so_error = errno;  sorwakeup(inp->inp_socket);  sowwakeup(inp->inp_socket);}voidsctp_ctlinput(cmd, sa, vip)	int cmd;	struct sockaddr *sa;	void *vip;{  register struct ip *ip = vip;  register struct sctphdr *sh;  int s;  struct in_addr faddr;  void (*notify) __P((struct inpcb *, int)) = sctp_notify;  if (PRC_IS_REDIRECT(cmd)) {    ip = 0;    notify = in_rtchange;  }else if (cmd == PRC_HOSTDEAD)    ip = 0;  else if ((unsigned)cmd >= PRC_NCMDS || inetctlerrmap[cmd] == 0)    return;  if(sa->sa_family != AF_INET ||      ((struct sockaddr_in *)sa)->sin_addr.s_addr == INADDR_ANY)    return;  faddr = ((struct sockaddr_in *)sa)->sin_addr;  if(ip){    register struct inpcb *inp;    sh = (struct sctphdr *)((caddr_t)ip + (ip->ip_hl << 2));    s = splnet();    /* This looks a bit strange but the ip points to the     * packet I sent. So I lookup in reverse fashion     */    inp = in_pcblookup_hash(&sctpinfo,			    ip->ip_dst, sh->destination, 			    ip->ip_src, sh->source,			    1, NULL);    if (inp != NULL && inp->inp_socket != NULL){      if(cmd != PRC_MSGSIZE){	(*notify)(inp, inetctlerrmap[cmd]);      }else{	sctp_notify_mbuf(inp,ip,sa);      }    }    splx(s);  }else{    in_pcbnotifyall(&sctpdb, faddr , cmd, notify);  }}static intsctp_pcblist(SYSCTL_HANDLER_ARGS){	int error, i, n, s;	struct inpcb *inp, **inp_list;	inp_gen_t gencnt;	struct xinpgen xig;	if (req->oldptr == 0) {		n = sctpinfo.ipi_count;		req->oldidx = 2 * (sizeof xig)			+ (n + n/8) * sizeof(struct xinpcb);		return 0;	}	if (req->newptr != 0)		return EPERM;	/*	 * OK, now we're committed to doing something.	 */	s = splnet();	gencnt = sctpinfo.ipi_gencnt;	n = sctpinfo.ipi_count;	splx(s);	xig.xig_len = sizeof xig;	xig.xig_count = n;	xig.xig_gen = gencnt;	xig.xig_sogen = so_gencnt;	error = SYSCTL_OUT(req, &xig, sizeof xig);	if (error)		return error;	inp_list = malloc(n * sizeof *inp_list, M_TEMP, M_WAITOK);	if (inp_list == 0)		return ENOMEM;		s = splnet();	for (inp = sctpinfo.listhead->lh_first, i = 0; inp && i < n;	     inp = inp->inp_list.le_next) {		if (inp->inp_gencnt <= gencnt && !prison_xinpcb(req->p, inp))			inp_list[i++] = inp;	}	splx(s);	n = i;	error = 0;	for (i = 0; i < n; i++) {		inp = inp_list[i];		if (inp->inp_gencnt <= gencnt) {			struct xinpcb xi;			xi.xi_len = sizeof xi;			/* XXX should avoid extra copy */			bcopy(inp, &xi.xi_inp, sizeof *inp);			if (inp->inp_socket)				sotoxsocket(inp->inp_socket, &xi.xi_socket);			error = SYSCTL_OUT(req, &xi, sizeof xi);		}	}	if (!error) {		/*		 * Give the user an updated idea of our state.		 * If the generation differs from what we told		 * her before, she knows that something happened		 * while we were processing this request, and it		 * might be necessary to retry.		 */		s = splnet();		xig.xig_gen = sctpinfo.ipi_gencnt;		xig.xig_sogen = so_gencnt;		xig.xig_count = sctpinfo.ipi_count;		splx(s);		error = SYSCTL_OUT(req, &xig, sizeof xig);	}	free(inp_list, M_TEMP);	return error;}SYSCTL_PROC(_net_inet_sctp, SCTPCTL_PCBLIST, pcblist, CTLFLAG_RD, 0, 0,	    sctp_pcblist, "S,xinpcb", "List of active SCTP sockets");static intsctp_getcred(SYSCTL_HANDLER_ARGS){	struct sockaddr_in addrs[2];	struct inpcb *inp;	int error, s;	error = suser(req->p);	if (error)		return (error);	error = SYSCTL_IN(req, addrs, sizeof(addrs));	if (error)		return (error);	s = splnet();	inp = in_pcblookup_hash(&sctpinfo, addrs[1].sin_addr, addrs[1].sin_port,				addrs[0].sin_addr, addrs[0].sin_port, 1, NULL);	if (inp == NULL || inp->inp_socket == NULL) {		error = ENOENT;		goto out;	}	error = SYSCTL_OUT(req, inp->inp_socket->so_cred, sizeof(struct ucred));out:	splx(s);	return (error);}SYSCTL_PROC(_net_inet_sctp, OID_AUTO, getcred, CTLTYPE_OPAQUE|CTLFLAG_RW,    0, 0, sctp_getcred, "S,ucred", "Get the ucred of a SCTP connection");static intsctp_output(inp, m, addr, control, p)	register struct inpcb *inp;	struct mbuf *m;	struct sockaddr *addr;	struct mbuf *control;	struct proc *p;{  register int len = m->m_pkthdr.len;  register struct ip *ip;  register struct sctphdr *sh;  int iphlen;  /*  struct route ro;*/  int error = 0, o_flgs = 0,s;  /* Currently we don't look at the attached   * control.   */  if (control)    m_freem(control);  /* Verify the packet size */  if (len > IP_MAXPACKET){    error = EMSGSIZE;    goto release;  }  /*   * Get IP and SCTP header together in first mbuf.   */  ip = mtod(m, struct ip *);  iphlen = (ip->ip_hl << 2);  if (m->m_len < iphlen + sizeof(struct sctphdr)) {    if ((m = m_pullup(m, iphlen + sizeof(struct sctphdr))) == 0) {      sctpstat.sctp_ohdrops++;      goto release;    }    ip = mtod(m, struct ip *);    iphlen = (ip->ip_hl << 2);  }  /* We don't allow the sending of ANY IP options */  if(iphlen > sizeof (struct ip)){    ip_stripoptions(m, (struct mbuf *)0);    iphlen = sizeof(struct ip);  }  /* Now get the SCTP header poistion */  sh = (struct sctphdr *)((caddr_t)ip + (ip->ip_hl << 2));    /* Now with IP header and SCTP header in hand, we must   * verify that the user is not cheating and filling   * in an alternate source address or port   */  if(sh->source != inp->inp_lport){    sctpstat.sctp_sendbadport++;    error = EFAULT;    goto release;  }  if(sh->destination == 0){    sctpstat.sctp_sendbadport++;    error = EFAULT;    goto release;  }  /* If an address WAS specified, we   * must validate that it IS one of   * our addresses, if not the IP   * stack will use the outgoing   * interface address.   */  if(ip->ip_dst.s_addr == INADDR_ANY){    sctpstat.sctp_sendbadaddr++;    error = EFAULT;    goto release;  }  if(ip->ip_src.s_addr != INADDR_ANY){    struct ifaddr *ifa;    struct sockaddr_in tmp;    /* Fill up the sockaddr_in and see     * if a interface is really bound here     */    memset(&tmp,0,sizeof(tmp));    tmp.sin_family = AF_INET;    tmp.sin_len = sizeof(tmp);    tmp.sin_addr.s_addr = ip->ip_src.s_addr;        ifa = ifa_ifwithaddr((struct sockaddr *)&tmp);    if(ifa == NULL){      /* Will not send a packet that is not from       * one of my source addresses.       */      sctpstat.sctp_sendbadaddr++;      error = EFAULT;      goto release;    }  }  /* You better have filled in the IP header */  if(ip->ip_hl != (sizeof(struct ip)/4)){    sctpstat.sctp_badpktfmt++;    error = EFAULT;    goto release;  }  if(ip->ip_v != IPVERSION){    sctpstat.sctp_badpktfmt++;    error = EFAULT;    goto release;  }  if(ip->ip_len > m->m_pkthdr.len){    sctpstat.sctp_badpktfmt++;    error = EFAULT;    goto release;  }  s = splnet();#ifdef IPSEC  ipsec_setsocket(m, inp->inp_socket);#endif /*IPSEC*/  /*  bzero(&ro, sizeof ro);*/  /* Fix up routing information if needed */  if(inp->inp_route.ro_dst.sa_family != AF_INET){    if(inp->inp_route.ro_rt){      RTFREE(inp->inp_route.ro_rt);    }    inp->inp_route.ro_rt = 0;        bzero(&inp->inp_route.ro_dst,sizeof(struct sockaddr_in));  }else{    struct sockaddr_in *dst;    dst = (struct sockaddr_in *)&inp->inp_route.ro_dst;    if(dst->sin_addr.s_addr != ip->ip_dst.s_addr){      if(inp->inp_route.ro_rt){	RTFREE(inp->inp_route.ro_rt);      }      inp->inp_route.ro_rt = 0;          bzero(&inp->inp_route.ro_dst,sizeof(struct sockaddr_in));    }  }  o_flgs = (IP_RAWOUTPUT | (inp->inp_socket->so_options & (SO_DONTROUTE | SO_BROADCAST)));  /*  error = ip_output(m, inp->inp_options, &ro, o_flgs,inp->inp_moptions);*/  error = ip_output(m, inp->inp_options, &inp->inp_route, o_flgs,inp->inp_moptions);  /*  if (ro.ro_rt)*/  /*    RTFREE(ro.ro_rt);*/  return (error); release:  m_freem(m);  return (error);}u_long	sctp_sendspace = 9216;		/* really max datagram size */					/* 40 1K datagrams */SYSCTL_INT(_net_inet_sctp, SCTPCTL_MAXDGRAM, maxdgram, CTLFLAG_RW,    &sctp_sendspace, 0, "Maximum outgoing SCTP datagram size");u_long	sctp_recvspace = 40 * (1024 +#ifdef INET6				      sizeof(struct sockaddr_in6)#else				      sizeof(struct sockaddr_in)#endif				      );SYSCTL_INT(_net_inet_sctp, SCTPCTL_RECVSPACE, recvspace, CTLFLAG_RW,    &sctp_recvspace, 0, "Maximum incoming SCTP datagram size");static intsctp_abort(struct socket *so){	struct inpcb *inp;	int s;	inp = sotoinpcb(so);	if (inp == 0)		return EINVAL;	/* ??? possible? panic instead? */	soisdisconnected(so);	s = splnet();	in_pcbdetach(inp);	splx(s);	return 0;}static intsctp_attach(struct socket *so, int proto, struct proc *p){	struct inpcb *inp;	int s, error;	inp = sotoinpcb(so);	if (inp != 0)		return EINVAL;	error = soreserve(so, sctp_sendspace, sctp_recvspace);	if (error)		return error;	s = splnet();	error = in_pcballoc(so, &sctpinfo, p);	splx(s);	if (error)		return error;	inp = (struct inpcb *)so->so_pcb;	inp->inp_vflag |= INP_IPV4;	inp->inp_ip_ttl = ip_defttl;#ifdef IPSEC	error = ipsec_init_policy(so, &inp->inp_sp);	if (error != 0) {		in_pcbdetach(inp);		return error;	}#endif /*IPSEC*/	return 0;}static intsctp_bind(struct socket *so, struct sockaddr *nam, struct proc *p){	struct inpcb *inp;	struct sockaddr_in *soaddr;	int s, error;	inp = sotoinpcb(so);	if (inp == 0)		return EINVAL;	if(nam->sa_family == AF_INET){	  /* we only support a port getting ALL addresses */	  soaddr = (struct sockaddr_in *)nam;	  if(soaddr->sin_addr.s_addr != INADDR_ANY)	    soaddr->sin_addr.s_addr = INADDR_ANY;	}	s = splnet();		error = in_pcbbind(inp, nam, p);	splx(s);	return error;}static intsctp_detach(struct socket *so){	struct inpcb *inp;	int s;	inp = sotoinpcb(so);	if (inp == 0)		return EINVAL;	s = splnet();	in_pcbdetach(inp);	splx(s);	return 0;}static intsctp_send(struct socket *so, int flags, struct mbuf *m, struct sockaddr *addr,	    struct mbuf *control, struct proc *p){	struct inpcb *inp;	int error;	/* Got to have a to address */	if(!addr){	  error = EDESTADDRREQ;	  m_freem(m);	  return(error);	}	inp = sotoinpcb(so);	if (inp == 0) {		m_freem(m);		return EINVAL;	}	return sctp_output(inp, m, addr, control, p);}static intsctp_disconnect(struct socket *so){	return EOPNOTSUPP;}intsctp_shutdown(struct socket *so){	struct inpcb *inp;	inp = sotoinpcb(so);	if (inp == 0)		return EINVAL;	socantsendmore(so);	return 0;}struct pr_usrreqs sctp_usrreqs = {	sctp_abort, pru_accept_notsupp, sctp_attach, sctp_bind, pru_connect_notsupp, 	pru_connect2_notsupp, in_control, sctp_detach, sctp_disconnect, 	pru_listen_notsupp, in_setpeeraddr, pru_rcvd_notsupp, 	pru_rcvoob_notsupp, sctp_send, pru_sense_null, sctp_shutdown,	in_setsockaddr, sosend, soreceive, sopoll};