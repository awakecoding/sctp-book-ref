/* * Copyright (c) 2001 Cisco Systems Inc. * Copyright (c) 1982, 1986, 1989, 1993 *	The Regents of the University of California.  All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in the *    documentation and/or other materials provided with the distribution. * 3. All advertising materials mentioning features or use of this software *    must display the following acknowledgement: *	This product includes software developed by the University of *	California, Berkeley and its contributors. * 4. Neither the name of the University nor the names of its contributors *    may be used to endorse or promote products derived from this software *    without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * * $Header: /home/sourceTree/src/sctp/FreeBsdKern/netinet643/sctp6_usrreq.c,v 1.3 2001/04/30 17:57:12 randall Exp $  */#include "opt_inet.h"#include "opt_inet6.h"#include "opt_ipsec.h"#include <sys/param.h>#include <sys/kernel.h>#include <sys/mbuf.h>#include <sys/protosw.h>#include <sys/socket.h>#include <sys/socketvar.h>#include <sys/sysctl.h>#include <sys/errno.h>#include <sys/stat.h>#include <sys/systm.h>#include <sys/syslog.h>#include <sys/proc.h>#include <net/if.h>#include <net/route.h>#include <net/if_types.h>#include <netinet/in.h>#include <netinet/in_systm.h>#include <netinet/ip.h>#include <netinet/in_pcb.h>#include <netinet/in_var.h>#include <netinet/ip_var.h>#include <netinet/sctp.h>#include <netinet/sctp_var.h>#include <netinet/ip6.h>#include <netinet6/ip6_var.h>#include <netinet6/in6_pcb.h>#include <netinet/icmp6.h>#include <netinet6/sctp6_var.h>#include <netinet6/ip6protosw.h>#include <netinet6/nd6.h>#ifdef IPSEC#include <netinet6/ipsec.h>#include <netinet6/ipsec6.h>#endif /*IPSEC*/#include "faith.h"/* * SCTP protocol stub. */extern	struct protosw inetsw[];static	int sctp6_detach __P((struct socket *so));extern int icmp6_ratelimit __P((const struct in6_addr *dst, 				const int type, const int code));					      static voidsctp6_send_abort(struct mbuf *m,		 struct ip6_hdr *oip,		 struct sctphdr *osh,		 int off){  /*   * Formulate the abort message, and send it back down.   */  register struct mbuf *mout;  register struct sctpAbort *abm;  register struct ip6_hdr *iph6;  struct route_in6 ro;  int abtlen;  unsigned int val;  /* Use ICMP rate limit since this is the equivilant of    * sending a no listner ICMP message    */  if(SCTPisThereAnAbortHere(m,off)){    return;  }  if(icmp6_ratelimit(&oip->ip6_dst,		     ICMP6_DST_UNREACH,ICMP6_DST_UNREACH_NOPORT)){    /* Rate limit in effect */    m_freem(m);    return;  }  mout = m_gethdr(M_DONTWAIT, MT_HEADER);  if (mout == NULL){    m_freem(m);    return;  }  abtlen = sizeof(struct sctpAbort) + sizeof(struct ip6_hdr);  mout->m_len = abtlen;  iph6 = mtod(mout, struct ip6_hdr *);  /* Fill in the IP6 header for the ABORT */  iph6->ip6_flow = oip->ip6_flow;  iph6->ip6_hlim = ip6_defhlim;  iph6->ip6_nxt = IPPROTO_SCTP;  iph6->ip6_src = oip->ip6_dst;  iph6->ip6_dst = oip->ip6_src;  iph6->ip6_plen = sizeof(struct sctpAbort);  HTONS(iph6->ip6_plen);  /* Now copy in and fill in the ABORT tags etc. */  /*  osh = (struct sctphdr *) ((caddr_t)oip + (oip->ip_hl << 2));*/  abm = (struct sctpAbort *) ((caddr_t)iph6 + sizeof(struct ip6_hdr));  abm->mh.source = osh->destination;  abm->mh.destination = osh->source;  abm->mh.adler32 = 0;  abm->mh.verificationTag = osh->verificationTag;  abm->uh.chunkID = SCTP_ABORT_ASSOCIATION;  abm->uh.chunkFlg = SCTP_HAD_NO_TCB;  abm->uh.chunkLength = 4;  HTONS(abm->uh.chunkLength);  val = sctp_calc_alder32((unsigned char *)abm,sizeof(struct sctpAbort));  abm->mh.adler32 = HTONL(val);  /* zap the rcvif, it should be null */  mout->m_pkthdr.len = mout->m_len;  mout->m_pkthdr.rcvif = 0;  /* zap the stack pointer to the route */  bzero(&ro, sizeof ro);  /* out it goes */  ip6_output(mout, NULL, &ro, 0, NULL, NULL);  /* Free the route if we got one back */  if (ro.ro_rt)    RTFREE(ro.ro_rt);  m_freem(m);}intsctp6_input(mp, offp, proto)	struct mbuf **mp;	int *offp, proto;{	struct mbuf *m = *mp;	register struct ip6_hdr *ip6;	register struct sctphdr *sh;	register struct inpcb *in6p;	struct	mbuf *opts = 0;	int off = *offp;	struct sockaddr_in6 sctp_in6;#if defined(NFAITH) && 0 < NFAITH	if (m->m_pkthdr.rcvif) {		if (m->m_pkthdr.rcvif->if_type == IFT_FAITH) {			/* XXX send icmp6 host/port unreach? */			m_freem(m);			return IPPROTO_DONE;		}	}#endif	sctpstat.sctp_ipackets++;	IP6_EXTHDR_CHECK(m, off, sizeof(struct sctphdr), IPPROTO_DONE);	ip6 = mtod(m, struct ip6_hdr *);	sh = (struct sctphdr *)((caddr_t)ip6 + off);	if (IN6_IS_ADDR_MULTICAST(&ip6->ip6_dst)) {	  /* No multi-cast support in SCTP */	  sctpstat.sctp_bcastmcast++;	  goto bad;	}	/*	 * Locate pcb for datagram.	 */	in6p = in6_pcblookup_hash(&sctpinfo, &ip6->ip6_src, sh->source,				  &ip6->ip6_dst, sh->destination, 1,				  m->m_pkthdr.rcvif);	if (in6p == 0) {		sctpstat.sctp_noport++;		sctp6_send_abort(m,ip6,sh,off);		return IPPROTO_DONE;	}#ifdef IPSEC	/*	 * Check AH/ESP integrity.	 */	if (ipsec6_in_reject_so(m, in6p->in6p_socket)) {		ipsec6stat.in_polvio++;		goto bad;	}#endif /*IPSEC*/	/*	 * Construct sockaddr format source address.	 * Stuff source address and datagram in user buffer.	 */	init_sin6(&sctp_in6, m); /* general init */	sctp_in6.sin6_port = sh->source;	if (in6p->in6p_flags & IN6P_CONTROLOPTS	    || in6p->in6p_socket->so_options & SO_TIMESTAMP)		ip6_savecontrol(in6p, &opts, ip6, m);	if (sbappendaddr(&in6p->in6p_socket->so_rcv,			(struct sockaddr *)&sctp_in6,			m, opts) == 0) {		sctpstat.sctp_fullsock++;		goto bad;	}	sorwakeup(in6p->in6p_socket);	return IPPROTO_DONE;bad:	if (m)		m_freem(m);	if (opts)		m_freem(opts);	return IPPROTO_DONE;}voidsctp6_notify_mbuf(register struct inpcb *in6p,register struct mbuf *m,		  struct sockaddr *sa){  struct mbuf *mnew;  mnew = m_copym(m, 0,  M_COPYALL, M_DONTWAIT);  if(mnew == NULL){    return;  }  if(sbappendaddr(&in6p->in6p_socket->so_rcv,		  sa, mnew, (struct mbuf *)NULL) == 0) {    sctpstat.sctp_fullsock++;    m_freem(mnew);    return;  }  sorwakeup(in6p->inp_socket);}voidsctp6_ctlinput(cmd, sa, d)	int cmd;	struct sockaddr *sa;	void *d;{  register struct sctphdr *shp;  struct sctphdr sh;  struct sockaddr_in6 sa6;  struct ip6_hdr *ip6;  struct mbuf *m;  int sss;  int off = 0;  void (*notify) __P((struct inpcb *, int)) = sctp_notify;  if (sa->sa_family != AF_INET6 ||      sa->sa_len != sizeof(struct sockaddr_in6))    return;  if ((unsigned)cmd >= PRC_NCMDS)    return;  if (PRC_IS_REDIRECT(cmd))    notify = in6_rtchange, d = NULL;  else if (cmd == PRC_HOSTDEAD)    d = NULL;  else if (inet6ctlerrmap[cmd] == 0)    return;  /* if the parameter is from icmp6, decode it. */  if (d != NULL) {    struct ip6ctlparam *ip6cp = (struct ip6ctlparam *)d;    m = ip6cp->ip6c_m;    ip6 = ip6cp->ip6c_ip6;    off = ip6cp->ip6c_off;  } else {    m = NULL;    ip6 = NULL;  }  /* translate addresses into internal form */  sa6 = *(struct sockaddr_in6 *)sa;  if (IN6_IS_ADDR_LINKLOCAL(&sa6.sin6_addr) && m && m->m_pkthdr.rcvif)    sa6.sin6_addr.s6_addr16[1] = htons(m->m_pkthdr.rcvif->if_index);  if (ip6) {    /*     * XXX: We assume that when IPV6 is non NULL,     * M and OFF are valid.     */    struct in6_addr s;    register struct inpcb *in6p;    /* translate addresses into internal form */    memcpy(&s, &ip6->ip6_src, sizeof(s));    if (IN6_IS_ADDR_LINKLOCAL(&s))      s.s6_addr16[1] = htons(m->m_pkthdr.rcvif->if_index);    /* check if we can safely examine src and dst ports */    if (m->m_pkthdr.len < off + sizeof(sh))      return;    if (m->m_len < off + sizeof(sh)) {      /*       * this should be rare case,       * so we compromise on this copy...       */      m_copydata(m, off, sizeof(sh), (caddr_t)&sh);      shp = &sh;    } else      shp = (struct sctphdr *)(mtod(m, caddr_t) + off);    sss = splnet();    in6p = in6_pcblookup_hash(&sctpinfo, &ip6->ip6_src, shp->source,			      &ip6->ip6_dst, shp->destination, 1,			      m->m_pkthdr.rcvif);    if (in6p != NULL && in6p->in6p_socket != NULL){      if(cmd == PRC_MSGSIZE){	sctp6_notify_mbuf(in6p,m,sa);      }else{	(*notify)(in6p, inet6ctlerrmap[cmd]);      }    }    splx(sss);  }else{    (void) in6_pcbnotify(&sctpdb, (struct sockaddr *)&sa6, 0,			 &zeroin6_addr, 0, cmd, notify);  }}static intsctp6_getcred(SYSCTL_HANDLER_ARGS){	struct sockaddr_in6 addrs[2];	struct inpcb *inp;	int error, s;	error = suser(req->p);	if (error)		return (error);	if (req->newlen != sizeof(addrs))		return (EINVAL);	if (req->oldlen != sizeof(struct ucred))		return (EINVAL);	error = SYSCTL_IN(req, addrs, sizeof(addrs));	if (error)		return (error);	s = splnet();	inp = in6_pcblookup_hash(&sctpinfo, &addrs[1].sin6_addr,				 addrs[1].sin6_port,				 &addrs[0].sin6_addr, addrs[0].sin6_port,				 1, NULL);	if (!inp || !inp->inp_socket) {		error = ENOENT;		goto out;	}	error = SYSCTL_OUT(req, inp->inp_socket->so_cred,			   sizeof(struct ucred));out:	splx(s);	return (error);}SYSCTL_PROC(_net_inet6_sctp6, OID_AUTO, getcred, CTLTYPE_OPAQUE|CTLFLAG_RW,	    0, 0,	    sctp6_getcred, "S,ucred", "Get the ucred of a SCTP6 connection");static intsctp6_abort(struct socket *so){	struct inpcb *inp;	int s;	inp = sotoinpcb(so);	if (inp == 0)		return EINVAL;	/* ??? possible? panic instead? */	soisdisconnected(so);	s = splnet();	in6_pcbdetach(inp);	splx(s);	return 0;}static intsctp6_attach(struct socket *so, int proto, struct proc *p){  struct inpcb *inp;  int s, error;  inp = sotoinpcb(so);  if (inp != 0)    return EINVAL;  if (so->so_snd.sb_hiwat == 0 || so->so_rcv.sb_hiwat == 0) {    error = soreserve(so, sctp_sendspace, sctp_recvspace);    if (error)      return error;  }  s = splnet();  error = in_pcballoc(so, &sctpinfo, p);  splx(s);  if (error)    return error;  inp = (struct inpcb *)so->so_pcb;  inp->inp_vflag |= INP_IPV6;  inp->in6p_hops = -1;	/* use kernel default */  inp->in6p_cksum = -1;	/* just to be sure */  /*   * XXX: ugly!!   * IPv4 TTL initialization is necessary for an IPv6 socket as well,   * because the socket may be bound to an IPv6 wildcard address,   * which may match an IPv4-mapped IPv6 address.   */  inp->inp_ip_ttl = ip_defttl;#ifdef IPSEC  error = ipsec_init_policy(so, &inp->in6p_sp);  if (error != 0) {    in6_pcbdetach(inp);    return (error);  }#endif /*IPSEC*/  return 0;}static intsctp6_bind(struct socket *so, struct sockaddr *nam, struct proc *p){  struct inpcb *inp;  int s, error;  struct sockaddr_in6 *sin6_p;  sin6_p = (struct sockaddr_in6 *)nam;  inp = sotoinpcb(so);  if (inp == 0)    return EINVAL;  /* Your NOT allowed to bind specific addresses :) */  if(sin6_p->sin6_family == AF_INET6){    bzero(&sin6_p->sin6_addr,sizeof(sin6_p->sin6_addr));  }  inp->inp_vflag &= ~INP_IPV4;  inp->inp_vflag |= INP_IPV6;  if ((inp->inp_flags & IN6P_BINDV6ONLY) == 0) {    if (IN6_IS_ADDR_UNSPECIFIED(&sin6_p->sin6_addr))      inp->inp_vflag |= INP_IPV4;    else if (IN6_IS_ADDR_V4MAPPED(&sin6_p->sin6_addr)) {      struct sockaddr_in sin;      in6_sin6_2_sin(&sin, sin6_p);      inp->inp_vflag |= INP_IPV4;      inp->inp_vflag &= ~INP_IPV6;      s = splnet();      error = in_pcbbind(inp, (struct sockaddr *)&sin, p);      splx(s);      return error;    }  }  s = splnet();  error = in6_pcbbind(inp, nam, p);  splx(s);  return error;}static intsctp6_detach(struct socket *so){	struct inpcb *inp;	int s;	inp = sotoinpcb(so);	if (inp == 0)		return EINVAL;	s = splnet();	in6_pcbdetach(inp);	splx(s);	return 0;}static intsctp6_disconnect(struct socket *so){  return ENOTCONN;}voidsctp6_notify_mtu_value(register struct inpcb *in6p,		       struct sockaddr_in6 *src,		       struct sockaddr_in6 *dst,		       int mtu,		       u_int ltag,		       int len){  /* The sender does not know the MTU, we   * must generate a ICMP message just   * like a router would have and send it   * to him.   */  struct mbuf *mout;  struct ip6_hdr *hin,*hbad;  struct icmp6_hdr *icmph;  struct sctphdr *sctp;  MGETHDR(mout, M_DONTWAIT, MT_HEADER);  if(mout == NULL){    /* gak nothing we can do */    return;  }  /* Fill in the pseudo ICMP message to inform   * the upper layer that we have a p-mtu    * problem. This will BREAK if a HDR mbuf is   * ever not big enough to handle our packet, i.e.   * 40 + 40 + 8 + 12 = 100 bytes needs to be available.   */  /* setup the pointers */  hin = mtod(mout, struct ip6_hdr *);  icmph = (struct icmp6_hdr *)((caddr_t)hin + sizeof(struct ip6_hdr));  hbad = (struct ip6_hdr *)((caddr_t)icmph + sizeof(struct icmp6_hdr));  sctp = (struct sctphdr *)((caddr_t)hbad + sizeof(struct ip6_hdr));  /* fix up all the data */  hin->ip6_flow = hbad->ip6_flow = 0;  hin->ip6_vfc = hbad->ip6_vfc = IPV6_VERSION;  hin->ip6_hlim = hbad->ip6_hlim = ip6_defhlim;  hbad->ip6_plen = len - sizeof(struct ip6_hdr);  HTONS(hbad->ip6_plen);    hbad->ip6_nxt = IPPROTO_SCTP;  hin->ip6_nxt = IPPROTO_ICMPV6;  hin->ip6_plen = (sizeof(struct icmp6_hdr) + sizeof(struct sctphdr) +		   sizeof(struct ip6_hdr));   HTONS(hin->ip6_plen);  hin->ip6_src = dst->sin6_addr;  hin->ip6_dst = src->sin6_addr;  hbad->ip6_src = src->sin6_addr;  hbad->ip6_dst = dst->sin6_addr;  icmph->icmp6_type = ICMP6_PACKET_TOO_BIG;  icmph->icmp6_code = 0;  icmph->icmp6_cksum = 0;  icmph->icmp6_mtu = mtu;  HTONL(icmph->icmp6_mtu);  sctp->source = src->sin6_port;  sctp->destination = dst->sin6_port;  sctp->verificationTag = ltag;  sctp->adler32 = 0;  mout->m_len = (sizeof(struct ip6_hdr) + sizeof(struct ip6_hdr) +		 sizeof(struct icmp6_hdr) + sizeof(struct sctphdr));  mout->m_pkthdr.len = mout->m_len;  mout->m_pkthdr.rcvif = 0;  if(sbappendaddr(&in6p->in6p_socket->so_rcv,		  (struct sockaddr *)&src, mout,		  (struct mbuf *)NULL) == 0) {    sctpstat.sctp_fullsock++;    m_freem(mout);    return;  }  sorwakeup(in6p->inp_socket);}intsctp6_output(in6p, m, addr6, control, p)	register struct inpcb *in6p;	register struct mbuf *m;	struct mbuf *control;	struct sockaddr *addr6;	struct proc *p;{  struct ifnet *ifp;  struct sockaddr_in6 *sin6;  struct ip6_hdr *ip6;  struct sctphdr *sctp6;  u_int ltag;  struct	in6_addr *laddr, *faddr;  int error = 0;  struct ip6_pktopts opt, *stickyopt = in6p->in6p_outputopts;  int priv,mtu,outsz;  int flags;  struct sockaddr_in6 tmps,tmpd;  struct route_in6 *rt6;  mtu = priv = 0;  ifp = NULL;  ip6 = mtod(m, struct ip6_hdr *);  if((ip6->ip6_vfc&IPV6_VERSION_MASK) != IPV6_VERSION){    error = EFAULT;    goto release;  }  sctp6 = (struct sctphdr *)(mtod(m, caddr_t) + sizeof(struct ip6_hdr));  if (p && !suser(p)){    priv = 1;  }  if(control){    if ((error = ip6_setpktoptions(control, &opt, priv)) != 0)      goto release;    in6p->in6p_outputopts = &opt;  }  /* Now setup for scoping checks, and later pmtu stuff */  if(addr6){    sin6 =  (struct sockaddr_in6 *)addr6;    tmpd = *sin6;  }else{    tmpd.sin6_len = sizeof(tmpd);    tmpd.sin6_flowinfo = 0;    tmpd.sin6_scope_id = 0;    tmpd.sin6_family = AF_INET6;  }  /* Now go out and copy in the    * specific things from the IP header   */  tmpd.sin6_addr = ip6->ip6_dst;  sin6 = &tmpd;  faddr = &sin6->sin6_addr;  /* KAME hack: embed scopeid */  if (in6_embedscope(&sin6->sin6_addr, sin6, in6p, NULL) != 0){    error = EINVAL;    goto release;  }   /* Now verify the address of src and dst */  if(IN6_IS_ADDR_UNSPECIFIED(faddr)){    /* You MUST have a destination set */    sctpstat.sctp_sendbadaddr++;    error = EFAULT;    goto release;  }else if (IN6_IS_ADDR_V4MAPPED(faddr)){    /* The calling code sctp6_send() should     * have intercepted this to sctp_send.     */    sctpstat.sctp_badpktfmt++;    error = EAFNOSUPPORT;    goto release;  }  /* Now fix up any routing problems that may exist   * since this may have went to the ipv4 side   */  rt6 = &in6p->in6p_route;  if(rt6->ro_dst.sin6_family != AF_INET6){    /* must clear and free it */    if(rt6->ro_rt){      RTFREE(rt6->ro_rt);      rt6->ro_rt = 0;    }  }  /* call select source address, this will   * fix up the routing table entry as well    */  if(IN6_IS_ADDR_UNSPECIFIED(&ip6->ip6_src)){    laddr = in6_selectsrc(sin6, in6p->in6p_outputopts,			  in6p->in6p_moptions,			  &in6p->in6p_route,			  &ip6->ip6_src, &error);    /* something went wrong with source address selection */    if(laddr == 0){      if (error == 0)	error = EADDRNOTAVAIL;      error = EFAULT;      goto release;    }    tmps.sin6_addr = *laddr;    /* What about the source */  }else{    /* validate the source address */    struct ifaddr *ifa;    /* we use ifa_ifwithaddr() here to find the     * interface we will be saying is associated     * with this address. Now this MAY NOT be the     * same that the packet goes out. Also we depend     * on ifa_ifwithaddr() to compare the addresses, it     * does a blanket comparison of the whole sockaddress     * structure for the length sa_len (sin6_len). This     * means that if the sin6_scope_id or sin6_flowinfor     * ever gets populated in the interface's addresses     * we will not match. It seems to match currently, I     * checked with my running 4.2 kernel.. but just     * a word to the wise :-)     */    bzero(&tmps,sizeof(tmps));    tmps.sin6_len = sizeof(tmps);    tmps.sin6_family = AF_INET6;    tmps.sin6_addr = ip6->ip6_src;    /* KAME hack: embed scopeid */    if(IN6_IS_SCOPE_LINKLOCAL(&tmps.sin6_addr)) {	    /* Here we cheat, since our previous call	     * on the destination embedded the scope correctly	     * to our destination, we reuse it since it	     * must be the same.	     */	    tmps.sin6_addr.s6_addr16[1] = tmpd.sin6_addr.s6_addr16[1];    }    ifa = ifa_ifwithaddr((struct sockaddr *)&tmps);    if(ifa == NULL){      /* Sorry no interface with specified source address */      sctpstat.sctp_sendbadaddr++;      error = EFAULT;      goto release;    }    /* Set to null since we don't need to copy     * back on top of the packet.     */    laddr = NULL;  }  /* Update the addresses in the packet with our scopes if link local */  if(IN6_IS_SCOPE_LINKLOCAL(&tmpd.sin6_addr)) {	  ip6->ip6_dst = tmpd.sin6_addr;	  ip6->ip6_src = tmps.sin6_addr;  }  /*   * Check the output datagram for correct source/destination   * information.   */  ltag = sctp6->verificationTag;  /* Is the source port what it should be? */  if((sctp6->source != in6p->in6p_lport) ||     (sctp6->source == 0)){    sctpstat.sctp_sendbadport++;    error = EFAULT;    goto release;  }  /* Is the destination port valid? */  if(sctp6->destination == 0){    sctpstat.sctp_sendbadport++;    error = EADDRNOTAVAIL;      goto release;  }  if(ip6->ip6_flow == 0){    /* set any flow label if not set */    ip6->ip6_flow = in6p->in6p_flowinfo & IPV6_FLOWINFO_MASK;  }  if((ip6->ip6_vfc &IPV6_VERSION_MASK) != IPV6_VERSION){    sctpstat.sctp_badpktfmt++;    error = EFAULT;    goto release;  }  if(ip6->ip6_nxt != IPPROTO_SCTP){    sctpstat.sctp_badpktfmt++;    error = EFAULT;    goto release;  }  /* Kernel selects the Hop limit */  ip6->ip6_hlim	= in6_selecthlim(in6p,				 in6p->in6p_route.ro_rt ?				 in6p->in6p_route.ro_rt->rt_ifp : NULL);  /* Copy in the source address we found earlier */  if(laddr != NULL){    ip6->ip6_src = *laddr;  }  tmps.sin6_port = sctp6->source;  tmpd.sin6_port = sctp6->destination;  flags = 0;  sctpstat.sctp_opackets++;#ifdef IPSEC  ipsec_setsocket(m, in6p->in6p_socket);#endif /*IPSEC*/  outsz = m->m_pkthdr.len;  error = ip6_output(m, in6p->in6p_outputopts, &in6p->in6p_route,		     flags, in6p->in6p_moptions, &ifp);  if(ifp && in6p->in6p_route.ro_rt != NULL) {    mtu = in6p->in6p_route.ro_rt->rt_rmx.rmx_mtu;  }else if(ifp){    mtu = nd_ifinfo[ifp->if_index].linkmtu;  }  if(mtu && mtu < outsz){    /* sender does not know the correct MTU */    sctp6_notify_mtu_value(in6p,&tmps,&tmpd,mtu,ltag,outsz);  }  goto releaseopt; release:  m_freem(m); releaseopt:  if (control){    in6p->in6p_outputopts = stickyopt;    m_freem(control);  }  return(error);}static intsctp6_send(struct socket *so, int flags, struct mbuf *m, struct sockaddr *addr,	  struct mbuf *control, struct proc *p){  struct inpcb *inp;  u_char *data;  struct ip *iph;  int error = 0;  inp = sotoinpcb(so);  if (inp == 0) {    error = EINVAL;    goto bad;  }  /* We can get either IPv6 or IPv4 down the socket.   * If we get IPv6 all is fine, if its V4 re-vector   * otherwise, drop it.   */  data = mtod(m, char *);  if((data[0]&IPV6_VERSION_MASK) == IPV6_VERSION){    error = sctp6_output(inp, m, addr, control, p);    return(error);  }else{    struct pr_usrreqs *pru;    iph = mtod(m, struct ip *);    if(iph->ip_v != IPVERSION){      goto bad;    }    if(addr->sa_family == AF_INET6){      in6_sin6_2_sin_in_sock(addr);    }    pru = inetsw[ip_protox[IPPROTO_SCTP]].pr_usrreqs;    if((pru != NULL) && (pru->pru_send != NULL)){      error = ((*pru->pru_send)(so, flags, m, addr, control,p));    }else{      error = ENOPROTOOPT;    }    return(error);  } bad:  sctpstat.sctp_badpktfmt++;  m_freem(m);  return(error);}struct pr_usrreqs sctp6_usrreqs = {	sctp6_abort, pru_accept_notsupp, sctp6_attach, sctp6_bind, pru_connect_notsupp,	pru_connect2_notsupp, in6_control, sctp6_detach, sctp6_disconnect,	pru_listen_notsupp, in6_mapped_peeraddr, pru_rcvd_notsupp,	pru_rcvoob_notsupp, sctp6_send, pru_sense_null, sctp_shutdown,	in6_mapped_sockaddr, sosend, soreceive, sopoll};